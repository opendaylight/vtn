/*
 * Copyright (c) 2013 NEC Corporation
 * All rights reserved.
 *
 * This program and the accompanying materials are made available under the
 * terms of the Eclipse Public License v1.0 which accompanies this
 * distribution, and is available at http://www.eclipse.org/legal/epl-v10.html
 */

package org.opendaylight.vtn.manager.internal.cluster;

import java.io.Serializable;
import java.net.InetAddress;
import java.net.NetworkInterface;
import java.util.Enumeration;
import java.util.Random;
import java.util.concurrent.atomic.AtomicLong;

import org.slf4j.Logger;
import org.slf4j.LoggerFactory;

import org.opendaylight.vtn.manager.internal.VTNManagerImpl;

import org.opendaylight.controller.clustering.services.
    IClusterContainerServices;
import org.opendaylight.controller.sal.utils.NetUtils;

/**
 * {@code ClusterEventId} describes an identifier of cluster cache event.
 *
 * <p>
 *   Every cluster cache event, which delivers arbitrary event to remote
 *   cluster node, is assigned an cluster event ID which is unique in the
 *   local node. The VTN manager can pick up cluster events generated by the
 *   local node because an node identifier is embedded in every cluster event
 *   ID.
 * </p>
 * <p>
 *   Although this class is public to other packages, this class does not
 *   provide any API. Applications other than VTN Manager must not use this
 *   class.
 * </p>
 */
public class ClusterEventId implements Serializable {
    private static final long serialVersionUID = 1962921552441279134L;

    /**
     * A character which separates fields in a string representation of
     * event ID.
     */
    public static final char  SEPARATOR = '-';

    /**
     * Identifier of the local cluster node.
     */
    private static long  localNodeId;

    /**
     * Event identifier for the next allocation.
     */
    protected static final AtomicLong  nextEventId = new AtomicLong();

    /**
     * Cluster node identifier.
     */
    private final long  nodeId;

    /**
     * Event identifier.
     */
    private final long  eventId;

    /**
     * Initialize local node identifier.
     *
     * @param mgr  VTN Manager service.
     */
    public static synchronized void initLocalNodeId(VTNManagerImpl mgr) {
        if (localNodeId != 0) {
            return;
        }

        // Create local node ID from the controller's MAC address.
        Logger logger = LoggerFactory.getLogger(ClusterEventId.class);
        IClusterContainerServices cluster = mgr.getClusterContainerService();
        InetAddress myAddr = (cluster == null) ? null : cluster.getMyAddress();
        if (myAddr == null) {
            logger.warn("Failed to get local InetAddress in the cluster");
        }
        long id = getMacAddress(logger, myAddr);
        if (id == 0) {
            // Use random value as identifier.
            logger.error("No network interface found");
            Random rand = new Random();
            do {
                id = rand.nextLong();
            } while (id == 0);
        }

        localNodeId = id;
        logger.debug("Local node ID: " + Long.toHexString(localNodeId));
    }

    /**
     * Return MAC address of the local cluster node.
     *
     * <p>
     *   If an IP address is passed to {@code myAddr}, this method tries to
     *   find a network interface associated with the specified IP address.
     * </p>
     *
     * @param logger  A logger instance.
     * @param myAddr  IP address of the network interrace.
     * @return  A long value which represents MAC address of the local
     *          cluster node. Zero is returned on failure.
     */
    private static long getMacAddress(Logger logger, InetAddress myAddr) {
        Enumeration<NetworkInterface> en;
        try {
            en = NetworkInterface.getNetworkInterfaces();
        } catch (Exception e) {
            logger.error("Failed to get network interface list", e);
            return 0;
        }

        long firstAddr = 0;
        while (en.hasMoreElements()) {
            NetworkInterface ni = en.nextElement();
            try {
                if (ni.isUp() && !ni.isLoopback() && !ni.isVirtual()) {
                    byte[] addr = ni.getHardwareAddress();
                    long mac = NetUtils.byteArray6ToLong(addr);
                    if (mac == 0) {
                        continue;
                    }
                    if (firstAddr == 0) {
                        firstAddr = mac;
                    }

                    if (myAddr != null) {
                        Enumeration<InetAddress> ien = ni.getInetAddresses();
                        while (ien.hasMoreElements()) {
                            InetAddress iaddr = ien.nextElement();
                            if (myAddr.equals(iaddr)) {
                                return mac;
                            }
                        }
                    }
                }
            } catch (Exception e) {
                logger.warn("Failed to get network interface: " + ni.getName(),
                            e);
            }
        }

        return firstAddr;
    }

    /**
     * Construct a new cluster event identifier.
     *
     * <p>
     *   This constructor uses the local cluster node ID as the node ID, and
     *   assigns a new event ID.
     * </p>
     */
    public ClusterEventId() {
        nodeId = localNodeId;
        eventId = nextEventId.getAndIncrement();
    }

    /**
     * Construct a new cluster event identifier specifying node and event ID.
     *
     * @param node   The node ID.
     * @param event  The event ID.
     */
    public ClusterEventId(long node, long event) {
        nodeId = node;
        eventId = event;
    }

    /**
     * Return a node identifier.
     *
     * @return  A node identifier in this event ID.
     */
    public long getNodeId() {
        return nodeId;
    }

    /**
     * Return an event identifier.
     *
     * @return  An event identifier in this event ID.
     */
    public long getEventId() {
        return eventId;
    }

    /**
     * Determine whether this event ID is generated by the local cluster node
     * or not.
     *
     * @return  {@code true} is returned if this event ID is generated by the
     *          local cluster node. Otherwise {@code false} is returned.
     */
    public boolean isLocal() {
        return (nodeId == localNodeId);
    }

    /**
     * Determine whether the given object is identical to this object.
     *
     * @param o  An object to be compared.
     * @return   {@code true} if identical. Otherwise {@code false}.
     */
    @Override
    public boolean equals(Object o) {
        if (o == this) {
            return true;
        }
        if (!(o instanceof ClusterEventId)) {
            return false;
        }

        ClusterEventId evid = (ClusterEventId)o;
        return (nodeId == evid.nodeId && eventId == evid.eventId);
    }


    /**
     * Return the hash code of this object.
     *
     * @return  The hash code.
     */
    @Override
    public int hashCode() {
        int h = (int)((nodeId ^ (nodeId >>> 32)) +
                      (eventId ^ (eventId >>> 32)));
        return h;
    }

    /**
     * Return a string representation of this object.
     *
     * @return  A string representation of this object.
     */
    @Override
    public String toString() {
        StringBuilder builder = new StringBuilder(Long.toHexString(nodeId));
        builder.append(SEPARATOR).append(eventId);
        return builder.toString();
    }
}
