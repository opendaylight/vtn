diff --git manager/implementation/src/test/java/org/opendaylight/vtn/manager/internal/ArpHandlerTest.java manager/implementation/src/test/java/org/opendaylight/vtn/manager/internal/ArpHandlerTest.java
new file mode 100644
index 0000000..b23e047
--- /dev/null
+++ manager/implementation/src/test/java/org/opendaylight/vtn/manager/internal/ArpHandlerTest.java
@@ -0,0 +1,423 @@
+/*
+ * Copyright (c) 2013 NEC Corporation
+ * All rights reserved.
+ *
+ * This program and the accompanying materials are made available under the
+ * terms of the Eclipse Public License v1.0 which accompanies this
+ * distribution, and is available at http://www.eclipse.org/legal/epl-v10.html
+ */
+package org.opendaylight.vtn.manager.internal;
+
+
+import java.net.InetAddress;
+import java.net.UnknownHostException;
+import java.util.Arrays;
+import java.util.HashSet;
+import java.util.List;
+import java.util.Set;
+
+import org.junit.BeforeClass;
+import org.junit.Test;
+import org.opendaylight.controller.hosttracker.hostAware.HostNodeConnector;
+import org.opendaylight.controller.sal.core.ConstructionException;
+import org.opendaylight.controller.sal.core.Node;
+import org.opendaylight.controller.sal.core.NodeConnector;
+import org.opendaylight.controller.sal.packet.ARP;
+import org.opendaylight.controller.sal.packet.Ethernet;
+import org.opendaylight.controller.sal.packet.Packet;
+import org.opendaylight.controller.sal.packet.PacketResult;
+import org.opendaylight.controller.sal.packet.RawPacket;
+import org.opendaylight.controller.sal.packet.address.EthernetAddress;
+import org.opendaylight.controller.sal.utils.EtherTypes;
+import org.opendaylight.controller.sal.utils.NodeConnectorCreator;
+import org.opendaylight.controller.sal.utils.NodeCreator;
+import org.opendaylight.controller.switchmanager.ISwitchManager;
+import org.opendaylight.controller.switchmanager.SubnetConfig;
+import org.opendaylight.vtn.manager.VBridgePath;
+
+
+public class ArpHandlerTest extends VTNManagerImplTestCommon {
+
+    private byte[] defaultIp = new byte[] {(byte)192, (byte)168, (byte)0, (byte)250};
+    private byte[] gwIp = new byte[] {(byte)192, (byte)168, (byte)0, (byte)254};
+    private byte[] hostIp = new byte[] {(byte)192, (byte)168, (byte)0, (byte)251};
+    private byte[] hostmac = new byte [] { 0x00, 0x00, 0x00, 0x11, 0x22, 0x33};
+
+    @BeforeClass
+    public static void beforeClass() {
+        stubMode = 1;
+    }
+
+    /**
+     * test case for {@link ArpHander#receive}
+     */
+    @Test
+    public void testReceive() {
+        VTNManagerImpl mgr = vtnMgr;
+        TestStub stub = stubObj;
+        ISwitchManager swmgr = mgr.getSwitchManager();
+
+        Set<Node> existNodes = swmgr.getNodes();
+        Set<NodeConnector> existConnectors = new HashSet<NodeConnector>();
+        for (Node node: existNodes) {
+            existConnectors.addAll(swmgr.getNodeConnectors(node));
+        }
+
+        Set<Node> testNodes = new HashSet<Node>(existNodes);
+        testNodes.add(null);
+
+        for (Node node: testNodes) {
+            int numMapped = 0;
+            Set<NodeConnector> mappedThis = new HashSet<NodeConnector>();
+            Set<NodeConnector> noMappedThis = new HashSet<NodeConnector>(existConnectors);
+
+            Set<String> ncstr = new HashSet<String>();
+            if (node != null) {
+                    for (NodeConnector nc : swmgr.getNodeConnectors(node)) {
+                        ncstr.add(nc.getNode().toString() + "/" + nc.getID());
+                    }
+                    mappedThis.addAll(swmgr.getNodeConnectors(node));
+            } else {
+                mappedThis.addAll(existConnectors);
+            }
+
+            SubnetConfig sconf = new SubnetConfig("test", "192.168.0.254/24", ncstr);
+            swmgr.addSubnet(sconf);
+
+            noMappedThis.removeAll(mappedThis);
+            numMapped = mappedThis.size();
+
+            // null
+            PacketResult result = mgr.receiveDataPacket(null);
+            assertEquals(PacketResult.IGNORED, result);
+
+            testReceiveDataPacketBCLoop(mgr, null, (short)0,
+                    mappedThis, noMappedThis, stub);
+
+            testReceiveDataPacketARPReplyReceive(mgr, null, (short)0,
+                    mappedThis, noMappedThis, stub);
+
+            testReceiveDataPacketBCLoopMatch(mgr, null, (short)0,
+                    mappedThis, noMappedThis, stub);
+
+            testReceiveDataPacketBCLoopToCont(mgr, null, (short)0,
+                    mappedThis, noMappedThis, stub);
+
+            testReceiveDataPacketUCLoop(mgr, null, (short)0,
+                    mappedThis, noMappedThis, stub);
+        }
+    }
+
+    /**
+     * test case for {@link ArpHander#probe} and {@link ArpHander#find}
+     */
+    @Test
+    public void testFindProbe() {
+        VTNManagerImpl mgr = vtnMgr;
+        TestStub stub = stubObj;
+        ISwitchManager swmgr = mgr.getSwitchManager();
+
+        Set<Node> existNodes = swmgr.getNodes();
+        Set<NodeConnector> existConnectors = new HashSet<NodeConnector>();
+        for (Node node: existNodes) {
+            existConnectors.addAll(swmgr.getNodeConnectors(node));
+        }
+
+        Set<Node> testNodes = new HashSet<Node>(existNodes);
+        testNodes.add(null);
+
+        InetAddress ia6 = null;
+        try {
+            ia6 = InetAddress.getByAddress(new byte[]{
+                    (byte)0x20, (byte)0x01, (byte)0x04, (byte)0x20,
+                    (byte)0x02, (byte)0x81, (byte)0x10, (byte)0x04,
+                    (byte)0x0e1, (byte)0x23, (byte)0xe6, (byte)0x88,
+                    (byte)0xd6, (byte)0x55, (byte)0xa1, (byte)0xb0});
+        } catch (UnknownHostException e) {
+            unexpected(e);
+        }
+
+        InetAddress ia = null;
+        try {
+            ia = InetAddress.getByAddress(new byte[] {
+                    (byte)10, (byte)0, (byte)0, (byte)1});
+        } catch (UnknownHostException e) {
+            unexpected(e);
+        }
+        for (Node node: testNodes) {
+            int numMapped = 0;
+            Set<NodeConnector> mappedThis = new HashSet<NodeConnector>();
+            Set<NodeConnector> noMappedThis = new HashSet<NodeConnector>(existConnectors);
+
+            Set<String> ncstr = new HashSet<String>();
+            if (node != null) {
+                    for (NodeConnector nc : swmgr.getNodeConnectors(node)) {
+                        ncstr.add(nc.getNode().toString() + "/" + nc.getID());
+                    }
+                    mappedThis.addAll(swmgr.getNodeConnectors(node));
+            } else {
+                mappedThis.addAll(existConnectors);
+            }
+
+            SubnetConfig sconf = new SubnetConfig("test", "192.168.0.254/24", ncstr);
+            swmgr.addSubnet(sconf);
+
+            noMappedThis.removeAll(mappedThis);
+            numMapped = mappedThis.size();
+
+            mgr.find(ia);
+
+            List<RawPacket> transDatas = stub.getTransmittedDataPacket();
+            assertEquals(numMapped, transDatas.size());
+
+            for (RawPacket raw : transDatas) {
+                Packet pkt = stub.decodeDataPacket(raw);
+                assertTrue(raw.getOutgoingNodeConnector().toString(),
+                        mappedThis.contains(raw.getOutgoingNodeConnector()));
+                assertFalse(raw.getOutgoingNodeConnector().toString(),
+                        noMappedThis.contains(raw.getOutgoingNodeConnector()));
+
+                Ethernet eth = (Ethernet)pkt;
+
+                checkOutEthernetPacket("", eth, EtherTypes.ARP,
+                    swmgr.getControllerMAC(), new byte[] {-1, -1, -1, -1, -1, -1},
+                    (short)0, EtherTypes.IPv4, ARP.REQUEST,
+                    swmgr.getControllerMAC(), new byte[] {0, 0, 0, 0, 0, 0},
+                    gwIp, ia.getAddress());
+            }
+        }
+
+        // probe()
+        for (Node node: existNodes) {
+            byte [] mac = new byte [] { 0x00, 0x00, 0x00, 0x11, 0x22, 0x33};
+            NodeConnector nc = NodeConnectorCreator.createOFNodeConnector(Short.valueOf("10"), node);
+            HostNodeConnector hnode = null;
+            try {
+                hnode = new HostNodeConnector(mac, ia, nc, (short)0);
+            } catch (ConstructionException e) {
+                unexpected(e);
+            }
+
+            mgr.probe(hnode);
+
+            List<RawPacket> transDatas = stub.getTransmittedDataPacket();
+            assertEquals(1, transDatas.size());
+
+            RawPacket raw = transDatas.get(0);
+            assertEquals(nc, raw.getOutgoingNodeConnector());
+
+            Ethernet eth = (Ethernet)stub.decodeDataPacket(raw);
+            checkOutEthernetPacket("", eth, EtherTypes.ARP,
+                    swmgr.getControllerMAC(), mac,
+                    (short)0, EtherTypes.IPv4, ARP.REQUEST,
+                    swmgr.getControllerMAC(), mac,
+                    gwIp, ia.getAddress());
+            }
+
+        // if null
+        mgr.probe(null);
+    }
+
+
+    // private methods
+
+    private void testReceiveDataPacketBCLoop(VTNManagerImpl mgr, VBridgePath bpath,
+            short vlan, Set<NodeConnector> mappedThis, Set<NodeConnector> noMappedThis,
+            TestStub stub) {
+         testReceiveDataPacketAHCommonLoop(mgr, bpath, vlan,
+                 mappedThis, noMappedThis, stub, (short)1, EtherTypes.ARP, ARP.REQUEST, null, defaultIp);
+    }
+
+    private void testReceiveDataPacketUCLoop(VTNManagerImpl mgr, VBridgePath bpath,
+            short vlan, Set<NodeConnector> mappedThis, Set<NodeConnector> noMappedThis,
+            TestStub stub) {
+        testReceiveDataPacketAHCommonLoop(mgr, bpath, vlan,
+                mappedThis, noMappedThis, stub, (short)0, EtherTypes.IPv4, (short)-1, null, defaultIp);
+    }
+
+    private void testReceiveDataPacketBCLoopMatch(VTNManagerImpl mgr, VBridgePath bpath,
+            short vlan, Set<NodeConnector> mappedThis, Set<NodeConnector> noMappedThis,
+            TestStub stub) {
+         testReceiveDataPacketAHCommonLoop(mgr, bpath, vlan,
+                 mappedThis, noMappedThis, stub, (short)1, EtherTypes.ARP, ARP.REQUEST, null, hostIp);
+     }
+
+    private void testReceiveDataPacketBCLoopToCont(VTNManagerImpl mgr, VBridgePath bpath,
+            short vlan, Set<NodeConnector> mappedThis, Set<NodeConnector> noMappedThis,
+            TestStub stub) {
+         testReceiveDataPacketAHCommonLoop(mgr, bpath, vlan,
+                 mappedThis, noMappedThis, stub, (short)1, EtherTypes.ARP, ARP.REQUEST, null, gwIp);
+     }
+
+    private void testReceiveDataPacketARPReplyReceive(VTNManagerImpl mgr, VBridgePath bpath,
+            short vlan, Set<NodeConnector> mappedThis, Set<NodeConnector> noMappedThis,
+            TestStub stub) {
+         testReceiveDataPacketAHCommonLoop(mgr, bpath, vlan,
+                 mappedThis, noMappedThis, stub, (short)1, EtherTypes.ARP, ARP.REPLY, null, defaultIp);
+     }
+
+    /**
+     * common method for ReceiveDataPacket test using ARPHandler.
+     */
+    private void testReceiveDataPacketAHCommonLoop(VTNManagerImpl mgr, VBridgePath bpath,
+            short vlan, Set<NodeConnector> mappedThis, Set<NodeConnector> noMappedThis,
+            TestStub stub, short isBc, EtherTypes ethType, short arpType,
+            NodeConnector targetnc, byte [] targetIp) {
+
+        ISwitchManager swmgr = mgr.getSwitchManager();
+        byte[] target = targetIp;
+        Node hostnode = NodeCreator.createOFNode(Long.valueOf(0));
+        NodeConnector hostnc = NodeConnectorCreator.createOFNodeConnector(Short.valueOf("10"), hostnode);
+        List<EthernetAddress> ethers = createEthernetAddresses(false);
+        boolean isFirst = true;
+
+        for (NodeConnector nc: mappedThis) {
+            if (targetnc != null && !targetnc.equals(nc)) {
+                continue;
+            }
+            byte iphost = 1;
+            for (EthernetAddress ea: ethers) {
+                byte[] bytes = ea.getValue();
+                byte [] src;
+                byte [] dst;
+                byte [] sender;
+                if (arpType == ARP.REPLY) {
+                    dst = new byte[] {bytes[0], bytes[1], bytes[2],
+                            bytes[3], bytes[4], bytes[5]};
+                    src = new byte[] {(byte)0x00, (byte)0x00, (byte)0x00,
+                            (byte)0xff, (byte)0xff, (byte)0x11};
+                    target = new byte[] {(byte)192, (byte)168, (byte)0, (byte)iphost};
+                    sender = targetIp;
+                } else {
+                    src = new byte[] {bytes[0], bytes[1], bytes[2],
+                            bytes[3], bytes[4], bytes[5]};
+                    if (isBc > 0) {
+                        dst = new byte[] {(byte)0xff, (byte)0xff, (byte)0xff,
+                                (byte)0xff, (byte)0xff, (byte)0xff};
+                    } else {
+                        dst = new byte[] {(byte)0x00, (byte)0x00, (byte)0x00,
+                                (byte)0xff, (byte)0xff, (byte)0x11};
+                    }
+                    sender = new byte[] {(byte)192, (byte)168, (byte)0, (byte)iphost};
+                }
+
+                RawPacket inPkt = null;
+                if (ethType.shortValue() == EtherTypes.IPv4.shortValue()) {
+                    inPkt = createIPv4RawPacket(src, dst, sender, target,
+                            (vlan > 0) ? vlan : -1, nc);
+                } else if (ethType.shortValue() == EtherTypes.ARP.shortValue()){
+                    inPkt = createARPRawPacket(src, dst, sender, target,
+                            (vlan > 0) ? vlan : -1, nc, arpType);
+                }
+                Ethernet inPktDecoded = (Ethernet)stub.decodeDataPacket(inPkt);
+                PacketResult result = mgr.receiveDataPacket(inPkt);
+
+                if (nc != null &&
+                        nc.getType() == NodeConnector.NodeConnectorIDType.OPENFLOW) {
+                    if (isFirst) {
+                        assertEquals(nc.toString() + ea.toString(), PacketResult.KEEP_PROCESSING, result);
+                    } else {
+                        assertEquals(nc.toString() + ea.toString(), PacketResult.IGNORED, result);
+                    }
+
+                    Packet payload = inPktDecoded.getPayload();
+                    if (inPktDecoded.getEtherType() == EtherTypes.VLANTAGGED.shortValue()) {
+                        payload = payload.getPayload();
+                    }
+
+                    List<RawPacket> transDatas = stub.getTransmittedDataPacket();
+                    if ((Arrays.equals(target, hostIp) || Arrays.equals(target, gwIp)) &&
+                            arpType != ARP.REPLY) {
+                        assertEquals(nc.toString() + "," + ea.toString(), 1, transDatas.size());
+                    } else if (ethType.shortValue() == EtherTypes.ARP.shortValue() &&
+                            arpType == ARP.REPLY) {
+                        if (isFirst) {
+                            assertEquals(nc.toString() + "," + ea.toString(),
+                                mappedThis.size() * ethers.size(), transDatas.size());
+                            isFirst = false;
+                        } else {
+                            assertEquals(nc.toString() + "," + ea.toString(),
+                                    0, transDatas.size());
+                        }
+                    } else {
+                        assertEquals(nc.toString() + "," + ea.toString(),
+                                mappedThis.size(), transDatas.size());
+                    }
+
+                    for (RawPacket raw: transDatas) {
+                        Packet pkt = stub.decodeDataPacket(raw);
+                        assertTrue(nc.toString() + ea.toString() + raw.getOutgoingNodeConnector(),
+                                mappedThis.contains(raw.getOutgoingNodeConnector()));
+                        assertFalse(nc.toString() + ea.toString() + raw.getOutgoingNodeConnector(),
+                                noMappedThis.contains(raw.getOutgoingNodeConnector()));
+
+                        if (Arrays.equals(target, hostIp) || Arrays.equals(target, gwIp)) {
+                            assertEquals(nc.toString() + ea.toString() + raw.getOutgoingNodeConnector(),
+                                    nc, raw.getOutgoingNodeConnector());
+                        }
+
+                        if (ethType.shortValue() == EtherTypes.IPv4.shortValue()) {
+                            // send ARP Request
+                            checkOutEthernetPacket(nc.toString() + "," + ea.toString(),
+                                    (Ethernet)pkt, EtherTypes.ARP,
+                                    swmgr.getControllerMAC(), new byte[] {-1, -1, -1, -1, -1, -1}, vlan,
+                                    EtherTypes.IPv4, ARP.REQUEST,
+                                    swmgr.getControllerMAC(),
+                                    new byte[] {0, 0, 0, 0, 0, 0},
+                                    gwIp, target);
+                        } else if (ethType.shortValue() == EtherTypes.ARP.shortValue() &&
+                                arpType == ARP.REQUEST && Arrays.equals(target, hostIp) ){
+                            // in this case receive ARP Reply
+                            checkOutEthernetPacket(nc.toString() + "," + ea.toString(),
+                                    (Ethernet)pkt, EtherTypes.ARP,
+                                    hostmac, src, vlan,
+                                    EtherTypes.IPv4, ARP.REPLY,
+                                    hostmac, src, target, sender);
+                        } else if (ethType.shortValue() == EtherTypes.ARP.shortValue() &&
+                                arpType == ARP.REQUEST && Arrays.equals(target, gwIp)){
+                            // in this case receive ARP Reply
+                            checkOutEthernetPacket(nc.toString() + "," + ea.toString(),
+                                    (Ethernet)pkt, EtherTypes.ARP,
+                                    swmgr.getControllerMAC(),
+                                    src, vlan,
+                                    EtherTypes.IPv4, ARP.REPLY,
+                                    swmgr.getControllerMAC(),
+                                    src,
+                                    target, sender);
+                        } else if (ethType.shortValue() == EtherTypes.ARP.shortValue() &&
+                                    arpType == ARP.REQUEST){
+                            // in this case flooded
+                            checkOutEthernetPacket(nc.toString() + "," + ea.toString(),
+                                    (Ethernet)pkt, EtherTypes.ARP,
+                                    swmgr.getControllerMAC(), dst, vlan,
+                                    EtherTypes.IPv4, ARP.REQUEST,
+                                    swmgr.getControllerMAC(),
+                                    new byte[] {0, 0, 0, 0, 0, 0},
+                                    gwIp, target);
+                        } else if (ethType.shortValue() == EtherTypes.ARP.shortValue() &&
+                                    arpType == ARP.REPLY){
+                            // in this case flooded
+                            checkOutEthernetPacket(nc.toString() + "," + ea.toString(),
+                                    (Ethernet)pkt, EtherTypes.ARP,
+                                    src, null, vlan,
+                                    EtherTypes.IPv4, ARP.REPLY,
+                                    src,
+                                    null,
+                                    sender, null);
+                        } else {
+                            fail("unexepcted packet received.");
+                        }
+                    }
+                } else {
+                    if (nc != null) {
+                        assertEquals(nc.toString() + "," + ea.toString(), PacketResult.IGNORED, result);
+                    } else {
+                        assertEquals(ea.toString(), PacketResult.IGNORED, result);
+                    }
+                }
+                iphost++;
+            }
+        }
+    }
+
+}
diff --git manager/implementation/src/test/java/org/opendaylight/vtn/manager/internal/MacAddressTableTest.java manager/implementation/src/test/java/org/opendaylight/vtn/manager/internal/MacAddressTableTest.java
new file mode 100644
index 0000000..c0ecb3b
--- /dev/null
+++ manager/implementation/src/test/java/org/opendaylight/vtn/manager/internal/MacAddressTableTest.java
@@ -0,0 +1,420 @@
+/*
+ * Copyright (c) 2013 NEC Corporation
+ * All rights reserved.
+ *
+ * This program and the accompanying materials are made available under the
+ * terms of the Eclipse Public License v1.0 which accompanies this
+ * distribution, and is available at http://www.eclipse.org/legal/epl-v10.html
+ */
+
+package org.opendaylight.vtn.manager.internal;
+
+import java.net.InetAddress;
+import java.net.UnknownHostException;
+import java.util.Hashtable;
+import java.util.List;
+import java.util.Set;
+
+import org.apache.felix.dm.impl.ComponentImpl;
+import org.junit.AfterClass;
+import org.junit.BeforeClass;
+import org.junit.Test;
+
+import org.opendaylight.controller.sal.core.NodeConnector;
+import org.opendaylight.controller.sal.packet.ARP;
+import org.opendaylight.controller.sal.packet.address.EthernetAddress;
+import org.opendaylight.vtn.manager.MacAddressEntry;
+import org.opendaylight.vtn.manager.VTNException;
+
+/**
+ * JUnit test for {@link MacAddressTable}
+ */
+public class MacAddressTableTest extends TestBase {
+    private static VTNManagerImpl vtnMgr = null;
+
+    /**
+     * setup a test environment for MacAddressTableTest
+     */
+    @BeforeClass
+    public static void beforeClass() {
+        vtnMgr = new VTNManagerImpl();
+        ComponentImpl c = new ComponentImpl(null, null, null);
+        GlobalResourceManager grsc = new GlobalResourceManager();
+
+        Hashtable<String, String> properties = new Hashtable<String, String>();
+        properties.put("containerName", "default");
+        c.setServiceProperties(properties);
+
+        grsc.init(c);
+        vtnMgr.init(c);
+        vtnMgr.setResourceManager(grsc);
+    }
+
+    /**
+     * cleanup a test environment
+     */
+    @AfterClass
+    public static void afterClass() {
+        // nothing to do.
+    }
+
+    /**
+     * Test case for {@link MacAddressTable#getTableKey(byte [])}
+     */
+    @Test
+    public void testGetTableKey() {
+        for (EthernetAddress ea: createEthernetAddresses(false)) {
+            byte [] value = ea.getValue();
+            Long lvalue = MacAddressTable.getTableKey(ea.getValue());
+
+            int len = value.length;
+            for (int i = 0; i < len; i++) {
+                assertTrue(value[len - i - 1] == (byte)((lvalue.longValue() >> (i * 8)) & 0xff));
+            }
+            assertTrue(lvalue.longValue() < (long)(1L << (len * 8)));
+        }
+    }
+
+    /**
+     * Test case for {@link MacAddressTable#MacAddressTable(VTNManagerImpl, String, int)} and
+     * {@link MacAddressTable#destroy()}
+     */
+    @Test
+    public void testMacAddressTable() {
+        VTNManagerImpl mgr = vtnMgr;
+
+        MacAddressTable tbl = new MacAddressTable(mgr, "Table", 600);
+        assertNotNull(tbl);
+        tbl.destroy(mgr);
+
+        tbl = new MacAddressTable(mgr, "Table", 10);
+        assertNotNull(tbl);
+        tbl.destroy(mgr);
+
+        tbl = new MacAddressTable(mgr, "Table", 1000000);
+        assertNotNull(tbl);
+        tbl.destroy(mgr);
+    }
+
+    /**
+     * Test case for {@link MacAddressTable#setAgeInterval(VTNManagerImpl, int)}
+     */
+    @Test
+    public void testSetAgeInterval() {
+        VTNManagerImpl mgr = vtnMgr;
+
+        MacAddressTable tbl = new MacAddressTable(mgr, "Table", 600);
+        tbl.setAgeInterval(mgr, 10);
+        tbl.setAgeInterval(mgr, 1000000);
+        tbl.setAgeInterval(mgr, 1000000);
+        tbl.destroy(mgr);
+    }
+
+    /**
+     * Test case for
+     * {@link MacAddressTable#add(VTNManagerImpl, PacketContext)},
+     * {@link MacAddressTable#get(PacketContext)},
+     * {@link MacAddressTable#remove(PacketContext)},
+     * {@link MacAddressTable#getEntry(DataLinkAddress)},
+     * {@link MacAddressTable#getEntries()}
+     */
+    @Test
+    public void testAddGetRemoveEntry() {
+        VTNManagerImpl mgr = vtnMgr;
+        MacAddressTable tbl = new MacAddressTable(mgr, "Table", 600);
+        MacAddressTable tall = new MacAddressTable(mgr, "Table", 600);
+        MacTableEntry tent = null;
+        MacAddressEntry mae = null;
+
+        byte iphost = 1;
+        short vlan = 4095;
+        List<NodeConnector> connectors = createNodeConnectors(3, false);
+
+        for (EthernetAddress ea: createEthernetAddresses(false)) {
+            byte [] bytes = ea.getValue();
+            byte [] src = new byte[] {bytes[0], bytes[1], bytes[2],
+                                        bytes[3], bytes[4], bytes[5]};
+            byte [] dst = new byte[] {(byte)0xff, (byte)0xff, (byte)0xff,
+                                        (byte)0xff, (byte)0xff, (byte)0xff};
+            byte [] sender = new byte[] {(byte)192, (byte)168, (byte)0, (byte)iphost};
+            byte [] sender2 = new byte[] {(byte)192, (byte)168, (byte)0, (byte)(iphost + 100)};
+            byte [] target = new byte[] {(byte)192, (byte)168, (byte)0, (byte)250};
+
+            // default
+            PacketContext dpctx = createARPPacketContext(src, dst, sender, target,
+                                          (short)-1, connectors.get(0), ARP.REQUEST);
+            // replaced src and dst
+            PacketContext rpctx = createARPPacketContext(dst, src, target, sender,
+                                          (short)-1, connectors.get(0), ARP.REQUEST);
+            // different sender address
+            PacketContext ippctx = createARPPacketContext(src, dst, sender2, target,
+                                          (short)-1, connectors.get(0), ARP.REQUEST);
+            // have vlan tag
+            PacketContext vlanpctx = createARPPacketContext(src, dst, sender, target,
+                                          vlan, connectors.get(0), ARP.REQUEST);
+            // different node connector
+            PacketContext ncpctx = createARPPacketContext(src, dst, sender, target,
+                                          (short)-1, connectors.get(1), ARP.REQUEST);
+
+            // get from empty table.
+            tent = tbl.get(dpctx);
+            assertNull(tent);
+            try {
+                mae = tbl.getEntry(ea);
+            } catch (VTNException e) {
+                unexpected(e);
+            }
+            assertNull(mae);
+
+            // add() and get() one data
+            tbl.add(mgr, dpctx);
+            tent = tbl.get(dpctx);
+            assertNull(tent);
+            tent = tbl.get(rpctx);
+            assertNotNull(tent);
+            assertTrue(tent.clearUsed());
+            assertEquals(connectors.get(0), tent.getPort());
+            assertEquals(0, tent.getVlan());
+
+            // getEntry()
+            try {
+                mae = tbl.getEntry(ea);
+            } catch (VTNException e) {
+                unexpected(e);
+            }
+            assertNotNull(mae);
+            assertEquals(ea, mae.getAddress());
+            assertEquals(0, mae.getVlan());
+            assertEquals(connectors.get(0), mae.getNodeConnector());
+            Set<InetAddress> iplist = mae.getInetAddresses();
+            assertTrue(iplist.size() == 1);
+            assertArrayEquals(sender, iplist.iterator().next().getAddress());
+
+            // add same packet
+            assertFalse(tent.clearUsed());
+            tbl.add(mgr, dpctx);
+            assertTrue(tent.clearUsed());
+
+            // add packet IP changed
+            tbl.add(mgr, ippctx);
+            tent = tbl.get(rpctx);
+            assertNotNull(tent);
+            assertEquals(connectors.get(0), tent.getPort());
+            assertEquals(0, tent.getVlan());
+            try {
+                mae = tbl.getEntry(ea);
+            } catch (VTNException e) {
+                unexpected(e);
+            }
+            iplist = mae.getInetAddresses();
+            assertTrue(iplist.size() == 2);
+            InetAddress ip = null, ip2 = null;
+            try {
+                ip = InetAddress.getByAddress(sender);
+                ip2 = InetAddress.getByAddress(sender2);
+            } catch (UnknownHostException e) {
+                unexpected(e);
+            }
+            assertTrue(iplist.contains(ip));
+            assertTrue(iplist.contains(ip2));
+            assertFalse(ip.equals(ip2));
+
+            tbl.add(mgr, dpctx);
+
+            // add packet vlan changed
+            tbl.add(mgr, vlanpctx);
+            tent = tbl.get(rpctx);
+            assertNotNull(tent);
+            assertEquals(connectors.get(0), tent.getPort());
+            assertEquals(vlan, tent.getVlan());
+            try {
+                mae = tbl.getEntry(ea);
+            } catch (VTNException e) {
+                unexpected(e);
+            }
+            iplist = mae.getInetAddresses();
+            assertTrue(iplist.size() == 1);
+            assertArrayEquals(sender, iplist.iterator().next().getAddress());
+
+            tbl.add(mgr, dpctx);
+
+            // add packet setted different nodeconnector
+            tbl.add(mgr, ncpctx);
+            tent = tbl.get(rpctx);
+            assertNotNull(tent);
+            assertEquals(connectors.get(1), tent.getPort());
+            assertEquals(0, tent.getVlan());
+            try {
+                mae = tbl.getEntry(ea);
+            } catch (VTNException e) {
+                unexpected(e);
+            }
+            iplist = mae.getInetAddresses();
+            assertTrue(iplist.size() == 1);
+            assertArrayEquals(sender, iplist.iterator().next().getAddress());
+
+            // check table size
+            List<MacAddressEntry> list = null;
+            try {
+                list = tbl.getEntries();
+            } catch (Exception e) {
+                unexpected(e);
+            }
+            assertNotNull(list);
+            assertTrue(list.size() == 1);
+            EthernetAddress eth = (EthernetAddress) list.get(0).getAddress();
+            assertArrayEquals(src, eth.getValue());
+
+            // remove entry
+            tbl.remove(rpctx);
+            assertNull(tbl.get(rpctx));
+
+            // check whether removed entry not included.
+            tent = tbl.get(rpctx);
+            assertNull(tent);
+
+            // removeEntry()
+            tbl.add(mgr, dpctx);
+            try {
+                mae = tbl.removeEntry(ea);
+            } catch (Exception e) {
+                unexpected(e);
+            }
+            assertNotNull(mae);
+            assertEquals(ea, mae.getAddress());
+            assertEquals(0, mae.getVlan());
+            assertEquals(connectors.get(0), mae.getNodeConnector());
+
+            try {
+                mae = tbl.removeEntry(ea);
+            } catch (Exception e) {
+                unexpected(e);
+            }
+            assertNull(mae);
+
+            // check whether removed entry not included.
+            tent = tbl.get(rpctx);
+            assertNull(tent);
+
+            tall.add(mgr, dpctx);
+            list = null;
+            try {
+                list = tall.getEntries();
+            } catch (Exception e) {
+                unexpected(e);
+            }
+            assertNotNull(list);
+            assertTrue(list.size() == iphost);
+
+            iphost++;
+        }
+        tbl.destroy(mgr);
+        tall.destroy(mgr);
+
+        // case for Multicast packet data
+        byte [] dst = new byte[] {(byte)0xFF, (byte)0xFF, (byte)0xFF,
+                                    (byte)0xFF, (byte)0xFF, (byte)0xFF};
+        byte [] src = new byte[] {(byte)0xFF, (byte)0x00, (byte)0x00,
+                                    (byte)0x00, (byte)0x00, (byte)0x01};
+        byte [] sender = new byte[] {(byte)192, (byte)168, (byte)100, (byte)1};
+        byte [] target = new byte[] {(byte)192, (byte)168, (byte)100, (byte)2};
+
+        MacAddressTable mtbl = new MacAddressTable(mgr, "Table", 600);
+        PacketContext mpctx = createARPPacketContext(src, dst, sender, target,
+                                           (short)-1, connectors.get(0), ARP.REQUEST);
+        mtbl.add(mgr, mpctx);
+
+        List<MacAddressEntry> list = null;
+        try {
+            list = mtbl.getEntries();
+        } catch (Exception e) {
+            unexpected(e);
+        }
+        assertNotNull(list);
+        assertTrue(list.size() == 0);
+    }
+
+    /**
+     * Test case for
+     * {@link MacAddressTable#flush()},
+     * {@link MacAddressTable#flush(Node)},
+     * {@link MacAddressTable#flush(Node, short)}
+     */
+    @Test
+    public void testFlush() {
+        VTNManagerImpl mgr = vtnMgr;
+
+        MacAddressTable tbl1 = new MacAddressTable(mgr, "Table", 600);
+        MacAddressTable tbl2 = new MacAddressTable(mgr, "Table2", 1000);
+        MacAddressTable tbl3 = new MacAddressTable(mgr, "Table3", 1000);
+        MacAddressTable tbl4 = new MacAddressTable(mgr, "Table4", 1000);
+        MacAddressTable tbl5 = new MacAddressTable(mgr, "Table5", 1000);
+
+        List<NodeConnector> connectors = createNodeConnectors(3, false);
+        short vlan = 0;
+        for (byte iphost = 1; iphost <= 9; iphost++) {
+            byte[] src = new byte[] {(byte)0x00, (byte)0x00, (byte)0x00,
+                                        (byte)0x00, (byte)0x00, (byte)iphost};
+            byte[] dst = new byte[] {(byte)0xff, (byte)0xff, (byte)0xff,
+                                        (byte)0xff, (byte)0xff, (byte)0xff};
+            byte[] sender = new byte[] {(byte)192, (byte)168, (byte)100, (byte)iphost};
+            byte[] target = new byte[] {(byte)192, (byte)168, (byte)100, (byte)250};
+
+            PacketContext pctx = createARPPacketContext(src, dst, sender, target, (short)(vlan / 3),
+                                               connectors.get(iphost % 3), ARP.REQUEST);
+            tbl1.add(mgr, pctx);
+            tbl2.add(mgr, pctx);
+            tbl3.add(mgr, pctx);
+            tbl4.add(mgr, pctx);
+            tbl5.add(mgr, pctx);
+
+            vlan++;
+        }
+
+        List<MacAddressEntry> list = null;
+        tbl1.flush();
+        try {
+            list = tbl1.getEntries();
+        } catch (Exception e) {
+            unexpected(e);
+        }
+        assertNotNull(list);
+        assertTrue(list.size() == 0);
+
+        tbl2.flush(connectors.get(0).getNode());
+        try {
+            list = tbl2.getEntries();
+        } catch (Exception e) {
+            unexpected(e);
+        }
+        assertNotNull(list);
+        assertTrue(list.size() == 6);
+
+        tbl3.flush(connectors.get(0).getNode(), (short)0);
+        try {
+            list = tbl3.getEntries();
+        } catch (Exception e) {
+            unexpected(e);
+        }
+        assertNotNull(list);
+        assertTrue(list.size() == 8);
+
+        tbl4.flush(connectors.get(0));
+        try {
+            list = tbl4.getEntries();
+        } catch (Exception e) {
+            unexpected(e);
+        }
+        assertNotNull(list);
+        assertTrue(list.size() == 6);
+
+        tbl5.flush(connectors.get(0), (short)0);
+        try {
+            list = tbl5.getEntries();
+        } catch (Exception e) {
+            unexpected(e);
+        }
+        assertNotNull(list);
+        assertTrue(list.size() == 8);
+    }
+}
diff --git manager/implementation/src/test/java/org/opendaylight/vtn/manager/internal/MacTableEntryTest.java manager/implementation/src/test/java/org/opendaylight/vtn/manager/internal/MacTableEntryTest.java
new file mode 100644
index 0000000..0f88cf0
--- /dev/null
+++ manager/implementation/src/test/java/org/opendaylight/vtn/manager/internal/MacTableEntryTest.java
@@ -0,0 +1,168 @@
+/**
+ * Copyright (c) 2013 NEC Corporation
+ * All rights reserved.
+ *
+ * This program and the accompanying materials are made available under the
+ * terms of the Eclipse Public License v1.0 which accompanies this
+ * distribution, and is available at http://www.eclipse.org/legal/epl-v10.html
+ */
+package org.opendaylight.vtn.manager.internal;
+
+import java.net.InetAddress;
+
+import java.util.ArrayList;
+import java.util.HashSet;
+import java.util.Iterator;
+import java.util.List;
+import java.util.Set;
+
+import org.junit.Rule;
+import org.junit.Test;
+import org.junit.rules.ExpectedException;
+
+import org.opendaylight.controller.sal.core.NodeConnector;
+import org.opendaylight.controller.sal.packet.address.EthernetAddress;
+import org.opendaylight.controller.sal.utils.NetUtils;
+import org.opendaylight.vtn.manager.MacAddressEntry;
+import org.opendaylight.vtn.manager.VTNException;
+
+
+/**
+ * JUnit test for {@link MacTableEntry}
+ */
+public class MacTableEntryTest extends TestBase {
+
+    @Rule
+    public ExpectedException thrown = ExpectedException.none();
+
+    /**
+     * Test case for getter methods.
+     */
+    @Test
+    public void testGetter() {
+        short vlans[] = {-10, 0, 1, 100, 4095};
+
+        for (NodeConnector nc: createNodeConnectors(3, false)) {
+            for (short vlan: vlans) {
+                for (Set<InetAddress> ips: createInetAddresses(false)) {
+                    MacTableEntry me = null;
+
+                    if (ips.size() == 0) {
+                        me = new MacTableEntry(copy(nc), vlan, null);
+                        assertNotNull(me);
+                    } else {
+                        boolean first = true;
+                        for (InetAddress ip: ips) {
+                            if (first) {
+                                me = new MacTableEntry(copy(nc), vlan, ip);
+                                assertNotNull(me);
+                                assertEquals(nc, me.getPort());
+                                assertEquals(vlan, me.getVlan());
+
+                                first = false;
+                            } else {
+                                assertTrue(me.addInetAddress(ip));
+                            }
+                        }
+                    }
+
+                    for (EthernetAddress ea: createEthernetAddresses(false)) {
+
+                        // test for getEntry()
+                        try {
+                            long eval =  NetUtils.byteArray6ToLong(ea.getValue());
+                            MacAddressEntry mae1 = me.getEntry(eval);
+                            MacAddressEntry mae2 = new MacAddressEntry(copy(ea), vlan, copy(nc), copy(ips));
+                            assertEquals(mae2, mae1);
+                        } catch (VTNException e) {
+                            unexpected(e);
+                        }
+                    }
+
+                    for (short newvlan: vlans) {
+                        me.setVlan(newvlan);
+                        assertEquals(newvlan, me.getVlan());
+                    }
+
+                    for (NodeConnector newnc: createNodeConnectors(3, false)) {
+                        me.setPort(newnc);
+                        assertEquals(newnc, me.getPort());
+                    }
+                }
+            }
+        }
+    }
+
+    /**
+     * Test case for {@link MacTableEntry#setUsed} and {@link MacTableEntry#clearUsed}
+     */
+    @Test
+    public void testUsed() {
+        short vlan = 0;
+        List<NodeConnector> connectors = createNodeConnectors(1, false);
+        NodeConnector nc = connectors.get(0);
+        List<Set<InetAddress>> ips = createInetAddresses(false);
+
+        Iterator<InetAddress> ip = ips.get(0).iterator();
+        MacTableEntry me = new MacTableEntry(nc, vlan, ip.next());
+
+        assertTrue(me.clearUsed());
+        me.setUsed();
+        assertTrue(me.clearUsed());
+        assertFalse(me.clearUsed());
+    }
+
+    /**
+     * Test case for {@link MacTableEntry#toString()}
+     */
+    @Test
+    public void testToString() {
+        String prefix = "MacTableEntry[";
+        String suffix = "]";
+        short vlans[] = {-10, 0, 1, 100, 4095};
+
+        for (NodeConnector nc: createNodeConnectors(3, false)) {
+            for (short vlan: vlans) {
+                for (Set<InetAddress> ips: createInetAddresses(false)) {
+                    StringBuffer i = new StringBuffer("ipaddr={");
+                    MacTableEntry me = null;
+                    ArrayList<String> list = new ArrayList<String>();
+                    HashSet<InetAddress> hash = new HashSet<InetAddress>();
+
+                    for (InetAddress ip: ips) {
+                        hash.add(ip);
+                    }
+
+                    if (ips.size() == 0) {
+                        me = new MacTableEntry(nc, vlan, null);
+                        i.append("}");
+                    } else {
+                        boolean first = true;
+                        for (InetAddress ip: hash) {
+                            if (first) {
+                                if (ip == null) {
+                                    me = new MacTableEntry(nc, vlan, null);
+                                } else {
+                                    me = new MacTableEntry(nc, vlan, ip);
+                                    i.append(ip.getHostAddress());
+                                }
+                                first = false;
+                            } else {
+                                me.addInetAddress(ip);
+                                i.append(",");
+                                i.append(ip.getHostAddress());
+                            }
+                        }
+                        i.append("}");
+                    }
+
+                    String p ="port=" + nc.toString();
+                    String v = "vlan=" + vlan;
+                    String required = joinStrings(prefix, suffix, ",", p, v, i);
+
+                    assertEquals(required, me.toString());
+                }
+            }
+        }
+    }
+}
\ No newline at end of file
diff --git manager/implementation/src/test/java/org/opendaylight/vtn/manager/internal/PacketContextTest.java manager/implementation/src/test/java/org/opendaylight/vtn/manager/internal/PacketContextTest.java
new file mode 100644
index 0000000..769031d
--- /dev/null
+++ manager/implementation/src/test/java/org/opendaylight/vtn/manager/internal/PacketContextTest.java
@@ -0,0 +1,222 @@
+/*
+ * Copyright (c) 2013 NEC Corporation
+ * All rights reserved.
+ *
+ * This program and the accompanying materials are made available under the
+ * terms of the Eclipse Public License v1.0 which accompanies this
+ * distribution, and is available at http://www.eclipse.org/legal/epl-v10.html
+ */
+package org.opendaylight.vtn.manager.internal;
+
+import java.net.InetAddress;
+import java.net.UnknownHostException;
+import java.util.TreeMap;
+
+import org.junit.Test;
+import org.opendaylight.controller.sal.core.NodeConnector;
+import org.opendaylight.controller.sal.packet.ARP;
+import org.opendaylight.controller.sal.packet.Ethernet;
+import org.opendaylight.controller.sal.packet.address.EthernetAddress;
+import org.opendaylight.controller.sal.utils.HexEncode;
+import org.opendaylight.controller.sal.utils.NetUtils;
+import org.opendaylight.vtn.manager.internal.cluster.PortVlan;
+
+public class PacketContextTest extends TestBase {
+    /**
+     * Test case for getter methods.
+     */
+    @Test
+    public void testGetter() {
+        short vlans[] = { -10, 0, 1, 100, 4095 };
+        Ethernet ether;
+        for (NodeConnector nc : createNodeConnectors(3, false)) {
+            byte iphost = 1;
+            for (short vlan : vlans) {
+                for (EthernetAddress ea : createEthernetAddresses(false)) {
+                    byte[] bytes = ea.getValue();
+                    byte[] src = new byte[] { bytes[0], bytes[1], bytes[2], bytes[3], bytes[4], bytes[5] };
+                    byte[] dst = new byte[] { (byte) 0xff, (byte) 0xff, (byte) 0xff, (byte) 0xff, (byte) 0xff,
+                            (byte) 0xff };
+                    byte[] sender = new byte[] { (byte) 192, (byte) 168, (byte) 0, iphost };
+                    byte[] sender2 = new byte[] { (byte) 192, (byte) 168, (byte) 0, (byte) (iphost + 100) };
+                    byte[] target = new byte[] { (byte) 192, (byte) 168, (byte) 0, (byte) 250 };
+
+                    testPacketContext(src, dst, sender, target, vlan, nc);
+
+                    ether = createARPPacket(src, dst, sender2, target, vlan, ARP.REQUEST);
+                    testPacketContext(ether, src, dst, sender2, vlan, nc);
+                }
+            }
+        }
+    }
+
+    /**
+     * test PacketContext(RawPacket raw, Ethernet ether)
+     *
+     * @param src
+     * @param dst
+     * @param sender
+     * @param target
+     * @param vlan
+     * @param nc
+     */
+    private void testPacketContext(byte[] src, byte[] dst, byte[] sender, byte[] target, short vlan, NodeConnector nc) {
+        InetAddress ipaddr = null;
+        MacTableEntry me;
+        PortVlan pv;
+        String desc;
+
+        PacketContext pc = createARPPacketContext(src, dst, sender, target, vlan, nc, ARP.REQUEST);
+
+        if (vlan < 0) {
+            assertEquals(0, pc.getVlan());
+            pv = new PortVlan(nc, (short) 0);
+            me = new MacTableEntry(nc, (short) 0, ipaddr);
+        } else {
+            assertEquals(vlan, pc.getVlan());
+            pv = new PortVlan(nc, vlan);
+            me = new MacTableEntry(nc, vlan, ipaddr);
+        }
+
+        if (pc.getRawPacket() == null) {
+            assertNull(pc.getIncomingNetwork());
+            try {
+                assertNull(pc.getIncomingNodeConnector());
+            } catch (NullPointerException expected) {
+                assertEquals(expected.getMessage(), null);
+            }
+        } else {
+            assertNotNull(pc.getIncomingNodeConnector());
+            assertEquals(pv, pc.getIncomingNetwork());
+        }
+
+        assertNull(pc.getOutgoingNodeConnector());
+        assertEquals(src, pc.getSourceAddress());
+        assertEquals(dst, pc.getDestinationAddress());
+
+        byte[] sip = pc.getSourceIpAddress();
+        assertEquals(sender, sip);
+
+        try {
+            ipaddr = InetAddress.getByAddress(sip);
+        } catch (UnknownHostException e) {
+            // This should never happen.
+            fail(e.getMessage());
+        }
+
+        Long key = NetUtils.byteArray6ToLong(src);
+        pc.addObsoleteEntry(key, me);
+
+        TreeMap<Long, MacTableEntry> map = new TreeMap<Long, MacTableEntry>();
+        map.put(key, me);
+
+        assertEquals(map, pc.getObsoleteEntries());
+
+        Ethernet ether = pc.getFrame();
+
+        if (vlan < 0) {
+            desc = convertForDescription(ether, nc, (short) 0);
+            ether = pc.createFrame((short) 0);
+        } else {
+            desc = convertForDescription(ether, nc, vlan);
+            ether = pc.createFrame(vlan);
+        }
+
+        assertEquals(desc, pc.getDescription(nc));
+        assertNotNull(ether);
+    }
+
+    /**
+     * test PacketContext(RawPacket raw, Ethernet ether)
+     *
+     * @param ether
+     * @param src
+     * @param dst
+     * @param sender
+     * @param vlan
+     * @param nc
+     */
+    private void testPacketContext(Ethernet ether, byte[] src, byte[] dst, byte[] sender, short vlan, NodeConnector nc) {
+        InetAddress ipaddr = null;
+        MacTableEntry me;
+        String desc;
+
+        PacketContext pctx = new PacketContext(ether, nc);
+        assertEquals(ether, pctx.getFrame());
+
+        if (pctx.getRawPacket() == null) {
+            assertNull(pctx.getIncomingNetwork());
+            try {
+                assertNull(pctx.getIncomingNodeConnector());
+            } catch (NullPointerException expected) {
+                assertEquals(expected.getMessage(), null);
+            }
+        } else {
+            assertNotNull(pctx.getIncomingNodeConnector());
+            assertNotNull(pctx.getIncomingNetwork());
+        }
+
+        assertEquals(nc, pctx.getOutgoingNodeConnector());
+
+        assertNotNull(pctx.getPayload());
+        assertEquals(src, pctx.getSourceAddress());
+        assertEquals(dst, pctx.getDestinationAddress());
+
+        assertEquals(sender, pctx.getSourceIpAddress());
+        byte[] sip = pctx.getSourceIpAddress();
+
+        try {
+            ipaddr = InetAddress.getByAddress(sip);
+        } catch (UnknownHostException e) {
+            // This should never happen.
+            fail(e.getMessage());
+        }
+
+        if (vlan < 0) {
+            assertEquals((short) 0, pctx.getVlan());
+            me = new MacTableEntry(nc, (short) 0, ipaddr);
+        } else {
+            assertEquals(vlan, pctx.getVlan());
+            me = new MacTableEntry(nc, vlan, ipaddr);
+        }
+
+        Long key = NetUtils.byteArray6ToLong(src);
+        pctx.addObsoleteEntry(key, me);
+
+        TreeMap<Long, MacTableEntry> map = new TreeMap<Long, MacTableEntry>();
+        map.put(key, me);
+
+        assertEquals(map, pctx.getObsoleteEntries());
+
+        if (vlan < 0) {
+            desc = convertForDescription(ether, nc, (short) 0);
+            ether = pctx.createFrame((short) 0);
+        } else {
+            desc = convertForDescription(ether, nc, vlan);
+            ether = pctx.createFrame(vlan);
+        }
+
+        assertEquals(desc, pctx.getDescription(nc));
+        assertNotNull(ether);
+    }
+
+    /**
+     * Create a string to compare description.
+     *
+     * @param ether
+     * @param port
+     * @param vlan
+     * @return A brief description of the specified ethernet frame.
+     */
+    private String convertForDescription(Ethernet ether, NodeConnector port, short vlan) {
+        String srcmac = HexEncode.bytesToHexStringFormat(ether.getSourceMACAddress());
+        String dstmac = HexEncode.bytesToHexStringFormat(ether.getDestinationMACAddress());
+        int type = ether.getEtherType() & 0xffff;
+
+        StringBuilder builder = new StringBuilder("src=");
+        builder.append(srcmac).append(", dst=").append(dstmac).append(", port=").append(port).append(", type=0x")
+                .append(Integer.toHexString(type)).append(", vlan=").append(vlan);
+
+        return builder.toString();
+    }
+}
diff --git manager/implementation/src/test/java/org/opendaylight/vtn/manager/internal/TestBase.java manager/implementation/src/test/java/org/opendaylight/vtn/manager/internal/TestBase.java
index c499676..4208d72 100644
--- manager/implementation/src/test/java/org/opendaylight/vtn/manager/internal/TestBase.java
+++ manager/implementation/src/test/java/org/opendaylight/vtn/manager/internal/TestBase.java
@@ -13,12 +13,25 @@ import java.io.ByteArrayInputStream;
 import java.io.ByteArrayOutputStream;
 import java.io.ObjectInputStream;
 import java.io.ObjectOutputStream;
+import java.net.InetAddress;
+import java.net.UnknownHostException;
 import java.util.ArrayList;
+import java.util.HashSet;
 import java.util.List;
 import java.util.Set;
 
 import org.opendaylight.controller.sal.core.Node;
 import org.opendaylight.controller.sal.core.NodeConnector;
+import org.opendaylight.controller.sal.packet.ARP;
+import org.opendaylight.controller.sal.packet.Ethernet;
+import org.opendaylight.controller.sal.packet.IEEE8021Q;
+import org.opendaylight.controller.sal.packet.IPv4;
+import org.opendaylight.controller.sal.packet.RawPacket;
+import org.opendaylight.controller.sal.packet.address.EthernetAddress;
+import org.opendaylight.controller.sal.utils.EtherTypes;
+import org.opendaylight.vtn.manager.SwitchPort;
+import org.opendaylight.vtn.manager.VBridgeConfig;
+import org.opendaylight.vtn.manager.VTenantConfig;
 
 import org.junit.Assert;
 
@@ -80,6 +93,88 @@ public abstract class TestBase extends Assert {
     }
 
     /**
+     * Create a copy of the specified {@link EthernetAddress}.
+     *
+     * @param ea    A {@link EthernetAddress} object to be copied.
+     * @return      A copied {@link EthernetAddress} object.
+     */
+    protected static EthernetAddress copy(EthernetAddress ea) {
+        if (ea != null) {
+            try {
+                ea = new EthernetAddress(ea.getValue());
+            } catch (Exception e) {
+                unexpected(e);
+            }
+        }
+        return ea;
+    }
+
+    /**
+     * Create a copy of the specified {@link InetAddress}.
+     *
+     * @param ia    A {@link InetAddress} object to be copied.
+     * @return      A copied {@link InetAddress} object.
+     */
+    protected static InetAddress copy(InetAddress ia) {
+        if (ia != null) {
+            try {
+                ia = InetAddress.getByAddress(ia.getAddress());
+            } catch (Exception e) {
+                unexpected(e);
+            }
+        }
+        return ia;
+    }
+
+    /**
+     * Create a deep copy of the specified {@link InetAddress} set.
+     *
+     * @param ia    A {@link InetAddress} set to be copied.
+     * @return      A copied {@link InetAddress} set.
+     */
+    protected static Set<InetAddress> copy(Set<InetAddress> ia) {
+        if (ia != null) {
+            Set<InetAddress> newset = new HashSet<InetAddress>();
+            try {
+                for (InetAddress iaddr: ia) {
+                    newset.add(InetAddress.getByAddress(iaddr.getAddress()));
+                }
+            } catch (Exception e) {
+                unexpected(e);
+            }
+            ia = newset;
+        }
+        return ia;
+    }
+
+    /**
+     * Create a list of boolean values and a {@code null}.
+     *
+     * @return A list of boolean values.
+     */
+    protected static List<Boolean> createBooleans() {
+        return createBooleans(true);
+    }
+
+    /**
+     * Create a list of boolean values.
+     *
+     * @param setNull  Set {@code null} to returned list if {@code true}.
+     * @return A list of boolean values.
+     */
+    protected static List<Boolean> createBooleans(boolean setNull) {
+        ArrayList<Boolean> list = new ArrayList<Boolean>();
+        if (setNull) {
+            list.add(null);
+        }
+
+        list.add(Boolean.TRUE);
+        list.add(Boolean.FALSE);
+        return list;
+    }
+
+
+    /**
      * Create a list of strings and a {@code null}.
      *
      * @param base A base string.
@@ -146,6 +241,59 @@ public abstract class TestBase extends Assert {
     }
 
     /**
+     * Create a list of {@link Node} and a {@code null}.
+     *
+     * @param num  The number of objects to be created.
+     * @return A list of {@link Node}.
+     */
+    protected static List<Node> createNodes(int num) {
+        return createNodes(num, true);
+    }
+
+    /**
+     * Create a list of {@link Node}.
+     *
+     * @param num      The number of objects to be created.
+     * @param setNull  Set {@code null} to returned list if {@code true}.
+     * @return A list of {@link Node}.
+     */
+    protected static List<Node> createNodes(int num, boolean setNull) {
+        ArrayList<Node> list = new ArrayList<Node>();
+        if (setNull) {
+            list.add(null);
+            num--;
+        }
+
+        String[] types = {
+            Node.NodeIDType.OPENFLOW,
+            Node.NodeIDType.ONEPK,
+            Node.NodeIDType.PRODUCTION,
+        };
+
+        for (int i = 0; i < num; i++) {
+            int tidx = i % types.length;
+            String type = types[tidx];
+            Object id;
+            if (type.equals(Node.NodeIDType.OPENFLOW)) {
+                id = new Long((long)i);
+            } else {
+                id = "Node ID: " + i;
+            }
+
+            try {
+                Node node = new Node(type, id);
+                assertNotNull(node.getType());
+                assertNotNull(node.getNodeIDString());
+                list.add(node);
+            } catch (Exception e) {
+                unexpected(e);
+            }
+        }
+
+        return list;
+    }
+
+    /**
      * Create a list of {@code NodeConnector} and a {@code null}.
      *
      * @param num  The number of objects to be created.
@@ -211,6 +359,361 @@ public abstract class TestBase extends Assert {
     }
 
     /**
+     * Create a list of {@link SwitchPort} and a {@code null}.
+     *
+     * @param num  The number of objects to be created.
+     * @return A list of {@link SwitchPort}.
+     */
+    protected static List<SwitchPort> createSwitchPorts(int num) {
+        return createSwitchPorts(num, true);
+    }
+
+    /**
+     * Create a list of {@link SwitchPort}.
+     *
+     * @param num      The number of objects to be created.
+     * @param setNull  Set {@code null} to returned list if {@code true}.
+     * @return A list of {@link SwitchPort}.
+     */
+    protected static List<SwitchPort>
+        createSwitchPorts(int num, boolean setNull) {
+        ArrayList<SwitchPort> list = new ArrayList<SwitchPort>();
+        if (setNull) {
+            list.add(null);
+            num--;
+            if (num == 0) {
+                return list;
+            }
+        }
+
+        list.add(new SwitchPort(null, null, null));
+        num--;
+        if (num == 0) {
+            return list;
+        }
+
+        list.add(new SwitchPort("name", "type", "id"));
+        num--;
+
+        for (; num > 0; num--) {
+            String name = ((num % 2) == 0) ? null : "name:" + num;
+            String type = ((num % 7) == 0) ? null : "type:" + num;
+            String id = ((num % 9) == 0) ? null : "id:" + num;
+            if (name == null && type == null && id == null) {
+                name = "name:" + num;
+            }
+            list.add(new SwitchPort(name, type, id));
+        }
+
+        return list;
+    }
+
+    /**
+     * Create a {@link VTenantConfig} object.
+     *
+     * @param desc  Description of the virtual tenant.
+     * @param idle  {@code idle_timeout} value for flow entries.
+     * @param hard  {@code hard_timeout} value for flow entries.
+     * @return  A {@link VBridgeConfig} object.
+     */
+    protected static VTenantConfig createVTenantConfig(String desc,
+                                                       Integer idle,
+                                                       Integer hard) {
+        if (idle == null) {
+            if (hard == null) {
+                return new VTenantConfig(desc);
+            } else {
+                return new VTenantConfig(desc, -1, hard.intValue());
+            }
+        } else if (hard == null) {
+            return new VTenantConfig(desc, idle.intValue(), -1);
+        }
+
+        return new VTenantConfig(desc, idle.intValue(), hard.intValue());
+    }
+
+    /**
+     * Create a {@link VBridgeConfig} object.
+     *
+     * @param desc  Description of the virtual bridge.
+     * @param age  {@code age} value for aging interval for MAC address table.
+     * @return  A {@link VBridgeConfig} object.
+     */
+    protected static VBridgeConfig createVBridgeConfig(String desc, Integer age) {
+        if (age == null) {
+            return new VBridgeConfig(desc);
+        } else {
+            return new VBridgeConfig(desc, age);
+        }
+    }
+
+
+    /**
+     * Create a list of {@link EthernetAddress} and a {@code null}.
+     *
+     * @return A list of {@link EthernetAddress}.
+     */
+    protected static List<EthernetAddress> createEthernetAddresses() {
+        return createEthernetAddresses(true);
+    }
+
+    /**
+     * Create a list of {@link EthernetAddress}.
+     *
+     * @param setNull  Set {@code null} to returned list if {@code true}.
+     * @return A list of {@link EthernetAddress}.
+     */
+    protected static List<EthernetAddress> createEthernetAddresses(boolean setNull) {
+        List<EthernetAddress> list = new ArrayList<EthernetAddress>();
+        byte [][] addrbytes = {
+            new byte[] {(byte) 0x00, (byte) 0x00, (byte) 0x00,
+                        (byte) 0x00, (byte) 0x00, (byte) 0x01},
+            new byte[] {(byte) 0x12, (byte) 0x34, (byte) 0x56,
+                        (byte) 0x78, (byte) 0x9a, (byte) 0xbc},
+            new byte[] {(byte) 0xfe, (byte) 0xdc, (byte) 0xba,
+                        (byte) 0x98, (byte) 0x76, (byte) 0x54}
+        };
+
+        if (setNull) {
+            list.add(null);
+        }
+
+        for(byte[] addr: addrbytes) {
+            try {
+                EthernetAddress ea;
+                ea = new EthernetAddress(addr);
+                list.add(ea);
+            } catch (Exception e) {
+                unexpected(e);
+            }
+        }
+
+        return list;
+    }
+
+    /**
+     * Create a list of {@link InetAddress} set and a {@code null}.
+     *
+     * @return A list of {@link InetAddress} set.
+     */
+    protected static List<Set<InetAddress>> createInetAddresses() {
+        return createInetAddresses(true);
+    }
+
+    /**
+     * Create a list of {@link InetAddress} set.
+     *
+     * @param setNull  Set {@code null} to returned list if {@code true}.
+     * @return A list of {@link InetAddress} set.
+     */
+    protected static List<Set<InetAddress>>
+        createInetAddresses(boolean setNull) {
+        List<Set<InetAddress>> list = new ArrayList<Set<InetAddress>>();
+        String[][] arrays = {
+            {"0.0.0.0"},
+            {"255.255.255.255", "10.1.2.3"},
+            {"0.0.0.0", "10.0.0.1", "192.255.255.1",
+             "2001:420:281:1004:e123:e688:d655:a1b0"},
+            {},
+        };
+
+        if (setNull) {
+            list.add(null);
+        }
+
+        for (String[] array: arrays) {
+            Set<InetAddress> iset = new HashSet<InetAddress>();
+            try {
+                for (String addr: array) {
+                    assertTrue(iset.add(InetAddress.getByName(addr)));
+                }
+                list.add(iset);
+            } catch (Exception e) {
+                unexpected(e);
+            }
+        }
+
+        return list;
+    }
+
+    /**
+     * create a PacketContext object.
+     *
+     * @param eth   A Ethernet data.
+     * @param nc    A node connector.
+     * @return PacketContext.
+     */
+    protected PacketContext createPacketContext (Ethernet eth, NodeConnector nc) {
+        PacketContext pctx = null;
+        RawPacket raw = null;
+        try {
+            raw = new RawPacket(eth.serialize());
+        } catch (Exception e) {
+            unexpected(e);
+        }
+
+        raw.setIncomingNodeConnector(copy(nc));
+        pctx = new PacketContext(raw, eth);
+
+        return pctx;
+    }
+
+    /**
+     * create a RawPacket object.
+     *
+     * @param eth   A Ethernet data.
+     * @param nc    A node connector.
+     * @return RawPacket.
+     */
+    protected RawPacket createRawPacket (Ethernet eth, NodeConnector nc) {
+        RawPacket raw = null;
+        try {
+            raw = new RawPacket(eth.serialize());
+        } catch (Exception e) {
+            unexpected(e);
+        }
+        raw.setIncomingNodeConnector(copy(nc));
+
+        return raw;
+    }
+
+    /**
+     * create a Ethernet object of IPv4 Packet.
+     *
+     * @param src   source MAC address
+     * @param dst   destination MAC address
+     * @param sender    sender address
+     * @param target    target address
+     * @param vlan  specify val ID. if vlan < 0, vlan tag is not added.
+     * @param arptype ARP.REQUEST or ARP.REPLY.
+     * @return  Ethernet.
+     */
+    protected Ethernet createIPv4Packet (byte[] src, byte[] dst, byte[] sender, byte [] target, short vlan) {
+
+        IPv4 ip = new IPv4();
+            ip.setVersion((byte) 4)
+                .setIdentification((short) 5)
+                .setDiffServ((byte) 0)
+                .setECN((byte) 0)
+                .setTotalLength((short) 84)
+                .setFlags((byte) 2)
+                .setFragmentOffset((short) 0)
+                .setTtl((byte) 64);
+        try {
+            ip.setDestinationAddress(InetAddress.getByAddress(target));
+            ip.setSourceAddress(InetAddress.getByAddress(sender));
+        } catch (UnknownHostException e) {
+            unexpected(e);
+        }
+
+        Ethernet eth = new Ethernet();
+        eth.setSourceMACAddress(src).setDestinationMACAddress(dst);
+
+        if (vlan >= 0) {
+            eth.setEtherType(EtherTypes.VLANTAGGED.shortValue());
+
+            IEEE8021Q vlantag = new IEEE8021Q();
+            vlantag.setCfi((byte) 0x0).setPcp((byte) 0x0).setVid((short) vlan).
+                setEtherType(EtherTypes.IPv4.shortValue()).setParent(eth);
+            eth.setPayload(vlantag);
+
+            vlantag.setPayload(ip);
+
+        } else {
+            eth.setEtherType(EtherTypes.IPv4.shortValue()).setPayload(ip);
+        }
+        return eth;
+    }
+
+    /**
+     * create a Ethernet object of ARP Packet.
+     *
+     * @param src   source MAC address
+     * @param dst   destination MAC address
+     * @param sender    sender address
+     * @param target    target address
+     * @param vlan  specify val ID. if vlan < 0, vlan tag is not added.
+     * @param arptype ARP.REQUEST or ARP.REPLY. (ARP Reply is not implemented yet )
+     * @return  Ethernet.
+     */
+    protected Ethernet createARPPacket (byte[] src, byte[] dst, byte[] sender, byte [] target, short vlan, short arptype) {
+        ARP arp = new ARP();
+        arp.setHardwareType(ARP.HW_TYPE_ETHERNET).
+            setProtocolType(EtherTypes.IPv4.shortValue()).
+            setHardwareAddressLength((byte)EthernetAddress.SIZE).
+            setProtocolAddressLength((byte)target.length).
+            setOpCode(arptype).
+            setSenderHardwareAddress(src).setSenderProtocolAddress(sender).
+            setTargetHardwareAddress(dst).setTargetProtocolAddress(target);
+
+        Ethernet eth = new Ethernet();
+        eth.setSourceMACAddress(src).setDestinationMACAddress(dst);
+
+        if (vlan >= 0) {
+            eth.setEtherType(EtherTypes.VLANTAGGED.shortValue());
+
+            IEEE8021Q vlantag = new IEEE8021Q();
+            vlantag.setCfi((byte) 0x0).setPcp((byte) 0x0).setVid((short) vlan).
+                setEtherType(EtherTypes.ARP.shortValue()).setParent(eth);
+            eth.setPayload(vlantag);
+
+            vlantag.setPayload(arp);
+
+        } else {
+            eth.setEtherType(EtherTypes.ARP.shortValue()).setPayload(arp);
+        }
+        return eth;
+    }
+
+    /**
+     * create a PacketContext object of ARP Request.
+     *
+     * @param src   source MAC address
+     * @param dst   destination MAC address
+     * @param sender    sender address
+     * @param target    target address
+     * @param vlan  specify val ID. if vlan < 0, vlan tag is not added.
+     * @param nc    A node connector
+     * @param arptype ARP.REQUEST or ARP.REPLY. (ARP Reply is not implemented yet )
+     * @return  PacketContext.
+     */
+    protected PacketContext createARPPacketContext (byte[] src, byte[] dst, byte[] sender, byte [] target, short vlan, NodeConnector nc, short arptype) {
+        return createPacketContext(createARPPacket(src, dst, sender, target, vlan, arptype), nc);
+    }
+
+    /**
+     * create a RawPacket object of ARP Request.
+     *
+     * @param src   source MAC address
+     * @param dst   destination MAC address
+     * @param sender    sender address
+     * @param target    target address
+     * @param vlan  specify val ID. if vlan < 0, vlan tag is not added.
+     * @param nc    A node connector
+     * @param arptype ARP.REQUEST or ARP.REPLY. (ARP Reply is not implemented yet )
+     * @return  PacketContext.
+     */
+    protected RawPacket createARPRawPacket (byte[] src, byte[] dst, byte[] sender, byte [] target, short vlan, NodeConnector nc, short arptype) {
+        return createRawPacket(createARPPacket(src, dst, sender, target, vlan, arptype), nc);
+    }
+
+    /**
+     * create a RawPacket object of IPv4 packet.
+     *
+     * @param src   source MAC address
+     * @param dst   destination MAC address
+     * @param sender    sender address
+     * @param target    target address
+     * @param vlan  specify val ID. if vlan < 0, vlan tag is not added.
+     * @param nc    A node connector
+     * @param arptype ARP.REQUEST or ARP.REPLY. (ARP Reply is not implemented yet )
+     * @return  PacketContext.
+     */
+    protected RawPacket createIPv4RawPacket (byte[] src, byte[] dst, byte[] sender, byte [] target, short vlan, NodeConnector nc) {
+        return createRawPacket(createIPv4Packet(src, dst, sender, target, vlan), nc);
+    }
+
+    /**
      * Join the separated strings with inserting a separator.
      *
      * @param prefix     A string to be prepended to the string.
diff --git manager/implementation/src/test/java/org/opendaylight/vtn/manager/internal/TestStub.java manager/implementation/src/test/java/org/opendaylight/vtn/manager/internal/TestStub.java
new file mode 100644
index 0000000..68969bc
--- /dev/null
+++ manager/implementation/src/test/java/org/opendaylight/vtn/manager/internal/TestStub.java
@@ -0,0 +1,921 @@
+/*
+ * Copyright (c) 2013 NEC Corporation
+ * All rights reserved.
+ *
+ * This program and the accompanying materials are made available under the
+ * terms of the Eclipse Public License v1.0 which accompanies this
+ * distribution, and is available at http://www.eclipse.org/legal/epl-v10.html
+ */
+
+package org.opendaylight.vtn.manager.internal;
+
+import java.net.InetAddress;
+import java.util.ArrayList;
+import java.util.Arrays;
+import java.util.HashMap;
+import java.util.HashSet;
+import java.util.List;
+import java.util.Map;
+import java.util.Properties;
+import java.util.Set;
+import java.util.concurrent.ConcurrentHashMap;
+import java.util.concurrent.ConcurrentMap;
+import java.util.concurrent.Future;
+
+import javax.transaction.HeuristicMixedException;
+import javax.transaction.HeuristicRollbackException;
+import javax.transaction.NotSupportedException;
+import javax.transaction.RollbackException;
+import javax.transaction.SystemException;
+import javax.transaction.Transaction;
+
+import org.opendaylight.controller.clustering.services.CacheConfigException;
+import org.opendaylight.controller.clustering.services.CacheExistException;
+import org.opendaylight.controller.clustering.services.IClusterContainerServices;
+import org.opendaylight.controller.clustering.services.IClusterGlobalServices;
+import org.opendaylight.controller.clustering.services.IClusterServices.cacheMode;
+import org.opendaylight.controller.forwardingrulesmanager.FlowConfig;
+import org.opendaylight.controller.forwardingrulesmanager.FlowEntry;
+import org.opendaylight.controller.forwardingrulesmanager.IForwardingRulesManager;
+import org.opendaylight.controller.forwardingrulesmanager.PortGroupConfig;
+import org.opendaylight.controller.forwardingrulesmanager.PortGroupProvider;
+import org.opendaylight.controller.hosttracker.IfIptoHost;
+import org.opendaylight.controller.hosttracker.hostAware.HostNodeConnector;
+import org.opendaylight.controller.sal.core.ConstructionException;
+import org.opendaylight.controller.sal.core.Edge;
+import org.opendaylight.controller.sal.core.Host;
+import org.opendaylight.controller.sal.core.Name;
+import org.opendaylight.controller.sal.core.Node;
+import org.opendaylight.controller.sal.core.NodeConnector;
+import org.opendaylight.controller.sal.core.Path;
+import org.opendaylight.controller.sal.core.Property;
+import org.opendaylight.controller.sal.core.UpdateType;
+import org.opendaylight.controller.sal.packet.Ethernet;
+import org.opendaylight.controller.sal.packet.IDataPacketService;
+import org.opendaylight.controller.sal.packet.LinkEncap;
+import org.opendaylight.controller.sal.packet.Packet;
+import org.opendaylight.controller.sal.packet.RawPacket;
+import org.opendaylight.controller.sal.routing.IRouting;
+import org.opendaylight.controller.sal.utils.NetUtils;
+import org.opendaylight.controller.sal.utils.NodeConnectorCreator;
+import org.opendaylight.controller.sal.utils.NodeCreator;
+import org.opendaylight.controller.sal.utils.Status;
+import org.opendaylight.controller.switchmanager.ISwitchManager;
+import org.opendaylight.controller.switchmanager.SpanConfig;
+import org.opendaylight.controller.switchmanager.Subnet;
+import org.opendaylight.controller.switchmanager.SubnetConfig;
+import org.opendaylight.controller.switchmanager.Switch;
+import org.opendaylight.controller.switchmanager.SwitchConfig;
+import org.opendaylight.controller.topologymanager.ITopologyManager;
+import org.opendaylight.controller.topologymanager.TopologyUserLinkConfig;
+import org.opendaylight.vtn.manager.SwitchPort;
+
+class TestStub implements IClusterGlobalServices, IClusterContainerServices,
+    ISwitchManager, ITopologyManager, IDataPacketService, IRouting, IForwardingRulesManager,
+    IfIptoHost {
+
+    /*
+     * stub mode
+     *   0 : no nodes
+     *   1 : 2 nodes and each node have 5 nodeconnectors.
+     *   2 :
+     */
+    private int stubmode = 0;
+
+    private Set<Node> nodes = null;
+    private ConcurrentMap<Node, Set<NodeConnector>> nodeConnectors = null;
+    private ConcurrentMap<Node, Map<String, NodeConnector>> nodeConnectorNames = null;
+    private Set<SwitchPort> ports = null;
+    private ConcurrentMap<Node, Map<Node, List<Edge>>> nodeEdges = null;
+    private ConcurrentMap<NodeConnector, Map<String, Property>> nodeConnectorProps = null;
+
+    private List<RawPacket> transmittedData = null;
+
+    private SubnetConfig savedSubnetConfig = null;
+
+
+    /**
+     * Constractor of TestStub
+     */
+    public TestStub() {
+        stubmode = 0;
+    }
+
+    /**
+     * Constractor of TestStub
+     * @param mode  stubmode
+     */
+    public TestStub(int mode) {
+        stubmode = mode;
+        setup();
+    }
+
+    private void setup() {
+        transmittedData = new ArrayList<RawPacket>();
+        if (stubmode == 1) {
+            // create nodes
+            nodes = new HashSet<Node>();
+            Node node = NodeCreator.createOFNode(Long.valueOf(0));
+            nodes.add(node);
+            node = NodeCreator.createOFNode(Long.valueOf(1));
+            nodes.add(node);
+
+            // create nodeconnectors
+            nodeConnectors = new ConcurrentHashMap<Node, Set<NodeConnector>>();
+            nodeConnectorNames = new ConcurrentHashMap<Node, Map<String, NodeConnector>>();
+            nodeConnectorProps = new ConcurrentHashMap<NodeConnector, Map<String, Property>>();
+            for (Node addnode : nodes) {
+                Map<String, NodeConnector> map = new HashMap<String, NodeConnector>();
+                Set<NodeConnector> ncs = new HashSet<NodeConnector>();
+                for (short i = 10; i < 15; i++) {
+                    NodeConnector nc =
+                        NodeConnectorCreator.createOFNodeConnector(Short.valueOf(i), addnode);
+                    ncs.add(nc);
+                    String mapname = "port-" + i;
+                    map.put(mapname, nc);
+
+                    Map<String, Property> propmap = nodeConnectorProps.get(nc);
+                    if (propmap == null) {
+                        propmap = new HashMap<String, Property>();
+                    }
+                    Name prop = new Name(mapname);
+                    propmap.put("name", prop);
+
+                    nodeConnectorProps.put(nc, propmap);
+                }
+                nodeConnectors.put(addnode, ncs);
+                nodeConnectorNames.put(addnode, map);
+            }
+
+            // create edges
+            nodeEdges = new ConcurrentHashMap<Node, Map<Node, List<Edge>>>();
+            for (Node srcnode: nodes) {
+                for (Node dstnode: nodes) {
+                    if(srcnode.equals(dstnode)) {
+                        continue;
+                    }
+
+                    Map<Node, List<Edge>> map = nodeEdges.get(srcnode);
+                    List<Edge> edglist = null;
+                    if (map == null) {
+                        map = new HashMap<Node, List<Edge>>();
+                    } else {
+                        edglist = map.get(dstnode);
+                    }
+                    if (edglist == null) {
+                        edglist = new ArrayList<Edge>();
+                    }
+
+                    NodeConnector tail = nodeConnectorNames.get(dstnode).get("port-15");
+                    NodeConnector head = nodeConnectorNames.get(srcnode).get("port-15");
+                    Edge edge = null;
+                    try {
+                        edge = new Edge(tail, head);
+                    } catch (ConstructionException e) {
+                        edge = null;
+                    }
+                    edglist.add(edge);
+                    map.put(dstnode, edglist);
+                    nodeEdges.put(srcnode, map);
+                }
+            }
+        }
+    }
+
+    // IClusterGlobalServices, IClusterContainerServices
+    private ConcurrentMap<String, ConcurrentMap<?, ?>> caches = new ConcurrentHashMap<String, ConcurrentMap<?, ?>>();
+
+    @Override
+    public ConcurrentMap<?, ?> createCache(String cacheName, Set<cacheMode> cMode) throws CacheExistException,
+            CacheConfigException {
+
+        ConcurrentMap<?, ?> res = this.caches.get(cacheName);
+        if (res == null) {
+            res = new ConcurrentHashMap<Object, Object>();
+            this.caches.put(cacheName, res);
+            return res;
+        }
+        throw new CacheExistException();
+    }
+
+    @Override
+    public ConcurrentMap<?, ?> getCache(String cacheName) {
+        return this.caches.get(cacheName);
+    }
+
+    @Override
+    public void destroyCache(String cacheName) {
+        this.caches.remove(cacheName);
+    }
+
+    @Override
+    public boolean existCache(String cacheName) {
+        return (this.caches.get(cacheName) != null);
+    }
+
+    @Override
+    public Set<String> getCacheList() {
+        return this.caches.keySet();
+    }
+
+    @Override
+    public Properties getCacheProperties(String cacheName) {
+        return null;
+    }
+
+    @Override
+    public void tbegin() throws NotSupportedException, SystemException {
+
+    }
+
+    @Override
+    public void tcommit() throws RollbackException, HeuristicMixedException, HeuristicRollbackException,
+            SecurityException, IllegalStateException, SystemException {
+
+    }
+
+    @Override
+    public void trollback() throws IllegalStateException, SecurityException, SystemException {
+
+    }
+
+    @Override
+    public Transaction tgetTransaction() throws SystemException {
+        return null;
+    }
+
+    @Override
+    public InetAddress getCoordinatorAddress() {
+        return null;
+    }
+
+    @Override
+    public List<InetAddress> getClusteredControllers() {
+        return null;
+    }
+
+    @Override
+    public InetAddress getMyAddress() {
+        return null;
+    }
+
+    @Override
+    public boolean amICoordinator() {
+        return false;
+    }
+
+    // ISwitchManager
+    @Override
+    public Status addSubnet(SubnetConfig configObject) {
+        savedSubnetConfig = configObject;
+        return null;
+    }
+
+    @Override
+    public Status removeSubnet(SubnetConfig configObject) {
+        return null;
+    }
+
+    @Override
+    public Status removeSubnet(String name) {
+        return null;
+    }
+
+    @Override
+    public List<Switch> getNetworkDevices() {
+       return null;
+    }
+
+    @Override
+    public List<SubnetConfig> getSubnetsConfigList() {
+        return null;
+    }
+
+    @Override
+    public SubnetConfig getSubnetConfig(String subnet) {
+        return null;
+    }
+
+    @Override
+    public Subnet getSubnetByNetworkAddress(InetAddress networkAddress) {
+
+        if (stubmode == 1) {
+            Subnet sub = new Subnet(savedSubnetConfig);
+            return sub;
+        }
+
+        return null;
+    }
+
+    @Override
+    public Status saveSwitchConfig() {
+        return null;
+    }
+
+    @Override
+    public Status addSpanConfig(SpanConfig configObject) {
+        return null;
+    }
+
+    @Override
+    public Status removeSpanConfig(SpanConfig cfgObject) {
+        return null;
+    }
+
+    @Override
+    public List<SpanConfig> getSpanConfigList() {
+        return null;
+    }
+
+    @Override
+    public List<NodeConnector> getSpanPorts(Node node) {
+        return null;
+    }
+
+    @Override
+    public void updateSwitchConfig(SwitchConfig cfgObject) {
+
+    }
+
+    @Override
+    public SwitchConfig getSwitchConfig(String nodeId) {
+        return null;
+    }
+
+    @Override
+    public Status addPortsToSubnet(String name, String nodeConnectors) {
+        return null;
+    }
+
+    @Override
+    public Status removePortsFromSubnet(String name, String nodeConnectors) {
+        return null;
+    }
+
+    @Override
+    public Set<Node> getNodes() {
+        if (stubmode == 1) {
+            return nodes;
+        }
+
+        return null;
+    }
+
+    @Override
+    public Map<String, Property> getNodeProps(Node node) {
+        return null;
+    }
+
+    @Override
+    public Property getNodeProp(Node node, String propName) {
+        return null;
+    }
+
+    @Override
+    public void setNodeProp(Node node, Property prop) {
+
+    }
+
+    @Override
+    public Status removeNodeProp(Node node, String propName) {
+        return null;
+    }
+
+    @Override
+    public Status removeNodeAllProps(Node node) {
+        return null;
+    }
+
+    @Override
+    public Set<NodeConnector> getUpNodeConnectors(Node node) {
+        if (stubmode == 1) {
+            return nodeConnectors.get(node);
+        }
+        return null;
+    }
+
+    @Override
+    public Set<NodeConnector> getNodeConnectors(Node node) {
+        if (stubmode == 1) {
+            return nodeConnectors.get(node);
+        }
+        return null;
+    }
+
+    @Override
+    public Set<NodeConnector> getPhysicalNodeConnectors(Node node) {
+        if (stubmode == 1) {
+            return nodeConnectors.get(node);
+        }
+
+        return null;
+    }
+
+    @Override
+    public Map<String, Property> getNodeConnectorProps(NodeConnector nodeConnector) {
+        return null;
+    }
+
+    @Override
+    public Property getNodeConnectorProp(NodeConnector nodeConnector, String propName) {
+        if (stubmode == 1) {
+            Map<String, Property> map = nodeConnectorProps.get(nodeConnector);
+            Property name = map.get(propName);
+            return name;
+        }
+        return null;
+    }
+
+    @Override
+    public Status addNodeConnectorProp(NodeConnector nodeConnector, Property prop) {
+        return null;
+    }
+
+    @Override
+    public Status removeNodeConnectorProp(NodeConnector nc, String propName) {
+        return null;
+    }
+
+    @Override
+    public Status removeNodeConnectorAllProps(NodeConnector nodeConnector) {
+        return null;
+    }
+
+    @Override
+    public NodeConnector getNodeConnector(Node node, String nodeConnectorName) {
+        if (stubmode == 1) {
+            Map<String, NodeConnector> map = nodeConnectorNames.get(node);
+            return map.get(nodeConnectorName);
+        }
+        return null;
+    }
+
+    @Override
+    public boolean isSpecial(NodeConnector p) {
+        if (stubmode == 1) {
+            return false;
+        }
+        return false;
+    }
+
+    @Override
+    public Boolean isNodeConnectorEnabled(NodeConnector nodeConnector) {
+        if (stubmode == 1) {
+            return true;
+        }
+        return null;
+    }
+
+    @Override
+    public byte[] getControllerMAC() {
+        return new byte[] {(byte)0x00, (byte)0x00, (byte)0x00,
+                            (byte)0xCC, (byte)0xCC, (byte)0xCC};
+    }
+
+    @Override
+    public byte[] getNodeMAC(Node node) {
+        return null;
+    }
+
+    @Override
+    public boolean isHostRefreshEnabled() {
+        return false;
+    }
+
+    @Override
+    public int getHostRetryCount() {
+        return 0;
+    }
+
+    @Override
+    public Property createProperty(String propName, String propValue) {
+        return null;
+    }
+
+    @Override
+    public String getNodeDescription(Node node) {
+        return null;
+    }
+
+    @Override
+    public Status updateNodeConfig(SwitchConfig switchConfig) {
+        return null;
+    }
+
+    @Override
+    public Status removeNodeConfig(String nodeId) {
+        return null;
+    }
+
+
+    // ITopologyManager
+    @Override
+    public boolean isInternal(NodeConnector p) {
+        if (stubmode == 1) {
+            return false;
+        }
+        return false;
+    }
+
+    @Override
+    public Map<Edge, Set<Property>> getEdges() {
+        return null;
+    }
+
+    @Override
+    public Map<Node, Set<Edge>> getNodeEdges() {
+        return null;
+    }
+
+    @Override
+    public void updateHostLink(NodeConnector p, Host h, UpdateType t, Set<Property> props) {
+
+    }
+
+    @Override
+    public Set<NodeConnector> getNodeConnectorWithHost() {
+        return null;
+    }
+
+    @Override
+    public Host getHostAttachedToNodeConnector(NodeConnector p) {
+        return null;
+    }
+
+    @Override
+    public Map<Node, Set<NodeConnector>> getNodesWithNodeConnectorHost() {
+        return null;
+    }
+
+    @Override
+    public Status addUserLink(TopologyUserLinkConfig link) {
+        return null;
+    }
+
+    @Override
+    public Status deleteUserLink(String linkName) {
+        return null;
+    }
+
+    @Override
+    public Status saveConfig() {
+        return null;
+    }
+
+    @Override
+    public ConcurrentMap<String, TopologyUserLinkConfig> getUserLinks() {
+        return null;
+    }
+
+    @Override
+    public List<Host> getHostsAttachedToNodeConnector(NodeConnector p) {
+        return null;
+    }
+
+    // IDataPacketService
+    @Override
+    public void transmitDataPacket(RawPacket outPkt) {
+        transmittedData.add(outPkt);
+    }
+
+    @Override
+    public Packet decodeDataPacket(RawPacket pkt) {
+        if (pkt == null) {
+            return null;
+        }
+        byte[] data = pkt.getPacketData();
+        if (data.length <= 0) {
+            return null;
+        }
+        if (pkt.getEncap().equals(LinkEncap.ETHERNET)) {
+            Ethernet res = new Ethernet();
+            try {
+                res.deserialize(data, 0, data.length * NetUtils.NumBitsInAByte);
+            } catch (Exception e) {
+                System.out.println("deserialize failed.");
+                return null;
+            }
+            return res;
+        }
+        return null;
+    }
+
+    @Override
+    public RawPacket encodeDataPacket(Packet pkt) {
+        if (pkt == null) {
+            return null;
+        }
+        byte[] data;
+        try {
+            data = pkt.serialize();
+        } catch (Exception e) {
+            return null;
+        }
+        if (data.length <= 0) {
+            return null;
+        }
+        try {
+            RawPacket res = new RawPacket(data);
+            return res;
+        } catch (ConstructionException cex) {
+        }
+
+        return null;
+    }
+
+    // IRouting
+
+    @Override
+    public Path getRoute(Node src, Node dst) {
+        if (stubmode == 1) {
+            List<Edge> edges = nodeEdges.get(src).get(dst);
+            Path result = null;
+            try {
+                result = new Path(edges);
+            } catch (ConstructionException e) {
+                result = null;
+            }
+            return result;
+        }
+
+        return null;
+    }
+
+    @Override
+    public Path getMaxThroughputRoute(Node src, Node dst) {
+        return null;
+    }
+
+    @Override
+    public Path getRoute(Node src, Node dst, Short Bw) {
+        return null;
+    }
+
+    @Override
+    public void clear() {
+
+    }
+
+    @Override
+    public void clearMaxThroughput() {
+
+    }
+
+    @Override
+    public void initMaxThroughput(Map<Edge, Number> EdgeWeightMap) {
+
+    }
+
+
+    // IForwardingRulesManager
+
+    @Override
+    public Status installFlowEntry(FlowEntry flow) {
+        return null;
+    }
+
+    @Override
+    public Status uninstallFlowEntry(FlowEntry flow) {
+        return null;
+    }
+
+    @Override
+    public Status uninstallFlowEntryGroup(String groupName) {
+        return null;
+    }
+
+    @Override
+    public Status modifyFlowEntry(FlowEntry current, FlowEntry newone) {
+        return null;
+    }
+
+    @Override
+    public Status modifyOrAddFlowEntry(FlowEntry newone) {
+        return null;
+    }
+
+    @Override
+    public Status installFlowEntryAsync(FlowEntry flow) {
+        return null;
+    }
+
+    @Override
+    public Status uninstallFlowEntryAsync(FlowEntry flow) {
+        return null;
+    }
+
+    @Override
+    public Status uninstallFlowEntryGroupAsync(String groupName) {
+        return null;
+    }
+
+    @Override
+    public Status modifyFlowEntryAsync(FlowEntry current, FlowEntry newone) {
+        return null;
+    }
+
+    @Override
+    public Status modifyOrAddFlowEntryAsync(FlowEntry newone) {
+        return null;
+    }
+
+    @Override
+    public Status solicitStatusResponse(Node node, boolean blocking) {
+        return null;
+    }
+
+    @Override
+    public boolean checkFlowEntryConflict(FlowEntry flow) {
+        return false;
+    }
+
+    @Override
+    public List<FlowEntry> getFlowEntriesForGroup(String group) {
+        return null;
+    }
+
+    @Override
+    public void addOutputPort(Node node, String flowName, List<NodeConnector> dstPort) {
+
+    }
+
+    @Override
+    public void removeOutputPort(Node node, String flowName, List<NodeConnector> dstPort) {
+
+    }
+
+    @Override
+    public void replaceOutputPort(Node node, String flowName, NodeConnector outPort) {
+
+    }
+
+    @Override
+    public NodeConnector getOutputPort(Node node, String flowName) {
+        return null;
+    }
+
+    @Override
+    public Map<String, Object> getTSPolicyData() {
+        return null;
+    }
+
+    @Override
+    public void setTSPolicyData(String policyName, Object o, boolean add) {
+
+    }
+
+    @Override
+    public Object getTSPolicyData(String policyName) {
+        return null;
+    }
+
+    @Override
+    public List<FlowConfig> getStaticFlows() {
+        return null;
+    }
+
+    @Override
+    public List<FlowConfig> getStaticFlows(Node node) {
+        return null;
+    }
+
+    @Override
+    public FlowConfig getStaticFlow(String name, Node n) {
+        return null;
+    }
+
+    @Override
+    public List<String> getStaticFlowNamesForNode(Node node) {
+        return null;
+    }
+
+    @Override
+    public List<Node> getListNodeWithConfiguredFlows() {
+        return null;
+    }
+
+    @Override
+    public Status addStaticFlow(FlowConfig config) {
+        return null;
+    }
+
+    @Override
+    public Status removeStaticFlow(FlowConfig config) {
+        return null;
+    }
+
+    @Override
+    public Status modifyStaticFlow(FlowConfig config) {
+        return null;
+    }
+
+    @Override
+    public Status removeStaticFlow(String name, Node node) {
+        return null;
+    }
+
+    @Override
+    public Status toggleStaticFlowStatus(FlowConfig configObject) {
+        return null;
+    }
+
+    @Override
+    public Status toggleStaticFlowStatus(String name, Node node) {
+        return null;
+    }
+
+    @Override
+    public Map<String, PortGroupConfig> getPortGroupConfigs() {
+        return null;
+    }
+
+    @Override
+    public boolean addPortGroupConfig(String name, String regex, boolean load) {
+        return false;
+    }
+
+    @Override
+    public boolean delPortGroupConfig(String name) {
+        return false;
+    }
+
+    @Override
+    public PortGroupProvider getPortGroupProvider() {
+        return null;
+    }
+
+    // IfIptoHost
+
+    @Override
+    public HostNodeConnector hostFind(InetAddress networkAddress) {
+        return null;
+    }
+
+    @Override
+    public HostNodeConnector hostQuery(InetAddress networkAddress) {
+        if (stubmode == 1) {
+            HostNodeConnector hnode = null;
+            byte [] tgt = networkAddress.getAddress();
+            byte [] ip = new byte[] {(byte)192, (byte)168, (byte)0, (byte)251};
+            if (Arrays.equals(tgt, ip)) {
+
+                byte [] mac = new byte [] { 0x00, 0x00, 0x00, 0x11, 0x22, 0x33};
+                Node node = NodeCreator.createOFNode(Long.valueOf(0));
+                NodeConnector nc = NodeConnectorCreator.createOFNodeConnector(Short.valueOf("10"), node);
+                try {
+                    hnode = new HostNodeConnector(mac, networkAddress, nc, (short)0);
+                } catch (ConstructionException e) {
+                    return null;
+                }
+
+            }
+            return  hnode;
+        }
+        return null;
+    }
+
+    @Override
+    public Future<HostNodeConnector> discoverHost(InetAddress networkAddress) {
+        return null;
+    }
+
+    @Override
+    public List<List<String>> getHostNetworkHierarchy(InetAddress hostAddress) {
+        return null;
+    }
+
+    @Override
+    public Set<HostNodeConnector> getAllHosts() {
+        return null;
+    }
+
+    @Override
+    public Set<HostNodeConnector> getActiveStaticHosts() {
+        return null;
+    }
+
+    @Override
+    public Set<HostNodeConnector> getInactiveStaticHosts() {
+        return null;
+    }
+
+    @Override
+    public Status addStaticHost(String networkAddress, String dataLayerAddress, NodeConnector nc, String vlan) {
+        return null;
+    }
+
+    @Override
+    public Status removeStaticHost(String networkAddress) {
+        return null;
+    }
+
+    // additional method
+    public List<RawPacket> getTransmittedDataPacket() {
+        List<RawPacket> ret = new ArrayList<RawPacket>();
+        ret.addAll(transmittedData);
+        transmittedData.clear();
+        return ret;
+    }
+
+
+}
diff --git manager/implementation/src/test/java/org/opendaylight/vtn/manager/internal/VTNManagerImplTest.java manager/implementation/src/test/java/org/opendaylight/vtn/manager/internal/VTNManagerImplTest.java
new file mode 100644
index 0000000..a079530
--- /dev/null
+++ manager/implementation/src/test/java/org/opendaylight/vtn/manager/internal/VTNManagerImplTest.java
@@ -0,0 +1,2924 @@
+/*
+ * Copyright (c) 2013 NEC Corporation
+ * All rights reserved.
+ *
+ * This program and the accompanying materials are made available under the
+ * terms of the Eclipse Public License v1.0 which accompanies this
+ * distribution, and is available at http://www.eclipse.org/legal/epl-v10.html
+ */
+package org.opendaylight.vtn.manager.internal;
+
+import static org.junit.Assert.*;
+
+import java.io.ByteArrayInputStream;
+import java.io.ByteArrayOutputStream;
+import java.io.File;
+import java.io.IOException;
+import java.io.ObjectInputStream;
+import java.io.ObjectOutputStream;
+import java.net.InetAddress;
+import java.util.ArrayList;
+import java.util.List;
+import java.util.Set;
+
+import org.junit.BeforeClass;
+import org.junit.Test;
+
+import org.opendaylight.controller.clustering.services.IClusterContainerServices;
+import org.opendaylight.controller.forwardingrulesmanager.IForwardingRulesManager;
+import org.opendaylight.controller.hosttracker.IfHostListener;
+import org.opendaylight.controller.hosttracker.IfIptoHost;
+import org.opendaylight.controller.hosttracker.hostAware.HostNodeConnector;
+import org.opendaylight.controller.sal.core.ConstructionException;
+import org.opendaylight.controller.sal.core.Node;
+import org.opendaylight.controller.sal.core.NodeConnector;
+import org.opendaylight.controller.sal.core.UpdateType;
+import org.opendaylight.controller.sal.packet.ARP;
+import org.opendaylight.controller.sal.packet.IDataPacketService;
+import org.opendaylight.controller.sal.packet.PacketResult;
+import org.opendaylight.controller.sal.packet.RawPacket;
+import org.opendaylight.controller.sal.packet.address.EthernetAddress;
+import org.opendaylight.controller.sal.routing.IRouting;
+import org.opendaylight.controller.sal.utils.GlobalConstants;
+import org.opendaylight.controller.sal.utils.NodeCreator;
+import org.opendaylight.controller.sal.utils.Status;
+import org.opendaylight.controller.sal.utils.StatusCode;
+import org.opendaylight.controller.switchmanager.ISwitchManager;
+import org.opendaylight.controller.topologymanager.ITopologyManager;
+import org.opendaylight.vtn.manager.IVTNManagerAware;
+import org.opendaylight.vtn.manager.IVTNModeListener;
+import org.opendaylight.vtn.manager.MacAddressEntry;
+import org.opendaylight.vtn.manager.PortMap;
+import org.opendaylight.vtn.manager.PortMapConfig;
+import org.opendaylight.vtn.manager.SwitchPort;
+import org.opendaylight.vtn.manager.VBridge;
+import org.opendaylight.vtn.manager.VBridgeConfig;
+import org.opendaylight.vtn.manager.VBridgeIfPath;
+import org.opendaylight.vtn.manager.VBridgePath;
+import org.opendaylight.vtn.manager.VInterface;
+import org.opendaylight.vtn.manager.VInterfaceConfig;
+import org.opendaylight.vtn.manager.VNodeState;
+import org.opendaylight.vtn.manager.VTNException;
+import org.opendaylight.vtn.manager.VTenant;
+import org.opendaylight.vtn.manager.VTenantConfig;
+import org.opendaylight.vtn.manager.VTenantPath;
+import org.opendaylight.vtn.manager.VlanMap;
+import org.opendaylight.vtn.manager.VlanMapConfig;
+
+/**
+ * JUnit test for {@link VTNManagerImplTest}.
+ * This test includes tests for other modules
+ * under {@code org/opendaylight/vtn/manager/internal} directory.
+ */
+public class VTNManagerImplTest extends VTNManagerImplTestCommon {
+
+    @BeforeClass
+    public static void beforeClass() {
+        stubMode = 0;
+    }
+
+    /**
+     * Test method for
+     * {@link VTNManagerImpl#getContainerName()}
+     */
+    @Test
+    public void testGetContainerName() {
+        assertEquals("default", vtnMgr.getContainerName());
+    }
+
+    /**
+     * Test method for
+     * {@link VTNManagerImpl#setClusterContainerService(IClusterContainerServices)},
+     * {@link VTNManagerImpl#unsetClusterContainerService(IClusterContainerServices)}
+     * .
+     */
+    @Test
+    public void testSetUnsetClusterContainerService() {
+        VTNManagerImpl mgr = vtnMgr;
+        TestStub stubnew = new TestStub();
+
+        mgr.setClusterContainerService(stubnew);
+        mgr.unsetClusterContainerService(stubnew);
+
+        mgr.setClusterContainerService(stubObj);
+    }
+
+    /**
+     * Test method for
+     * {@link VTNManagerImpl#setSwitchManager(ISwitchManager)},
+     * {@link VTNManagerImpl#unsetSwitchManager(ISwitchManager)},
+     * {@link VTNManagerImpl#getSwitchManager()}
+     * .
+     */
+    @Test
+    public void testSetUnsetSwitchManager() {
+        VTNManagerImpl mgr = vtnMgr;
+        ISwitchManager org = mgr.getSwitchManager();
+        TestStub stub = new TestStub();
+
+        mgr.setSwitchManager((ISwitchManager)stub);
+        assertSame(stub, mgr.getSwitchManager());
+
+        mgr.unsetSwitchManager((ISwitchManager)stub);
+        assertNull(mgr.getSwitchManager());
+
+        mgr.setSwitchManager((ISwitchManager)org);
+        assertSame(org, mgr.getSwitchManager());
+    }
+
+    /**
+     * Test method for
+     * {@link VTNManagerImpl#setTopologyManager(ITopologyManager)},
+     * {@link VTNManagerImpl#unsetTopologyManager(ITopologyManager)},
+     * {@link VTNManagerImpl#getTopologyManager()}.
+     */
+    @Test
+    public void testSetUnsetTopologyManager() {
+        VTNManagerImpl mgr = vtnMgr;
+        ITopologyManager org = mgr.getTopologyManager();
+        TestStub stub = new TestStub();
+
+        mgr.setTopologyManager((ITopologyManager)stub);
+        assertSame(stub, mgr.getTopologyManager());
+
+        mgr.unsetTopologyManager((ITopologyManager)stub);
+        assertNull(mgr.getTopologyManager());
+
+        mgr.setTopologyManager((ITopologyManager)org);
+        assertSame(org, mgr.getTopologyManager());
+    }
+
+    /**
+     * Test method for
+     * {@link VTNManagerImpl#setForwardingRuleManager(IForwardingRulesManager)},
+     * {@link VTNManagerImpl#unsetForwardingRuleManager(IForwardingRulesManager)},
+     * {@link VTNManagerImpl#getForwardingRuleManager()}
+     */
+    @Test
+    public void testSetUnsetForwardingRuleManager() {
+        VTNManagerImpl mgr = vtnMgr;
+        IForwardingRulesManager org = mgr.getForwardingRuleManager();
+        TestStub stub = new TestStub();
+
+        mgr.setForwardingRuleManager((IForwardingRulesManager)stub);
+        assertSame(stub, mgr.getForwardingRuleManager());
+
+        mgr.unsetForwardingRuleManager((IForwardingRulesManager)stub);
+        assertNull(mgr.getForwardingRuleManager());
+
+        mgr.setForwardingRuleManager((IForwardingRulesManager)org);
+        assertSame(org, mgr.getForwardingRuleManager());
+    }
+
+    /**
+     * Test method for
+     * {@link VTNManagerImpl#setRouting(IRouting)},
+     * {@link VTNManagerImpl#unsetRouting(IRouting)},
+     * {@link VTNManagerImpl#getRouting()}
+     */
+    @Test
+    public void testSetUnsetRouting() {
+        VTNManagerImpl mgr = vtnMgr;
+        IRouting org = mgr.getRouting();
+        TestStub stub = new TestStub();
+
+        mgr.setRouting((IRouting)stub);
+        assertSame(stub, mgr.getRouting());
+
+        mgr.unsetRouting((IRouting)stub);
+        assertNull(mgr.getRouting());
+
+        mgr.setRouting((IRouting)org);
+        assertSame(org, mgr.getRouting());
+    }
+
+    /**
+     * Test method for
+     * {@link VTNManagerImpl#setDataPacketService(IDataPacketService)},
+     * {@link VTNManagerImpl#unsetDataPacketService(IDataPacketService)},
+     * {@link VTNManagerImpl#getDataPacketService()}
+     * .
+     */
+    @Test
+    public void testSetUnsetDataPacketService() {
+        VTNManagerImpl mgr = vtnMgr;
+        IDataPacketService org = mgr.getDataPacketService();
+        TestStub stub = new TestStub();
+
+        mgr.setDataPacketService((IDataPacketService)stub);
+        assertSame(stub, mgr.getDataPacketService());
+
+        mgr.unsetDataPacketService((IDataPacketService)stub);
+        assertNull(mgr.getDataPacketService());
+
+        mgr.setDataPacketService((IDataPacketService)org);
+        assertSame(org, mgr.getDataPacketService());
+    }
+
+    /**
+     * Test method for
+     * {@link VTNManagerImpl#setHostTracker(IfIptoHost)},
+     * {@link VTNManagerImpl#unsetHostTracker(IfIptoHost)},
+     * {@link VTNManagerImpl#getHostTracker()}
+     */
+    @Test
+    public void testSetUnsetHostTracker() {
+        VTNManagerImpl mgr = vtnMgr;
+        IfIptoHost org = mgr.getHostTracker();
+        TestStub stub = new TestStub();
+
+        mgr.setHostTracker(stub);
+        assertSame(stub, mgr.getHostTracker());
+
+        mgr.unsetHostTracker(stub);
+        assertNull(mgr.getHostTracker());
+
+        mgr.setHostTracker(org);
+        assertSame(org, mgr.getHostTracker());
+    }
+
+    /**
+     * Test method for
+     * {@link VTNManagerImpl#addHostListener(IfHostListener)},
+     * {@link VTNManagerImpl#removeHostListener(IfHostListener)},
+     * {@link VTNManagerImpl#notifyHost(HostNodeConnector)}
+     */
+    @Test
+    public void testIfHostListener() {
+       VTNManagerImpl mgr = vtnMgr;
+
+       // stub for test
+       class HostListener implements IfHostListener {
+           private int hostListenerCalled = 0;
+
+           @Override
+           public void hostListener(HostNodeConnector host) {
+               hostListenerCalled++;
+           }
+
+           int getHostListenerCalled () {
+               int ret = hostListenerCalled;
+               hostListenerCalled = 0;
+               return  ret;
+           }
+       }
+
+       HostListener hl1 = new HostListener();
+       HostListener hl2 = new HostListener();
+       mgr.addHostListener(hl1);
+       mgr.addHostListener(hl2);
+
+       // add entry to MacAddressTable to call HostListener
+       byte [] src = new byte[] {(byte)0, (byte)0, (byte)0, (byte)0, (byte)0, (byte)0x01};
+       byte [] dst = new byte[] {(byte)0xff, (byte)0xff, (byte)0xff,
+                                   (byte)0xff, (byte)0xff, (byte)0xff};
+       byte [] sender = new byte[] {(byte)192, (byte)168, (byte)0, (byte)1};
+       byte [] target = new byte[] {(byte)192, (byte)168, (byte)0, (byte)250};
+       List<NodeConnector> connectors = createNodeConnectors(1, false);
+       PacketContext pctx = createARPPacketContext(src, dst, sender, target,
+               (short)-1, connectors.get(0), ARP.REQUEST);
+
+       MacAddressTable table = new MacAddressTable(mgr, "table", 600);
+       table.add(mgr, pctx);
+
+       sleep(10L);
+       assertEquals(1, hl1.getHostListenerCalled());
+       assertEquals(1, hl2.getHostListenerCalled());
+
+       mgr.removeHostListener(hl2);
+       mgr.removeHostListener(hl1);
+    }
+
+    /**
+     * Test method for
+     * {@link VTNManagerImpl#setResourceManager(IVTNResourceManager)},
+     * {@link VTNManagerImpl#unsetResourceManager(IVTNResourceManager)},
+     * {@link VTNManagerImpl#getResourceManager()}
+     */
+    @Test
+    public void testSetResourceManager() {
+        VTNManagerImpl mgr = vtnMgr;
+        IVTNResourceManager org = mgr.getResourceManager();
+        GlobalResourceManager newmgr = new GlobalResourceManager();
+
+        mgr.setResourceManager(newmgr);
+        assertSame(newmgr, mgr.getResourceManager());
+
+        mgr.unsetResourceManager(newmgr);
+        // TODO:
+//        assertNull(mgr.getResourceManager());
+
+        mgr.setResourceManager(org);
+        assertSame(org, mgr.getResourceManager());
+    }
+
+    /**
+     * Test method for
+     * {@link VTNManagerImpl#removeVTNManagerAware(IVTNManagerAware)},
+     * {@link VTNManagerImpl#addVTNManagerAware(IVTNManagerAware)}
+     */
+    @Test
+    public void testIVTNManagerAware() {
+        VTNManagerImpl mgr = vtnMgr;
+
+        class VTNManagerAwareData<T, S> {
+            T path = null;
+            S obj = null;
+            UpdateType type = null;
+            int count = 0;
+
+            VTNManagerAwareData(T p, S o, UpdateType t, int c) {
+                path = p;
+                obj = o;
+                type = t;
+                count = c;
+            }
+        };
+
+        class VTNManagerAwareStub implements IVTNManagerAware {
+            private final long sleepMilliTime = 10L;
+
+            private int vtnChangedCalled = 0;
+            private int vbrChangedCalled = 0;
+            private int vIfChangedCalled = 0;
+            private int vlanMapChangedCalled = 0;
+            private int portMapChangedCalled = 0;
+            VTNManagerAwareData<VTenantPath, VTenant> vtnChangedInfo = null;
+            VTNManagerAwareData<VBridgePath, VBridge> vbrChangedInfo = null;
+            VTNManagerAwareData<VBridgeIfPath, VInterface> vIfChangedInfo = null;
+            VTNManagerAwareData<VBridgePath, VlanMap> vlanMapChangedInfo = null;
+            VTNManagerAwareData<VBridgeIfPath, PortMap> portMapChangedInfo = null;
+
+            @Override
+            public void vtnChanged(VTenantPath path, VTenant vtenant, UpdateType type) {
+                vtnChangedCalled++;
+                vtnChangedInfo = new VTNManagerAwareData<VTenantPath, VTenant>(path, vtenant,
+                        type, vtnChangedCalled);
+            }
+
+            @Override
+            public void vBridgeChanged(VBridgePath path, VBridge vbridge, UpdateType type) {
+                vbrChangedCalled++;
+                vbrChangedInfo = new VTNManagerAwareData<VBridgePath, VBridge>(path, vbridge, type,
+                        vbrChangedCalled);
+            }
+
+            @Override
+            public void vBridgeInterfaceChanged(VBridgeIfPath path, VInterface viface, UpdateType type) {
+                vIfChangedCalled++;
+                vIfChangedInfo = new VTNManagerAwareData<VBridgeIfPath, VInterface>(path, viface, type,
+                        vIfChangedCalled);
+            }
+
+            @Override
+            public void vlanMapChanged(VBridgePath path, VlanMap vlmap, UpdateType type) {
+                vlanMapChangedCalled++;
+                vlanMapChangedInfo = new VTNManagerAwareData<VBridgePath, VlanMap>(path, vlmap, type,
+                        vlanMapChangedCalled);
+            }
+
+            @Override
+            public void portMapChanged(VBridgeIfPath path, PortMap pmap, UpdateType type) {
+                portMapChangedCalled++;
+                portMapChangedInfo = new VTNManagerAwareData<VBridgeIfPath, PortMap>(path, pmap, type,
+                        portMapChangedCalled);
+            }
+
+            void checkVtnInfo (int count, VTenantPath path, String name, UpdateType type) {
+                sleep(sleepMilliTime);
+                assertEquals(count, vtnChangedCalled);
+                if (path != null) {
+                    assertEquals(path, vtnChangedInfo.path);
+                }
+                if (name != null) {
+                    assertEquals(name, vtnChangedInfo.obj.getName());
+                }
+                if (type != null) {
+                    assertEquals(type, vtnChangedInfo.type);
+                }
+                vtnChangedCalled = 0;
+                vtnChangedInfo = null;
+            }
+
+            void checkVbrInfo (int count, VBridgePath path, String name, UpdateType type) {
+                sleep(sleepMilliTime);
+                assertEquals(count, vbrChangedCalled);
+                if (path != null) {
+                    assertEquals(path, vbrChangedInfo.path);
+                }
+                if (name != null) {
+                    assertEquals(name, vbrChangedInfo.obj.getName());
+                }
+                if (type != null) {
+                    assertEquals(type, vbrChangedInfo.type);
+                }
+                vbrChangedCalled = 0;
+                vbrChangedInfo = null;
+            }
+
+            void checkVIfInfo (int count, VBridgeIfPath path, String name, UpdateType type) {
+                sleep(sleepMilliTime);
+                assertEquals(count, vIfChangedCalled);
+                if (path != null) {
+                    assertEquals(path, vIfChangedInfo.path);
+                }
+                if (name != null) {
+                    assertEquals(name, vIfChangedInfo.obj.getName());
+                }
+                if (type != null) {
+                    assertEquals(type, vIfChangedInfo.type);
+                }
+                vIfChangedCalled = 0;
+                vIfChangedInfo = null;
+            }
+
+            void checkVlmapInfo (int count, VBridgePath path, String id, UpdateType type) {
+                sleep(sleepMilliTime);
+                assertEquals(count, vlanMapChangedCalled);
+                if (path != null) {
+                    assertEquals(path, vlanMapChangedInfo.path);
+                }
+                if (id != null) {
+                    assertEquals(id, vlanMapChangedInfo.obj.getId());
+                }
+                if (type != null) {
+                    assertEquals(type, vlanMapChangedInfo.type);
+                }
+                vlanMapChangedCalled = 0;
+                vlanMapChangedInfo = null;
+            }
+
+            void checkPmapInfo (int count, VBridgeIfPath path, PortMapConfig pconf, UpdateType type) {
+                sleep(sleepMilliTime);
+                assertEquals(count, portMapChangedCalled);
+                if (path != null) {
+                    assertEquals(path, portMapChangedInfo.path);
+                }
+                if (pconf != null) {
+                    assertEquals(pconf, portMapChangedInfo.obj.getConfig());
+                }
+                if (type != null) {
+                    assertEquals(type, portMapChangedInfo.type);
+                }
+                portMapChangedCalled = 0;
+                portMapChangedInfo = null;
+            }
+
+            void checkAllNull() {
+                sleep(sleepMilliTime);
+                assertEquals(0, vtnChangedCalled);
+                assertNull(vtnChangedInfo);
+                assertEquals(0, vbrChangedCalled);
+                assertNull(vbrChangedInfo);
+                assertEquals(0, vIfChangedCalled);
+                assertNull(vIfChangedInfo);
+                assertEquals(0, vlanMapChangedCalled);
+                assertNull(vlanMapChangedInfo);
+                assertEquals(0, portMapChangedCalled);
+                assertNull(portMapChangedInfo);
+            }
+        };
+
+        VTNManagerAwareStub stub1 = new VTNManagerAwareStub();
+        VTNManagerAwareStub stub2 = new VTNManagerAwareStub();
+
+        // add a tenant
+        String tname = "tenant";
+        VTenantPath tpath = new VTenantPath(tname);
+        Status st = mgr.addTenant(tpath, new VTenantConfig(null));
+        assertTrue(st.isSuccess());
+        stub1.checkAllNull();
+        stub2.checkAllNull();
+
+        mgr.addVTNManagerAware(stub1);
+        mgr.addVTNManagerAware(stub2);
+        stub1.checkVtnInfo(1, tpath, tname, UpdateType.ADDED);
+        stub2.checkVtnInfo(1, tpath, tname, UpdateType.ADDED);
+
+        mgr.removeVTNManagerAware(stub2);
+        mgr.addVTNManagerAware(stub2);
+        stub2.checkVtnInfo(1, tpath, tname, UpdateType.ADDED);
+        stub1.checkAllNull();
+        stub2.checkAllNull();
+
+        // add a vbridge
+        String bname = "bridge";
+        VBridgePath bpath = new VBridgePath(tname, bname);
+        st = mgr.addBridge(bpath, new VBridgeConfig(null));
+        assertTrue(st.isSuccess());
+        stub1.checkVbrInfo(1, bpath, bname, UpdateType.ADDED);
+        stub2.checkVbrInfo(1, bpath, bname, UpdateType.ADDED);
+
+        mgr.removeVTNManagerAware(stub2);
+        mgr.addVTNManagerAware(stub2);
+        stub2.checkVtnInfo(1, tpath, tname, UpdateType.ADDED);
+        stub2.checkVbrInfo(1, bpath, bname, UpdateType.ADDED);
+        stub1.checkAllNull();
+        stub2.checkAllNull();
+
+        // add a vInterface
+        String ifname = "vif";
+        VBridgeIfPath ifpath = new VBridgeIfPath(tname, bname, ifname);
+        VInterfaceConfig ifconf = new VInterfaceConfig(null, null);
+        st = mgr.addBridgeInterface(ifpath, ifconf);
+        assertTrue(st.isSuccess());
+        stub1.checkVIfInfo(1, ifpath, ifname, UpdateType.ADDED);
+        stub2.checkVIfInfo(1, ifpath, ifname, UpdateType.ADDED);
+
+        mgr.removeVTNManagerAware(stub2);
+        mgr.addVTNManagerAware(stub2);
+        stub2.checkVtnInfo(1, tpath, tname, UpdateType.ADDED);
+        stub2.checkVbrInfo(1, bpath, bname, UpdateType.ADDED);
+        stub2.checkVIfInfo(1, ifpath, ifname, UpdateType.ADDED);
+        stub1.checkAllNull();
+        stub2.checkAllNull();
+
+        // set a PortMap
+        Node node = NodeCreator.createOFNode(0L);
+        SwitchPort port = new SwitchPort(NodeConnector.NodeConnectorIDType.OPENFLOW,
+        String.valueOf(10));
+        PortMapConfig pmconf = new PortMapConfig(node, port, (short)0);
+        st = mgr.setPortMap(ifpath, pmconf);
+
+        // at this vbridge status and vInterface status are UNKNOWN -> DOWN.
+        stub1.checkVbrInfo(1, bpath, bname, UpdateType.CHANGED);
+        stub1.checkVIfInfo(1, ifpath, ifname, UpdateType.CHANGED);
+        stub1.checkPmapInfo(1, ifpath, pmconf, UpdateType.ADDED);
+        stub2.checkVbrInfo(1, bpath, bname, UpdateType.CHANGED);
+        stub2.checkVIfInfo(1, ifpath, ifname, UpdateType.CHANGED);
+        stub2.checkPmapInfo(1, ifpath, pmconf, UpdateType.ADDED);
+
+        mgr.removeVTNManagerAware(stub2);
+        mgr.addVTNManagerAware(stub2);
+        stub2.checkVtnInfo(1, tpath, tname, UpdateType.ADDED);
+        stub2.checkVbrInfo(1, bpath, bname, UpdateType.ADDED);
+        stub2.checkVIfInfo(1, ifpath, ifname, UpdateType.ADDED);
+        // TODO: need to check.
+//        stub2.checkPmapInfo(1, ifpath, pmconf, UpdateType.ADDED);
+        stub1.checkAllNull();
+        stub2.checkAllNull();
+
+        // set a VLanMap
+        VlanMapConfig vlconf = new VlanMapConfig(null, (short)4095);
+        VlanMap map = null;
+        try {
+            map = mgr.addVlanMap(bpath, vlconf);
+        } catch (VTNException e) {
+            unexpected(e);
+        }
+        stub1.checkVlmapInfo(1, bpath, map.getId(), UpdateType.ADDED);
+        stub2.checkVlmapInfo(1, bpath, map.getId(), UpdateType.ADDED);
+
+        mgr.removeVTNManagerAware(stub2);
+        mgr.addVTNManagerAware(stub2);
+        stub2.checkVtnInfo(1, tpath, tname, UpdateType.ADDED);
+        stub2.checkVbrInfo(1, bpath, bname, UpdateType.ADDED);
+        stub2.checkVIfInfo(1, ifpath, ifname, UpdateType.ADDED);
+        // TODO: need to check.
+//      stub2.checkPmapInfo(1, ifpath, pmconf, UpdateType.ADDED);
+        stub2.checkVlmapInfo(1, bpath, map.getId(), UpdateType.ADDED);
+        stub1.checkAllNull();
+        stub2.checkAllNull();
+
+        // modify a tenant setting
+        st = mgr.modifyTenant(tpath, new VTenantConfig("desc"), false);
+        assertTrue(st.isSuccess());
+        stub1.checkVtnInfo(1, tpath, tname, UpdateType.CHANGED);
+        stub2.checkVtnInfo(1, tpath, tname, UpdateType.CHANGED);
+        stub1.checkAllNull();
+        stub2.checkAllNull();
+
+        st = mgr.modifyBridge(bpath, new VBridgeConfig("desc"), false);
+        assertTrue(st.isSuccess());
+        stub1.checkVbrInfo(1, bpath, bname, UpdateType.CHANGED);
+        stub2.checkVbrInfo(1, bpath, bname, UpdateType.CHANGED);
+        stub1.checkAllNull();
+        stub2.checkAllNull();
+
+        st = mgr.modifyBridgeInterface(ifpath, new VInterfaceConfig("interface", true), false);
+        assertTrue(st.isSuccess());
+        stub1.checkVIfInfo(1, ifpath, ifname, UpdateType.CHANGED);
+        stub2.checkVIfInfo(1, ifpath, ifname, UpdateType.CHANGED);
+        stub1.checkAllNull();
+        stub2.checkAllNull();
+
+        // change a PortMap setting
+        port = new SwitchPort(NodeConnector.NodeConnectorIDType.OPENFLOW, String.valueOf(11));
+        pmconf = new PortMapConfig(node, port, (short)0);
+        st = mgr.setPortMap(ifpath, pmconf);
+        stub1.checkPmapInfo(1, ifpath, pmconf, UpdateType.CHANGED);
+        stub2.checkPmapInfo(1, ifpath, pmconf, UpdateType.CHANGED);
+
+        // remove a VLANMap
+        st = mgr.removeVlanMap(bpath, map.getId());
+        assertTrue(st.isSuccess());
+        stub1.checkVlmapInfo(1, bpath, map.getId(), UpdateType.REMOVED);
+        stub2.checkVlmapInfo(1, bpath, map.getId(), UpdateType.REMOVED);
+        stub1.checkAllNull();
+        stub2.checkAllNull();
+
+        // remove a portmap
+        st = mgr.setPortMap(ifpath, null);
+        assertTrue(st.isSuccess());
+
+        // vBridge status and vInterface status is changed (DOWN->UNKNOWN)
+        stub1.checkVbrInfo(1, bpath, bname, UpdateType.CHANGED);
+        stub1.checkVIfInfo(1, ifpath, ifname, UpdateType.CHANGED);
+        stub1.checkPmapInfo(1, ifpath, pmconf, UpdateType.REMOVED);
+        stub2.checkVbrInfo(1, bpath, bname, UpdateType.CHANGED);
+        stub2.checkVIfInfo(1, ifpath, ifname, UpdateType.CHANGED);
+        stub2.checkPmapInfo(1, ifpath, pmconf, UpdateType.REMOVED);
+        stub1.checkAllNull();
+        stub2.checkAllNull();
+
+        // remove a vbridge interface
+        st = mgr.removeBridgeInterface(ifpath);
+        assertTrue(st.isSuccess());
+        stub1.checkVIfInfo(1, ifpath, ifname, UpdateType.REMOVED);
+        stub2.checkVIfInfo(1, ifpath, ifname, UpdateType.REMOVED);
+        stub1.checkAllNull();
+        stub2.checkAllNull();
+
+        // remove a vbridge
+        st = mgr.removeBridge(bpath);
+        assertTrue(st.isSuccess());
+        stub1.checkVbrInfo(1, bpath, bname, UpdateType.REMOVED);
+        stub2.checkVbrInfo(1, bpath, bname, UpdateType.REMOVED);
+        stub1.checkAllNull();
+        stub2.checkAllNull();
+
+        // remove a tenant
+        st =mgr.removeTenant(tpath);
+        assertTrue(st.isSuccess());
+        stub1.checkVtnInfo(1, tpath, tname, UpdateType.REMOVED);
+        stub2.checkVtnInfo(1, tpath, tname, UpdateType.REMOVED);
+        stub1.checkAllNull();
+        stub2.checkAllNull();
+    }
+
+
+    /**
+     * Test method for
+     * {@link VTNManagerImpl#addVTNModeListener(IVTNModeListener)},
+     * {@link oVTNManagerImpl#removeVTNModeListener(IVTNModeListener)}
+     * {@link VTNManagerImpl#notifyChange(boolean)},
+     * {@link VTNManagerImpl#notifyChange(IVTNModeListener, boolean)}
+     */
+    @Test
+    public void testIVTNModeListener() {
+        VTNManagerImpl mgr = vtnMgr;
+
+        // stub for test
+        class VTNModeListenerStub implements IVTNModeListener {
+            private int calledCount = 0;
+            private Boolean oldactive = null;
+            private final long sleepMilliTime = 10L;
+
+            @Override
+            public void vtnModeChanged(boolean active) {
+                calledCount++;
+                oldactive = Boolean.valueOf(active);
+            }
+
+            public int getCalledCount() {
+                sleep(sleepMilliTime);
+                int ret = calledCount;
+                calledCount = 0;
+                return ret;
+            }
+
+            public Boolean getCalledArg() {
+                sleep(sleepMilliTime);
+                Boolean ret = oldactive;
+                oldactive = null;
+                return ret;
+            }
+        };
+
+        VTNModeListenerStub stub1 = new VTNModeListenerStub();
+        VTNModeListenerStub stub2 = new VTNModeListenerStub();
+
+        VTenantPath tpath = new VTenantPath("tenant");
+        Status st = mgr.addTenant(tpath, new VTenantConfig(null));
+        assertTrue(st.isSuccess());
+        assertEquals(0, stub1.getCalledCount());
+        assertEquals(0, stub2.getCalledCount());
+
+        mgr.addVTNModeListener(stub1);
+        assertEquals(1, stub1.getCalledCount());
+        assertEquals(true, stub1.getCalledArg());
+
+        mgr.addVTNModeListener(stub2);
+        assertEquals(1, stub2.getCalledCount());
+        assertEquals(true, stub2.getCalledArg());
+        assertEquals(0, stub1.getCalledCount());
+
+        mgr.addVTNModeListener(stub1);
+        assertEquals(0, stub1.getCalledCount());
+        assertEquals(0, stub2.getCalledCount());
+
+        // notifyChange(boolean)
+        for (Boolean bool: createBooleans(false)) {
+            boolean curr = bool.booleanValue();
+            mgr.notifyChange(curr);
+            sleep(1L);
+            assertEquals(1, stub1.getCalledCount());
+            assertEquals(1, stub2.getCalledCount());
+            assertEquals(bool, stub1.getCalledArg());
+            assertEquals(bool, stub2.getCalledArg());
+        }
+
+        // notifyChange(IVTNModeListener, boolean)
+        for (Boolean bool: createBooleans(false)) {
+            boolean curr = bool.booleanValue();
+            mgr.notifyChange(stub1, curr);
+            assertEquals(1, stub1.getCalledCount());
+            assertEquals(0, stub2.getCalledCount());
+            assertEquals(bool, stub1.getCalledArg());
+            assertEquals(null, stub2.getCalledArg());
+
+            mgr.notifyChange(stub2, curr);
+            assertEquals(1, stub2.getCalledCount());
+            assertEquals(0, stub1.getCalledCount());
+            assertEquals(bool, stub2.getCalledArg());
+            assertEquals(null, stub1.getCalledArg());
+        }
+
+        // remove Tenant
+        st = mgr.removeTenant(tpath);
+        assertTrue(st.isSuccess());
+        assertEquals(1, stub1.getCalledCount());
+        assertEquals(1, stub2.getCalledCount());
+        assertEquals(false, stub1.getCalledArg());
+        assertEquals(false, stub2.getCalledArg());
+
+        // remove stub1
+        mgr.removeVTNModeListener(stub1);
+        mgr.notifyChange(true);
+        assertEquals(1, stub2.getCalledCount());
+        assertEquals(0, stub1.getCalledCount());
+        assertEquals(true, stub2.getCalledArg());
+        assertEquals(null, stub1.getCalledArg());
+
+        mgr.removeVTNModeListener(stub2);
+        mgr.notifyChange(true);
+        assertEquals(0, stub2.getCalledCount());
+        assertEquals(0, stub1.getCalledCount());
+        assertEquals(null, stub2.getCalledArg());
+        assertEquals(null, stub1.getCalledArg());
+
+        // add in case that there is no tenant.
+        mgr.addVTNModeListener(stub1);
+        assertEquals(1, stub1.getCalledCount());
+        assertEquals(false, stub1.getCalledArg());
+
+        mgr.removeVTNModeListener(stub1);
+    }
+
+    /**
+     * Test method for
+     * {@link org.opendaylight.controller.vtn.internal.VTNManagerImpl#getStateDB()}
+     */
+    @Test
+    public void testGetStateDB() {
+        // TODO:
+    }
+
+    /**
+     * Test method for
+     * {@link VTNManagerImpl#addMacAddressTable(VBridgePath, int)},
+     * {@link VTNManagerImpl#removeMacAddressTable(VBridgePath, boolean)},
+     * {@link VTNManagerImpl#getMacAddressTable(VBridgePath)}
+     */
+    @Test
+    public void testMacAddressTable() {
+        VTNManagerImpl mgr = vtnMgr;
+        MacAddressTable table = null;
+        VBridgePath bpath = new VBridgePath("teannt", "bridge");
+        int[] ages = new int[] {10, 600, 1000000};
+
+        for (int age: ages) {
+            mgr.addMacAddressTable(bpath, age);
+
+            table = mgr.getMacAddressTable(bpath);
+            assertNotNull(table);
+
+            mgr.removeMacAddressTable(bpath, false);
+        }
+
+        table = mgr.getMacAddressTable(bpath);
+        assertNull(table);
+
+        mgr.removeMacAddressTable(bpath, false);
+    }
+
+    /**
+     * Test method for
+     * {@link VTNManagerImpl#addTenant(VTenantPath, VTenantConfig)},
+     * {@link VTNManagerImpl#removeTenant(VTenantPath)},
+     * {@link VTNManagerImpl#getTenants()},
+     * {@link VTNManagerImpl#getTenant(VTenantPath)},
+     * {@link VTNManagerImpl#isActive()}
+     */
+//    @Ignore("")
+    @Test
+    public void testAddGetRemoveTenant() {
+        VTNManagerImpl mgr = vtnMgr;
+        List<String> strings = createStrings("tenant", false);
+        List<String> descs = createStrings("desc");
+        List<Integer> ivs = createIntegers(-1, 4);
+        List<Integer> hvs = createIntegers(-1, 4);
+
+        strings.add(new String("123456789012345678901234567890_"));
+        ivs.add(new Integer(65535));
+        hvs.add(new Integer(65535));
+
+        assertFalse(mgr.isActive());
+
+        // test for add
+        for (String tname : strings) {
+            if (tname.isEmpty()) {
+                // empty is invalid for tenant name.
+                continue;
+            }
+            VTenantPath tpath = new VTenantPath(tname);
+
+            for (String desc : descs) {
+                for (Integer iv : ivs) {
+                    for (Integer hv : hvs) {
+                        VTenantConfig tconf = createVTenantConfig(desc, iv, hv);
+
+                        Status st = mgr.addTenant(tpath, tconf);
+                        if (iv != null && hv != null && iv.intValue() > 0 && hv.intValue() > 0
+                                && iv.intValue() >= hv.intValue()) {
+                            assertEquals(tconf.toString(), StatusCode.BADREQUEST, st.getCode());
+                            continue;
+                        } else if ((iv == null || iv.intValue() < 0) && hv != null &&
+                                hv.intValue() > 0 && 300 >= hv.intValue()) {
+                            assertEquals(tconf.toString(), StatusCode.BADREQUEST, st.getCode());
+                            continue;
+                        } else {
+                            assertTrue(tconf.toString(), st.isSuccess());
+                            assertTrue(tconf.toString(), mgr.isActive());
+                        }
+
+                        // getTenant()
+                        VTenant tenant = null;
+                        try {
+                            tenant = mgr.getTenant(tpath);
+                        } catch (Exception e) {
+                            unexpected(e);
+                        }
+                        assertEquals(tname, tenant.getName());
+                        assertEquals(tconf.getDescription(), tenant.getDescription());
+                        if (iv == null || iv.intValue() < 0) {
+                            assertEquals(tconf.toString(), 300, tenant.getIdleTimeout());
+                        } else {
+                            assertEquals(tconf.toString(), iv.intValue(), tenant.getIdleTimeout());
+                        }
+                        if (hv == null || hv.intValue() < 0) {
+                            assertEquals(tconf.toString(), 0, tenant.getHardTimeout());
+                        } else {
+                            assertEquals(tconf.toString(), hv.intValue(), tenant.getHardTimeout());
+                        }
+
+                        // removeTenant()
+                        mgr.removeTenant(tpath);
+                        assertTrue(tconf.toString(), st.isSuccess());
+                    }
+                }
+            }
+        }
+
+        try {
+            List<VTenant> list = mgr.getTenants();
+            assertTrue(list.size() == 0);
+        } catch (Exception e) {
+            unexpected(e);
+        }
+
+        assertFalse(mgr.isActive());
+    }
+
+    /**
+     * Test method for
+     * {@link VTNManagerImpl#modifyTenant(VTenantPath, VTenantConfig, boolean)}
+     */
+    @Test
+    public void testModifyTenant() {
+        VTNManagerImpl mgr = vtnMgr;
+        List<String> tnames = new ArrayList<String>();
+        List<String> descs = new ArrayList<String>();
+        List<Integer> ivs = createIntegers(-1, 4);
+        List<Integer> hvs = createIntegers(-1, 4);
+
+        tnames.add(new String("vtn"));
+        tnames.add(new String("123456789012345678901234567890_"));
+        descs.add(null);
+        descs.add(new String("desc"));
+        ivs.add(new Integer(65535));
+        hvs.add(new Integer(65535));
+
+        boolean first = true;
+        for (String tname : tnames) {
+            VTenantPath tpath = new VTenantPath(tname);
+            VTenantConfig tconf = createVTenantConfig(new String("orig"), 20, 30);
+            Status st = mgr.addTenant(tpath, tconf);
+
+            for (String desc : descs) {
+                for (Integer orgiv : ivs) {
+                    for (Integer orghv : hvs) {
+                        // check parameters
+                        if (orgiv != null && orghv != null && orgiv.intValue() > 0 && orghv.intValue() > 0
+                                && orgiv.intValue() >= orghv.intValue()) {
+                            continue;
+                        } else if ((orgiv == null || orgiv.intValue() < 0) && orghv != null && orghv.intValue() > 0
+                                && 300 >= orghv.intValue()) {
+                            continue;
+                        }
+
+                        String olddesc;
+                        Integer oldiv;
+                        Integer oldhv;
+                        for (Integer iv : ivs) {
+                            for (Integer hv : hvs) {
+                                VTenant tenant = null;
+
+                                if (first) {
+                                    for (String ndesc : descs) {
+                                        // test for all == true. executed at
+                                        // first time only.
+                                        tconf = createVTenantConfig(ndesc, iv, hv);
+                                        st = mgr.modifyTenant(tpath, tconf, true);
+
+                                        if (iv != null && hv != null &&
+                                            iv.intValue() > 0 && hv.intValue() > 0 &&
+                                            iv.intValue() >= hv.intValue()) {
+                                            assertEquals(tconf.toString(),
+                                                    StatusCode.BADREQUEST, st.getCode());
+                                        } else if ((iv == null || iv < 0) &&
+                                                hv != null && hv > 0 && 300 >= hv) {
+                                            assertEquals(tconf.toString(),
+                                                    StatusCode.BADREQUEST, st.getCode());
+                                        } else {
+                                            assertTrue(tconf.toString(), st.isSuccess());
+                                        }
+
+                                        try {
+                                            tenant = mgr.getTenant(tpath);
+                                        } catch (Exception e) {
+                                            unexpected(e);
+                                        }
+
+                                        if (st.isSuccess()) {
+                                            assertEquals(tconf.toString(),
+                                                    tname, tenant.getName());
+                                            assertEquals(tconf.toString(),
+                                                    ndesc, tenant.getDescription());
+                                            if (iv == null || iv.intValue() < 0) {
+                                                assertEquals(tconf.toString(),
+                                                        300, tenant.getIdleTimeout());
+                                            } else {
+                                                assertEquals(tconf.toString(),
+                                                        iv.intValue(), tenant.getIdleTimeout());
+                                            }
+                                            if (hv == null || hv.intValue() < 0) {
+                                                assertEquals(tconf.toString(),
+                                                        0, tenant.getHardTimeout());
+                                            } else {
+                                                assertEquals(tconf.toString(),
+                                                        hv.intValue(), tenant.getHardTimeout());
+                                            }
+                                        }
+                                    }
+                                }
+
+                                tconf = createVTenantConfig(desc, orgiv, orghv);
+                                st = mgr.modifyTenant(tpath, tconf, true);
+
+                                olddesc = (desc == null) ? null : new String(desc);
+                                oldiv = (orgiv == null || orgiv.intValue() < 0) ?
+                                            new Integer(300) : orgiv;
+                                oldhv = (orghv == null || orghv.intValue() < 0) ?
+                                            new Integer(0) : orghv;
+
+                                // all == false
+                                tconf = createVTenantConfig(desc, iv, hv);
+                                st = mgr.modifyTenant(tpath, tconf, false);
+
+                                if ((iv == null || iv.intValue() < 0) && (hv == null || hv.intValue() < 0)) {
+                                    // both are notset
+                                    // not changed.
+                                } else if (iv == null || iv.intValue() < 0) {
+                                    // idle_timeout is notset
+                                    if (hv.intValue() > 0
+                                            && (oldiv.intValue() != 0 && oldiv.intValue() >= hv.intValue())) {
+                                        assertEquals(tconf.toString(),
+                                                StatusCode.BADREQUEST, st.getCode());
+                                    } else {
+                                        assertTrue(tconf.toString(), st.isSuccess());
+                                    }
+                                } else if (hv == null || hv.intValue() < 0) {
+                                    // hard_timeout is notset
+                                    if (iv > 0 && oldhv > 0) {
+                                        if (iv >= oldhv) {
+                                            assertEquals(tconf.toString(),
+                                                    StatusCode.BADREQUEST, st.getCode());
+                                        } else {
+                                            assertTrue(tconf.toString(), st.isSuccess());
+                                        }
+                                    } else {
+                                        assertTrue(tconf.toString(), st.isSuccess());
+                                    }
+                                } else {
+                                    // both are set
+                                    if (iv.intValue() > 0 && hv.intValue() > 0) {
+                                        if (iv.intValue() >= hv.intValue()) {
+                                            assertEquals(tconf.toString(),
+                                                    StatusCode.BADREQUEST, st.getCode());
+                                        } else {
+                                            assertTrue(tconf.toString(), st.isSuccess());
+                                        }
+                                    } else {
+                                        assertTrue(tconf.toString(), st.isSuccess());
+                                    }
+                                }
+
+                                tenant = null;
+                                try {
+                                    tenant = mgr.getTenant(tpath);
+                                } catch (Exception e) {
+                                    unexpected(e);
+                                }
+
+                                if (st.isSuccess()) {
+                                    assertEquals(tconf.toString(), tname, tenant.getName());
+                                    assertEquals(tconf.toString(), olddesc, tenant.getDescription());
+                                    if (iv == null || iv.intValue() < 0) {
+                                        assertEquals(tconf.toString(),
+                                                oldiv.intValue(), tenant.getIdleTimeout());
+                                    } else {
+                                        assertEquals(tconf.toString(),
+                                                iv.intValue(), tenant.getIdleTimeout());
+                                    }
+                                    if (hv == null || hv.intValue() < 0) {
+                                        assertEquals(tconf.toString(),
+                                                oldhv.intValue(), tenant.getHardTimeout());
+                                    } else {
+                                        assertEquals(tconf.toString(),
+                                                hv.intValue(), tenant.getHardTimeout());
+                                    }
+                                }
+
+                                olddesc = tenant.getDescription();
+                                oldiv = tenant.getIdleTimeout();
+                                oldhv = tenant.getHardTimeout();
+                            }
+                        }
+                        first = false;
+                    }
+                }
+            }
+        }
+
+        try {
+            List<VTenant> list = mgr.getTenants();
+            assertTrue(list.size() == tnames.size());
+        } catch (Exception e) {
+            unexpected(e);
+        }
+
+        for (String tname : tnames) {
+            VTenantPath tpath = new VTenantPath(tname);
+            mgr.removeTenant(tpath);
+        }
+    }
+
+    /**
+     * Test method for invalid cases of
+     * {@link VTNManagerImpl#addTenant(VTenantPath, VTenantConfig)},
+     * {@link VTNManagerImpl#modifyTenant(VTenantPath, VTenantConfig, boolean)},
+     * {@link VTNManagerImpl#removeTenant(VTenantPath)},
+     * {@link VTNManagerImpl#getTenants()},
+     * {@link VTNManagerImpl#getTenant(VTenantPath)}
+     */
+    @Test
+    public void testTenantInvalidCase() {
+        VTNManagerImpl mgr = vtnMgr;
+        String name = "Tenant";
+        String desc = "Description";
+        VTenantPath tpath = new VTenantPath(name);
+        VTenantConfig tconf = new VTenantConfig(desc);
+        Status st = null;
+
+        // bad request
+        VTenantPath[] btplist = new VTenantPath[] {null, new VTenantPath(null)};
+        VTenantConfig[] bcflist = new VTenantConfig[] {
+                null, new VTenantConfig(desc, 65536, 65535),
+                new VTenantConfig(desc, 65535, 65536)};
+
+        for (VTenantPath path: btplist) {
+            st = mgr.addTenant(path, tconf);
+            assertEquals((path == null) ? "null" : path.toString(), StatusCode.BADREQUEST, st.getCode());
+        }
+
+        for (VTenantConfig conf: bcflist) {
+            st = mgr.addTenant(tpath, conf);
+            assertEquals((conf == null) ? "null" : conf.toString(), StatusCode.BADREQUEST, st.getCode());
+        }
+
+        st = mgr.addTenant(new VTenantPath(""), tconf);
+        assertEquals(StatusCode.BADREQUEST, st.getCode());
+        st = mgr.addTenant(new VTenantPath("12345678901234567890123456789012"), tconf);
+        assertEquals(StatusCode.BADREQUEST, st.getCode());
+
+
+        st = mgr.addTenant(tpath, tconf);
+        assertTrue(st.isSuccess());
+
+        for (VTenantPath path: btplist) {
+            st = mgr.modifyTenant(path, tconf, false);
+            assertEquals((path == null) ? "null" : path.toString(),
+                    StatusCode.BADREQUEST, st.getCode());
+
+            st = mgr.removeTenant(path);
+            assertEquals((path == null) ? "null" : path.toString(),
+                    StatusCode.BADREQUEST, st.getCode());
+
+            try {
+                mgr.getTenant(path);
+                fail("Throwing exception was expected.");
+            } catch (VTNException e) {
+               assertEquals((path == null) ? "null" : path.toString(),
+                       StatusCode.BADREQUEST,e.getStatus().getCode());
+            }
+        }
+
+        for (VTenantConfig conf: bcflist) {
+            st = mgr.modifyTenant(tpath, conf, true);
+            assertEquals((conf == null) ? "null" : conf.toString(),
+                    StatusCode.BADREQUEST, st.getCode());
+        }
+
+        // confilct
+        st = mgr.addTenant(tpath, tconf);
+        assertEquals(StatusCode.CONFLICT, st.getCode());
+
+        // not found
+        VTenantPath lpath = new VTenantPath("12345678901234567890123456789012");
+        st = mgr.modifyTenant(lpath, tconf, true);
+        assertEquals(StatusCode.NOTFOUND, st.getCode());
+
+        st = mgr.removeTenant(lpath);
+        assertEquals(StatusCode.NOTFOUND, st.getCode());
+
+        try {
+            mgr.getTenant(lpath);
+            fail("Throwing exception was expected.");
+        } catch (VTNException e) {
+           assertEquals(StatusCode.NOTFOUND, e.getStatus().getCode());
+        }
+
+        st = mgr.removeTenant(tpath);
+        assertTrue(st.isSuccess());
+
+        st = mgr.removeTenant(tpath);
+        assertEquals(StatusCode.NOTFOUND, st.getCode());
+
+        st = mgr.modifyTenant(tpath, tconf, true);
+        assertEquals(StatusCode.NOTFOUND, st.getCode());
+
+        st = mgr.removeTenant(tpath);
+        assertEquals(StatusCode.NOTFOUND, st.getCode());
+
+        // TODO: StatusCode.NOTACCEPTABLE
+    }
+
+    /**
+     * Test method for
+     * {@link VTNManagerImpl#addBridge(VBridgePath, VBridgeConfig)},
+     * {@link VTNManagerImpl#removeBridge(VBridgePath)},
+     * {@link VTNManagerImpl#modifyBridge(VBridgePath, VBridgeConfig, boolean)},
+     * {@link VTNManagerImpl#getBridges(VTenantPath)},
+     * {@link VTNManagerImpl#getBridge(VBridgePath)}.
+     */
+    @Test
+    public void testBridge() {
+        VTNManagerImpl mgr = vtnMgr;
+        List<Integer> ages = new ArrayList<Integer>();
+        List<String> tlist = new ArrayList<String>();
+        List<String> blist = createStrings("vbr", false);
+
+        tlist.add("vtn");
+        tlist.add("123456789012345678901234567890_");
+        blist.add("012345678901234567890123456789_");
+        ages.add(null);
+        ages.add(10);
+        ages.add(600);
+        ages.add(1000000);
+
+        boolean first = true;
+        for (String tname : tlist) {
+            VTenantPath tpath = new VTenantPath(tname);
+            Status st = mgr.addTenant(tpath, new VTenantConfig(null));
+            assertTrue(st.isSuccess());
+
+            for (String bname : blist) {
+                if (bname.isEmpty()) {
+                    continue; // This is a invalid condition.
+                }
+                VBridgePath bpath = new VBridgePath(tname, bname);
+                for (String desc : createStrings("desc")) {
+                    for (Integer age : ages) {
+                        VBridgeConfig bconf = createVBridgeConfig(desc, age);
+                        st = mgr.addBridge(bpath, bconf);
+                        assertTrue(bconf.toString(), st.isSuccess());
+
+                        VBridge brdg = null;
+                        try {
+                            brdg = mgr.getBridge(bpath);
+                        } catch (Exception e) {
+                            unexpected(e);
+                        }
+                        assertEquals(bconf.toString(), bname, brdg.getName());
+                        assertEquals(bconf.toString(), desc, brdg.getDescription());
+                        if (age == null) {
+                            assertEquals(bconf.toString(), 600, brdg.getAgeInterval());
+                        } else {
+                            assertEquals(bconf.toString(), age.intValue(), brdg.getAgeInterval());
+                        }
+                        assertEquals(bconf.toString(), VNodeState.UNKNOWN, brdg.getState());
+
+                        String olddesc = brdg.getDescription();
+                        int oldage = brdg.getAgeInterval();
+
+                        for (String newdesc : createStrings("desc")) {
+                            for (Integer newage : ages) {
+                                bconf = createVBridgeConfig(newdesc, newage);
+                                st = mgr.modifyBridge(bpath, bconf, false);
+
+                                brdg = null;
+                                try {
+                                    brdg = mgr.getBridge(bpath);
+                                } catch (Exception e) {
+                                    unexpected(e);
+                                }
+                                assertEquals(bconf.toString(), bname, brdg.getName());
+                                if (newdesc == null) {
+                                    assertEquals(bconf.toString(),
+                                            olddesc, brdg.getDescription());
+                                } else {
+                                    assertEquals(bconf.toString(),
+                                            newdesc, brdg.getDescription());
+                                    olddesc = newdesc;
+                                }
+                                if (newage == null) {
+                                    assertEquals(bconf.toString(), oldage, brdg.getAgeInterval());
+                                } else {
+                                    assertEquals(bconf.toString(),
+                                            newage.intValue(), brdg.getAgeInterval());
+                                    oldage = newage.intValue();
+                                }
+                                assertEquals(bconf.toString(),
+                                        VNodeState.UNKNOWN, brdg.getState());
+                            }
+                        }
+
+                        st = mgr.removeBridge(bpath);
+                        assertTrue(bpath.toString(), st.isSuccess());
+                    }
+
+                    if (first) {
+                        VBridgeConfig bconf = new VBridgeConfig("desc", 10);
+                        st = mgr.addBridge(bpath, bconf);
+                        for (String newdesc : createStrings("desc")) {
+                            for (Integer newage : ages) {
+                                bconf = createVBridgeConfig(newdesc, newage);
+                                st = mgr.modifyBridge(bpath, bconf, true);
+
+                                VBridge brdg = null;
+                                try {
+                                    brdg = mgr.getBridge(bpath);
+                                } catch (Exception e) {
+                                    unexpected(e);
+                                }
+                                assertEquals(bconf.toString(), bname, brdg.getName());
+                                assertEquals(bconf.toString(), newdesc, brdg.getDescription());
+                                if (newage == null) {
+                                    assertEquals(bconf.toString(), 600, brdg.getAgeInterval());
+                                } else {
+                                    assertEquals(bconf.toString(),
+                                            newage.intValue(), brdg.getAgeInterval());
+                                }
+                                assertEquals(bconf.toString(),
+                                        VNodeState.UNKNOWN, brdg.getState());
+                            }
+                        }
+
+                        st = mgr.removeBridge(bpath);
+                        assertTrue(bpath.toString(), st.isSuccess());
+
+                        first = false;
+                    }
+                }
+            }
+
+            try {
+                List<VBridge> list = mgr.getBridges(tpath);
+                assertEquals(tpath.toString(), 0, list.size());
+            } catch (VTNException e) {
+                unexpected(e);
+            }
+            st = mgr.removeTenant(tpath);
+            assertTrue(tpath.toString(), st.isSuccess());
+        }
+
+        // add mulitple entry.
+        for (String tname : tlist) {
+            VTenantPath tpath = new VTenantPath(tname);
+            Status st = mgr.addTenant(tpath, new VTenantConfig(null));
+            assertTrue(tpath.toString(), st.isSuccess());
+
+            for (String bname : blist) {
+                if (bname.isEmpty()) {
+                    continue; // This is a invalid condition.
+                }
+                VBridgePath bpath = new VBridgePath(tname, bname);
+                VBridgeConfig bconf = createVBridgeConfig(null, null);
+
+                st = mgr.addBridge(bpath, bconf);
+                assertTrue(bconf.toString(), st.isSuccess());
+            }
+            try {
+                List<VBridge> list = mgr.getBridges(tpath);
+                assertEquals(tpath.toString(), blist.size() - 1, list.size());
+            } catch (VTNException e) {
+                unexpected(e);
+            }
+            st = mgr.removeTenant(tpath);
+            assertTrue(tpath.toString(), st.isSuccess());
+        }
+    }
+
+    /**
+     * Test method for invalid cases of
+     * {@link VTNManagerImpl#addBridge(VBridgePath, VBridgeConfig)},
+     * {@link VTNManagerImpl#removeBridge(VBridgePath)},
+     * {@link VTNManagerImpl#modifyBridge(VBridgePath, VBridgeConfig, boolean)},
+     * {@link VTNManagerImpl#getBridges(VTenantPath)},
+     * {@link VTNManagerImpl#getBridge(VBridgePath)}.
+     */
+    @Test
+    public void testBridgeInvalidCase() {
+        VTNManagerImpl mgr = vtnMgr;
+
+        // invalid case for addBridge()
+        String tname = "tenant";
+        VTenantPath tpath = new VTenantPath(tname);
+        Status st = mgr.addTenant(tpath, new VTenantConfig(null));
+        assertTrue(st.isSuccess());
+        String bname = "bridge";
+        VBridgePath bpath = new VBridgePath(tname, bname);
+        VBridgeConfig bconf = createVBridgeConfig(null, null);
+
+        VBridgePath[] bbplist = new VBridgePath[] {null, new VBridgePath(tname, null),
+                                                    new VBridgePath((String)null, bname)};
+        VBridgeConfig[] bcflist = new VBridgeConfig[] {null, new VBridgeConfig("desc", 9),
+                new VBridgeConfig("desc", 1000001)};
+
+        for (VBridgePath path : bbplist) {
+            st = mgr.addBridge(path, bconf);
+            assertEquals((path == null) ? "null" : path.toString(),
+                    StatusCode.BADREQUEST, st.getCode());
+        }
+
+        st = mgr.addBridge(new VBridgePath(tname, ""), bconf);
+        assertEquals(StatusCode.BADREQUEST, st.getCode());
+        st = mgr.addBridge(new VBridgePath(tname, "123456789012345678901234567890_1"), bconf);
+        assertEquals(StatusCode.BADREQUEST, st.getCode());
+
+        for (VBridgeConfig conf : bcflist) {
+            st = mgr.addBridge(bpath, conf);
+            assertEquals((conf == null) ? "null" :conf.toString(),
+                    StatusCode.BADREQUEST, st.getCode());
+        }
+
+        // add bridge before modifyBridge() and removeBridge()
+        st = mgr.addBridge(bpath, bconf);
+        assertTrue(st.isSuccess());
+
+        for (VBridgePath path : bbplist) {
+            st = mgr.modifyBridge(path, bconf, true);
+            assertEquals((path == null) ? "null" :path.toString(),
+                    StatusCode.BADREQUEST, st.getCode());
+            st = mgr.removeBridge(path);
+            assertEquals((path == null) ? "null" : path.toString(),
+                    StatusCode.BADREQUEST, st.getCode());
+
+            try {
+                mgr.getBridge(path);
+                fail("Throwing exception was expected.");
+            } catch (VTNException e) {
+                assertEquals((path == null) ? "null" : path.toString(),
+                        StatusCode.BADREQUEST, e.getStatus().getCode());
+            }
+        }
+        for (VBridgeConfig conf : bcflist) {
+            st = mgr.modifyBridge(bpath, conf, false);
+            assertEquals((conf == null) ? "null" : conf.toString(),
+                    StatusCode.BADREQUEST, st.getCode());
+        }
+
+        try {
+            mgr.getBridges(null);
+            fail("Throwing exception was expected.");
+        } catch (VTNException e) {
+            assertEquals(StatusCode.BADREQUEST, e.getStatus().getCode());
+        }
+
+        try {
+            mgr.getBridges(new VTenantPath(null));
+            fail("Throwing exception was expected.");
+        } catch (VTNException e) {
+            assertEquals(StatusCode.BADREQUEST, e.getStatus().getCode());
+        }
+
+        // conflict
+        st = mgr.addBridge(bpath, bconf);
+        assertEquals(StatusCode.CONFLICT, st.getCode());
+
+        // not found
+        VBridgePath[] nbplist = new VBridgePath[]{new VBridgePath(tname, "bbbbb"),
+                new VBridgePath("tt", bname)};
+        for (VBridgePath path: nbplist) {
+            st = mgr.removeBridge(path);
+            assertEquals(StatusCode.NOTFOUND, st.getCode());
+
+            st = mgr.modifyBridge(path, bconf, true);
+            assertEquals(StatusCode.NOTFOUND, st.getCode());
+
+            try {
+                mgr.getBridge(path);
+                fail("Throwing exception was expected.");
+            } catch (VTNException e) {
+                assertEquals(StatusCode.NOTFOUND, e.getStatus().getCode());
+            }
+        }
+
+        st = mgr.addBridge(new VBridgePath("tt", bname), bconf);
+        assertEquals(StatusCode.NOTFOUND, st.getCode());
+
+        st = mgr.removeTenant(tpath);
+        assertTrue(st.isSuccess());
+
+        st = mgr.removeBridge(bpath);
+        assertEquals(StatusCode.NOTFOUND, st.getCode());
+
+        st = mgr.addBridge(bpath, bconf);
+        assertEquals(StatusCode.NOTFOUND, st.getCode());
+
+        try {
+            mgr.getBridge(bpath);
+            fail("Throwing exception was expected.");
+        } catch (VTNException e) {
+            assertEquals(StatusCode.NOTFOUND, e.getStatus().getCode());
+        }
+
+        try {
+            mgr.getBridges(tpath);
+            fail("Throwing exception was expected.");
+        } catch (VTNException e) {
+            assertEquals(StatusCode.NOTFOUND, e.getStatus().getCode());
+        }
+
+        // TODO: NOTACCEPTABLE
+    }
+
+    /**
+     * Test method for
+     * {@link VTNManagerImpl#addBridgeInterface(VBridgeIfPath, VInterfaceConfig)},
+     * {@link VTNManagerImpl#modifyBridgeInterface(VBridgeIfPath, VInterfaceConfig, boolean)},
+     * {@link VTNManagerImpl#removeBridgeInterface(VBridgeIfPath)},
+     * {@link VTNManagerImpl#getBridgeInterfaces(VBridgePath)},
+     * {@link VTNManagerImpl#getBridgeInterface(VBridgeIfPath)}.
+     */
+    @Test
+    public void testBridgeInterface() {
+        VTNManagerImpl mgr = vtnMgr;
+        List<String> tlist = new ArrayList<String>();
+        List<String> blist = new ArrayList<String>();
+        List<String> iflist = createStrings("vinterface", false);
+        List<String> descs = new ArrayList<String>();
+
+        tlist.add("vtn");
+        blist.add("vbr");
+        iflist.add("abcdefghijklmnoopqrstuvwxyz1234");
+        descs.add(null);
+        descs.add("description");
+
+        for (String tname : tlist) {
+            VTenantPath tpath = new VTenantPath(tname);
+            Status st = mgr.addTenant(tpath, new VTenantConfig(null));
+            assertTrue(tpath.toString(), st.isSuccess());
+
+            for (String bname : blist) {
+                VBridgePath bpath = new VBridgePath(tname, bname);
+                VBridgeConfig bconf = createVBridgeConfig(null, null);
+                st = mgr.addBridge(bpath, bconf);
+                assertTrue(bpath.toString(), st.isSuccess());
+
+                List<VInterface> list = null;
+                try {
+                    list = mgr.getBridgeInterfaces(bpath);
+                } catch (Exception e) {
+                    unexpected(e);
+                }
+                assertTrue(list.size() == 0);
+
+                for (String ifname : iflist) {
+                    if (ifname.isEmpty()) {
+                        continue; // This is a invalid condition.
+                    }
+
+                    VBridgeIfPath ifp = new VBridgeIfPath(tname, bname, ifname);
+                    for (String desc : createStrings("desc")) {
+                        for (Boolean enabled : createBooleans()) {
+                            VInterfaceConfig ifconf = new VInterfaceConfig(desc, enabled);
+
+                            st = mgr.addBridgeInterface(ifp, ifconf);
+                            assertTrue(ifp.toString() + "," + ifconf.toString(),
+                                    st.isSuccess());
+
+                            VInterface vif = null;
+                            try {
+                                vif = mgr.getBridgeInterface(ifp);
+                            } catch (Exception e) {
+                                unexpected(e);
+                            }
+
+                            assertEquals(ifp.toString() + "," + ifconf.toString(),
+                                    ifname, vif.getName());
+                            assertEquals(ifp.toString() + "," + ifconf.toString(),
+                                    desc, vif.getDescription());
+                            if (enabled == null) {
+                                assertEquals(ifp.toString() + "," + ifconf.toString(),
+                                        Boolean.TRUE, vif.getEnabled());
+                            } else {
+                                assertEquals(ifp.toString() + "," + ifconf.toString(),
+                                        enabled, vif.getEnabled());
+                            }
+                            if (enabled == Boolean.FALSE) {
+                                assertEquals(ifp.toString() + "," + ifconf.toString(),
+                                        VNodeState.DOWN, vif.getState());
+                            } else {
+                                assertEquals(ifp.toString() + "," + ifconf.toString(),
+                                        VNodeState.UNKNOWN, vif.getState());
+                            }
+
+                            VBridge brdg = null;
+                            try {
+                                brdg = mgr.getBridge(bpath);
+                            } catch (VTNException e) {
+                               unexpected(e);
+                            }
+                            assertEquals(ifp.toString() + "," + ifconf.toString(),
+                                    VNodeState.UNKNOWN, brdg.getState());
+
+                            st = mgr.removeBridgeInterface(ifp);
+                            assertTrue(ifp.toString() + "," + ifconf.toString(), st.isSuccess());
+                        }
+                    }
+
+                    // for modify(false)
+                    st = mgr.addBridgeInterface(ifp, new VInterfaceConfig("desc", Boolean.FALSE));
+                    assertTrue(st.isSuccess());
+
+                    String olddesc = new String("desc");
+                    Boolean oldenabled = Boolean.FALSE;
+                    for (String desc : descs) {
+                        for (Boolean enabled : createBooleans()) {
+                            VInterfaceConfig ifconf = new VInterfaceConfig(desc, enabled);
+                            st = mgr.modifyBridgeInterface(ifp, ifconf, false);
+                            assertTrue(ifp.toString() + "," + ifconf.toString(), st.isSuccess());
+
+                            VInterface vif = null;
+                            try {
+                                vif = mgr.getBridgeInterface(ifp);
+                            } catch (Exception e) {
+                                unexpected(e);
+                            }
+
+                            assertEquals(ifp.toString() + "," + ifconf.toString(),
+                                    ifname, vif.getName());
+
+                            if (desc == null) {
+                                assertEquals(ifp.toString() + "," + ifconf.toString(),
+                                        olddesc, vif.getDescription());
+                            } else {
+                                assertEquals(ifp.toString() + "," + ifconf.toString(),
+                                        desc, vif.getDescription());
+                            }
+
+                            Boolean currenabled = enabled;
+                            if (enabled == null) {
+                                assertEquals(ifp.toString() + "," + ifconf.toString(),
+                                        oldenabled, vif.getEnabled());
+                                currenabled = oldenabled;
+                            } else {
+                                assertEquals(ifp.toString() + "," + ifconf.toString(),
+                                        enabled, vif.getEnabled());
+                            }
+
+                            if (currenabled == Boolean.FALSE) {
+                                assertEquals(ifp.toString() + "," + ifconf.toString(),
+                                        VNodeState.DOWN, vif.getState());
+                            } else {
+                                assertEquals(ifp.toString() + "," + ifconf.toString(),
+                                        VNodeState.UNKNOWN, vif.getState());
+                            }
+                            VBridge brdg = null;
+                            try {
+                                brdg = mgr.getBridge(bpath);
+                            } catch (VTNException e) {
+                               unexpected(e);
+                            }
+                            assertEquals(ifp.toString() + "," + ifconf.toString(),
+                                    VNodeState.UNKNOWN, brdg.getState());
+
+                            olddesc = vif.getDescription();
+                            oldenabled = vif.getEnabled();
+                        }
+                    }
+
+                    // for modify(true)
+                    st = mgr.modifyBridgeInterface(ifp, new VInterfaceConfig("desc", Boolean.FALSE), true);
+                    assertTrue(ifp.toString(), st.isSuccess());
+                    for (String desc : descs) {
+                        for (Boolean enabled : createBooleans()) {
+                            VInterfaceConfig ifconf = new VInterfaceConfig(desc, enabled);
+                            st = mgr.modifyBridgeInterface(ifp, ifconf, true);
+                            assertTrue(ifp.toString() + "," + ifconf.toString(), st.isSuccess());
+
+                            VInterface vif = null;
+                            try {
+                                vif = mgr.getBridgeInterface(ifp);
+                            } catch (Exception e) {
+                                unexpected(e);
+                            }
+
+                            assertEquals(ifname, vif.getName());
+                            assertEquals(desc, vif.getDescription());
+                            if (enabled == null) {
+                                assertEquals(ifp.toString() + "," + ifconf.toString(),
+                                        Boolean.TRUE, vif.getEnabled());
+                            } else {
+                                assertEquals(ifp.toString() + "," + ifconf.toString(),
+                                        enabled, vif.getEnabled());
+                            }
+
+                            if (enabled == Boolean.FALSE) {
+                                assertEquals(ifp.toString() + "," + ifconf.toString(),
+                                        VNodeState.DOWN, vif.getState());
+                            } else {
+                                assertEquals(ifp.toString() + "," + ifconf.toString(),
+                                        VNodeState.UNKNOWN, vif.getState());
+                            }
+
+                            VBridge brdg = null;
+                            try {
+                                brdg = mgr.getBridge(bpath);
+                            } catch (VTNException e) {
+                               unexpected(e);
+                            }
+                            assertEquals(ifp.toString() + "," + ifconf.toString(),
+                                    VNodeState.UNKNOWN, brdg.getState());
+                        }
+                    }
+                }
+
+                list = null;
+                try {
+                    list = mgr.getBridgeInterfaces(bpath);
+                } catch (Exception e) {
+                    unexpected(e);
+                }
+                assertTrue((iflist.size() - 1) == list.size());
+            }
+
+            st = mgr.removeTenant(tpath);
+            assertTrue(tpath.toString(), st.isSuccess());
+        }
+
+        // TODO: NOTACCEPTABLE
+    }
+
+    /**
+     * Test method for invalid cases of
+     * {@link VTNManagerImpl#addBridgeInterface(VBridgeIfPath, VInterfaceConfig)},
+     * {@link VTNManagerImpl#modifyBridgeInterface(VBridgeIfPath, VInterfaceConfig, boolean)},
+     * {@link VTNManagerImpl#removeBridgeInterface(VBridgeIfPath)},
+     * {@link VTNManagerImpl#getBridgeInterfaces(VBridgePath)},
+     * {@link VTNManagerImpl#getBridgeInterface(VBridgeIfPath)}
+     */
+    @Test
+    public void testBridgeInterfaceInvalidCase() {
+        VTNManagerImpl mgr = vtnMgr;
+
+        String tname = "tenant";
+        VTenantPath tpath = new VTenantPath(tname);
+        Status st = mgr.addTenant(tpath, new VTenantConfig(null));
+        assertTrue(st.isSuccess());
+        String bname = "bridge";
+        VBridgePath bpath = new VBridgePath(tname, bname);
+        st = mgr.addBridge(bpath, new VBridgeConfig(null));
+        assertTrue(st.isSuccess());
+        String ifname = "interface";
+        VBridgeIfPath ifpath = new VBridgeIfPath(tname, bname, ifname);
+        VInterfaceConfig ifconf = new VInterfaceConfig("desc", Boolean.FALSE);
+
+        VBridgeIfPath[] ifplist = new VBridgeIfPath[] {
+                null, new VBridgeIfPath(tname, bname, null),
+                new VBridgeIfPath(tname, null, ifname),
+                new VBridgeIfPath(null, bname, ifname),
+                };
+        VInterfaceConfig[] ifclist = new VInterfaceConfig[] {null};
+
+        for (VBridgeIfPath path : ifplist) {
+            st = mgr.addBridgeInterface(path, ifconf);
+            assertEquals((path == null) ? "null" : path.toString(),
+                    StatusCode.BADREQUEST, st.getCode());
+        }
+
+        for (VInterfaceConfig conf : ifclist) {
+            st = mgr.addBridgeInterface(ifpath, conf);
+            assertEquals((conf == null) ? "null" : conf.toString(),
+                    StatusCode.BADREQUEST, st.getCode());
+        }
+
+        // addBridgeInterface() also return BADREQUEST in these case.
+        st = mgr.addBridgeInterface(new VBridgeIfPath(tname, bname, ""), ifconf);
+        assertEquals(StatusCode.BADREQUEST, st.getCode());
+        st = mgr.addBridgeInterface(new VBridgeIfPath(tname, bname, "123456789012345678901234567890_1"), ifconf);
+        assertEquals(StatusCode.BADREQUEST, st.getCode());
+
+        // add Interface before modify and remove()
+        st = mgr.addBridgeInterface(ifpath, ifconf);
+        assertTrue(st.isSuccess());
+
+        for (VBridgeIfPath path : ifplist) {
+            st = mgr.modifyBridgeInterface(path, ifconf, false);
+            assertEquals((path == null) ? "null" : path.toString(),
+                    StatusCode.BADREQUEST, st.getCode());
+            st = mgr.removeBridgeInterface(path);
+            assertEquals((path == null) ? "null" : path.toString(),
+                    StatusCode.BADREQUEST, st.getCode());
+
+            try {
+                mgr.getBridgeInterface(path);
+                fail("Throwing exception was expected.");
+            } catch (VTNException e) {
+                assertEquals((path == null) ? "null" : path.toString(),
+                        StatusCode.BADREQUEST, e.getStatus().getCode());
+            }
+        }
+
+        for (VInterfaceConfig conf : ifclist) {
+            st = mgr.modifyBridgeInterface(ifpath, conf, true);
+            assertEquals((conf == null) ? "null" : conf.toString(),
+                    StatusCode.BADREQUEST, st.getCode());
+        }
+
+        try {
+            mgr.getBridgeInterfaces(null);
+            fail("Throwing exception was expected.");
+        } catch (VTNException e) {
+            assertEquals(StatusCode.BADREQUEST, e.getStatus().getCode());
+        }
+
+        // conflict
+        st = mgr.addBridgeInterface(ifpath, ifconf);
+        assertEquals(StatusCode.CONFLICT, st.getCode());
+
+        // not found
+        VBridgeIfPath[] nbplist = new VBridgeIfPath[] {
+                new VBridgeIfPath(tname, bname, "i"),
+                new VBridgeIfPath(tname, "bbbbb", ifname),
+                new VBridgeIfPath("tt", bname, ifname)
+        };
+
+        for (VBridgeIfPath path: nbplist) {
+            st = mgr.removeBridgeInterface(path);
+            assertEquals((path == null) ? "null" : path.toString(),
+                    StatusCode.NOTFOUND, st.getCode());
+
+            st = mgr.modifyBridgeInterface(path, ifconf, false);
+            assertEquals((path == null) ? "null" : path.toString(),
+                    StatusCode.NOTFOUND, st.getCode());
+
+            if (!(path.getTenantName().equals(tname) &&
+                    path.getBridgeName().equals(bname))) {
+                st = mgr.addBridgeInterface(path, ifconf);
+                assertEquals((path == null) ? "null" : path.toString(),
+                        StatusCode.NOTFOUND, st.getCode());
+            }
+
+            try {
+                mgr.getBridgeInterface(path);
+                fail("Throwing exception was expected.");
+            } catch (VTNException e) {
+                assertEquals((path == null) ? "null" : path.toString(),
+                        StatusCode.NOTFOUND, e.getStatus().getCode());
+            }
+        }
+
+        st = mgr.removeTenant(tpath);
+        assertTrue(st.isSuccess());
+
+        st = mgr.removeBridgeInterface(ifpath);
+        assertEquals(StatusCode.NOTFOUND, st.getCode());
+
+        st = mgr.addBridgeInterface(ifpath, ifconf);
+        assertEquals(StatusCode.NOTFOUND, st.getCode());
+
+        try {
+            mgr.getBridgeInterface(ifpath);
+            fail("Throwing exception was expected.");
+        } catch (VTNException e) {
+            assertEquals(StatusCode.NOTFOUND, e.getStatus().getCode());
+        }
+
+        try {
+            mgr.getBridgeInterfaces(bpath);
+            fail("Throwing exception was expected.");
+        } catch (VTNException e) {
+            assertEquals(StatusCode.NOTFOUND, e.getStatus().getCode());
+        }
+
+        // TODO: NOTACCEPTABLE
+    }
+
+    /**
+     * Test method for
+     * {@link VTNManagerImpl#addVlanMap(VBridgePath, VlanMapConfig)},
+     * {@link VTNManagerImpl#removeVlanMap(VBridgePath, java.lang.String)},
+     * {@link VTNManagerImpl#getVlanMap(VBridgePath, java.lang.String)},
+     * {@link VTNManagerImpl#getVlanMaps(VBridgePath)}.
+     */
+    @Test
+    public void testVlanMap() {
+        VTNManagerImpl mgr = vtnMgr;
+        short[] vlans = new short[] { 0, 10, 4095 };
+        Status st = null;
+        String tname = "vtn";
+        VTenantPath tpath = new VTenantPath(tname);
+        String bname = "vbridge";
+        VBridgePath bpath = new VBridgePath(tname, bname);
+        String ifname = "vinterface";
+        VBridgeIfPath ifp = new VBridgeIfPath(tname, bname, ifname);
+        List<VBridgePath> bpathlist = new ArrayList<VBridgePath>();
+        List<VBridgeIfPath> ifplist = new ArrayList<VBridgeIfPath>();
+        bpathlist.add(bpath);
+        ifplist.add(ifp);
+
+        createTenantAndBridgeAndInterface(mgr, tpath, bpathlist, ifplist);
+
+        // add a vlanmap to a vbridge
+        for (Node node : createNodes(3)) {
+            for (short vlan : vlans) {
+                VlanMapConfig vlconf = new VlanMapConfig(node, vlan);
+                VlanMap map = null;
+                try {
+                    map = mgr.addVlanMap(bpath, vlconf);
+                    if (node != null && node.getType() != NodeConnector.NodeConnectorIDType.OPENFLOW) {
+                        fail("throwing Exception was expected." + vlconf.toString());
+                    }
+                } catch (VTNException e) {
+                    if (node != null && node.getType() == NodeConnector.NodeConnectorIDType.OPENFLOW) {
+                        unexpected(e);
+                    } else {
+                        continue;
+                    }
+                }
+
+                VlanMap getmap = null;
+                try {
+                    getmap = mgr.getVlanMap(bpath, map.getId());
+                } catch (VTNException e) {
+                    unexpected(e);
+                }
+                assertEquals(vlconf.toString(), getmap.getId(), map.getId());
+                assertEquals(vlconf.toString(), getmap.getNode(), node);
+                assertEquals(vlconf.toString(), getmap.getVlan(), vlan);
+
+                VBridge brdg = null;
+                try {
+                    brdg = mgr.getBridge(bpath);
+                } catch (VTNException e) {
+                   unexpected(e);
+                }
+                assertEquals((node == null) ? VNodeState.UP : VNodeState.DOWN, brdg.getState());
+
+                st = mgr.removeVlanMap(bpath, map.getId());
+                assertTrue(vlconf.toString(), st.isSuccess());
+            }
+        }
+
+        // add multi vlanmap to a vbridge
+        for (Node node : createNodes(3)) {
+            for (short vlan : vlans) {
+                VlanMapConfig vlconf = new VlanMapConfig(node, vlan);
+                VlanMap map = null;
+                try {
+                    map = mgr.addVlanMap(bpath, vlconf);
+                    if (node != null && node.getType() != NodeConnector.NodeConnectorIDType.OPENFLOW) {
+                        fail("throwing Exception was expected.");
+                    }
+                } catch (VTNException e) {
+                    if (node != null && node.getType() == NodeConnector.NodeConnectorIDType.OPENFLOW) {
+                        unexpected(e);
+                    } else {
+                        continue;
+                    }
+                } catch (Exception e) {
+                    unexpected(e);
+                }
+            }
+
+            List<VlanMap> list = null;
+            try {
+                list = mgr.getVlanMaps(bpath);
+            } catch (Exception e) {
+                unexpected(e);
+            }
+            if (node == null || node.getType() == NodeConnector.NodeConnectorIDType.OPENFLOW) {
+                assertTrue((node == null) ? "null" : node.toString(),
+                        list.size() == vlans.length);
+                VBridge brdg = null;
+                try {
+                    brdg = mgr.getBridge(bpath);
+                } catch (VTNException e) {
+                   unexpected(e);
+                }
+                if (node == null) {
+                    assertEquals(VNodeState.UP, brdg.getState());
+                } else {
+                    assertEquals(node.toString(), VNodeState.DOWN, brdg.getState());
+                }
+            } else {
+                assertTrue(node.toString(), list.size() == 0);
+                VBridge brdg = null;
+                try {
+                    brdg = mgr.getBridge(bpath);
+                } catch (VTNException e) {
+                   unexpected(e);
+                }
+                assertEquals(node.toString(), VNodeState.UNKNOWN, brdg.getState());
+            }
+
+            for (VlanMap map : list) {
+                st = mgr.removeVlanMap(bpath, map.getId());
+                assertTrue((node == null) ? "null" : node.toString() + "," + map.toString(),
+                        st.isSuccess());
+            }
+        }
+
+        st = mgr.removeTenant(tpath);
+        assertTrue(st.isSuccess());
+    }
+
+
+    /**
+     * Test method for invalid cases of
+     * {@link VTNManagerImpl#addVlanMap(VBridgePath, VlanMapConfig)},
+     * {@link VTNManagerImpl#removeVlanMap(VBridgePath, java.lang.String)},
+     * {@link VTNManagerImpl#getVlanMap(VBridgePath, java.lang.String)},
+     * {@link VTNManagerImpl#getVlanMaps(VBridgePath)}.
+     */
+    @Test
+    public void testVlanMapInvalidCase() {
+        VTNManagerImpl mgr = vtnMgr;
+        Status st = null;
+        String tname = "vtn";
+        VTenantPath tpath = new VTenantPath(tname);
+        String bname = "vbridge";
+        VBridgePath bpath = new VBridgePath(tname, bname);
+        String ifname = "vinterface";
+        VBridgeIfPath ifp = new VBridgeIfPath(tname, bname, ifname);
+
+        List<VBridgePath> bpathlist = new ArrayList<VBridgePath>();
+        List<VBridgeIfPath> ifplist = new ArrayList<VBridgeIfPath>();
+        bpathlist.add(bpath);
+        ifplist.add(ifp);
+        createTenantAndBridgeAndInterface(mgr, tpath, bpathlist, ifplist);
+
+        Node node = NodeCreator.createOFNode(0L);
+        Node node1 = NodeCreator.createOFNode(1L);
+        VlanMap map = null;
+
+        // conflict case
+        try {
+            map = mgr.addVlanMap(bpath, new VlanMapConfig(null, (short) 0));
+        } catch (Exception e) {
+            unexpected(e);
+        }
+
+        map = null;
+        try {
+            map = mgr.addVlanMap(bpath, new VlanMapConfig(null, (short) 0));
+            fail("Expected to throw Exception.");
+        } catch (VTNException e) {
+            assertEquals(StatusCode.CONFLICT, e.getStatus().getCode());
+        }
+
+        map = null;
+        try {
+            map = mgr.addVlanMap(bpath, new VlanMapConfig(node, (short) 0));
+            fail("Expected to throw Exception.");
+        } catch (VTNException e) {
+            assertEquals(StatusCode.CONFLICT, e.getStatus().getCode());
+        }
+
+        map = null;
+        try {
+            map = mgr.addVlanMap(bpath, new VlanMapConfig(node, (short) 1));
+        } catch (Exception e) {
+            unexpected(e);
+        }
+
+        // if mapped node is not exist, duplicate vlanmap success.
+        try {
+            map = mgr.addVlanMap(bpath, new VlanMapConfig(node1, (short) 1));
+        } catch (Exception e) {
+            unexpected(e);
+        }
+
+        map = null;
+        try {
+            map = mgr.addVlanMap(bpath, new VlanMapConfig(null, (short) 1));
+            fail("Expected to throw Exception.");
+        } catch (VTNException e) {
+            assertEquals(StatusCode.CONFLICT, e.getStatus().getCode());
+        }
+
+        // invalid case
+        VBridgeConfig bconf = new VBridgeConfig(null);
+        st = mgr.removeBridge(bpath);
+        assertTrue(st.isSuccess());
+        st = mgr.addBridge(bpath, bconf);
+        assertTrue(st.isSuccess());
+        node = NodeCreator.createOFNode(0L);
+
+        // bad request
+        VlanMapConfig vlconf = new VlanMapConfig(null, (short) 0);
+        VBridgePath[] bbplist = new VBridgePath[] {null,
+                new VBridgePath(tname, null), new VBridgePath((String) null, bname)};
+        VlanMapConfig[] bvclist = new VlanMapConfig[] {
+                null, new VlanMapConfig(node, (short) -1), new VlanMapConfig(node, (short) 4096)};
+
+        for (VBridgePath path: bbplist) {
+            try {
+                map = mgr.addVlanMap(path, vlconf);
+                fail("Throwing Exception was expected.");
+            } catch (VTNException e) {
+                assertEquals((path == null) ? "null" : path.toString(),
+                        StatusCode.BADREQUEST, e.getStatus().getCode());
+            }
+            try {
+                map = mgr.addVlanMap(path, new VlanMapConfig(null, (short) 0));
+                fail("Throwing Exception was expected.");
+            } catch (VTNException e) {
+                assertEquals((path == null) ? "null" : path.toString(),
+                        StatusCode.BADREQUEST, e.getStatus().getCode());
+            }
+        }
+
+        for (VlanMapConfig conf: bvclist) {
+            try {
+                map = mgr.addVlanMap(bpath, conf);
+                fail("Throwing Exception was expected." + conf.toString());
+            } catch (VTNException e) {
+                assertEquals((conf == null) ? "null" : conf.toString(),
+                        StatusCode.BADREQUEST, e.getStatus().getCode());
+            }
+        }
+
+        // add to execute getVlanMap() and removeVlanMap() test.
+        try {
+            map = mgr.addVlanMap(bpath, new VlanMapConfig(node, (short) 4095));
+        } catch (Exception e) {
+            unexpected(e);
+        }
+
+        try {
+            map = mgr.getVlanMap(bpath, null);
+            fail("Throwing Exception was expected.");
+        } catch (VTNException e) {
+            assertEquals(StatusCode.BADREQUEST, e.getStatus().getCode());
+        }
+
+        st = mgr.removeVlanMap(bpath, null);
+        assertEquals(StatusCode.BADREQUEST, st.getCode());
+
+        List<VlanMap> list = null;
+        for (VBridgePath path: bbplist) {
+            try {
+                map = mgr.getVlanMap(path, map.getId());
+                fail("Throwing Exception was expected.");
+            } catch (VTNException e) {
+                assertEquals((path == null) ? "null" : path.toString(),
+                        StatusCode.BADREQUEST, e.getStatus().getCode());
+            }
+
+            try {
+                list = mgr.getVlanMaps(path);
+                fail("Throwing Exception was expected.");
+            } catch (VTNException e) {
+                assertEquals((path == null) ? "null" : path.toString(),
+                        StatusCode.BADREQUEST, e.getStatus().getCode());
+            }
+
+            st = mgr.removeVlanMap(path, map.getId());
+            assertEquals((path == null) ? "null" : path.toString(),
+                    StatusCode.BADREQUEST, st.getCode());
+        }
+
+        // case Node == null is executed in {@link testVlanMap()}.
+
+        // not found
+        VBridgePath[] nbplist = new VBridgePath[] {
+                new VBridgePath(tname, "vbridg"), new VBridgePath("vtn0", bname)};
+
+        for (VBridgePath path: nbplist) {
+            try {
+                map = mgr.addVlanMap(path, new VlanMapConfig(node, (short) 0));
+                fail("Throwing Exception was expected.");
+            } catch (VTNException e) {
+                assertEquals((path == null) ? "null" : path.toString(),
+                        StatusCode.NOTFOUND, e.getStatus().getCode());
+            }
+
+            try {
+                map = mgr.getVlanMap(path, map.getId());
+                fail("Throwing Exception was expected.");
+            } catch (VTNException e) {
+                assertEquals((path == null) ? "null" : path.toString(),
+                        StatusCode.NOTFOUND, e.getStatus().getCode());
+            }
+
+            try {
+                list = mgr.getVlanMaps(path);
+                fail("Throwing Exception was expected.");
+            } catch (VTNException e) {
+                assertEquals((path == null) ? "null" : path.toString(),
+                        StatusCode.NOTFOUND, e.getStatus().getCode());
+            }
+
+            st = mgr.removeVlanMap(path, map.getId());
+            assertEquals((path == null) ? "null" : path.toString(),
+                    StatusCode.NOTFOUND, st.getCode());
+        }
+
+        st = mgr.removeVlanMap(bpath, map.getId());
+        assertEquals(StatusCode.SUCCESS, st.getCode());
+
+        st = mgr.removeVlanMap(bpath, map.getId());
+        assertEquals(StatusCode.NOTFOUND, st.getCode());
+
+        try {
+            map = mgr.getVlanMap(bpath, map.getId());
+            fail("Throwing Exception was expected.");
+        } catch (VTNException e) {
+            assertEquals(StatusCode.NOTFOUND, e.getStatus().getCode());
+        }
+
+        // TODO: NOTACCEPTABLE case
+
+        st = mgr.removeTenant(tpath);
+        assertTrue(st.isSuccess());
+    }
+
+    /**
+     * Test method for {@link VTNManagerImpl#getPortMap(VBridgeIfPath)} and
+     * {@link VTNManagerImpl#setPortMap(VBridgeIfPath, PortMapConfig)}.
+     */
+    @Test
+    public void testPortMap() {
+        VTNManagerImpl mgr = vtnMgr;
+        short[] vlans = new short[] { 0, 10, 4095 };
+        Status st = null;
+        String tname = "vtn";
+        VTenantPath tpath = new VTenantPath(tname);
+        String bname = "vbridge";
+        VBridgePath bpath = new VBridgePath(tname, bname);
+        String ifname = "vinterface";
+        VBridgeIfPath ifp = new VBridgeIfPath(tname, bname, ifname);
+        List<VBridgePath> bpathlist = new ArrayList<VBridgePath>();
+        List<VBridgeIfPath> ifplist = new ArrayList<VBridgeIfPath>();
+        bpathlist.add(bpath);
+        ifplist.add(ifp);
+
+        createTenantAndBridgeAndInterface(mgr, tpath, bpathlist, ifplist);
+
+        PortMap pmap = null;
+        try {
+            pmap = mgr.getPortMap(ifp);
+        } catch (Exception e) {
+            unexpected(e);
+        }
+        assertNull(pmap);
+
+        Node node = NodeCreator.createOFNode(0L);
+        SwitchPort[] ports = new SwitchPort[] {
+                new SwitchPort("port-10", NodeConnector.NodeConnectorIDType.OPENFLOW, "10"),
+                new SwitchPort(null, NodeConnector.NodeConnectorIDType.OPENFLOW, "11"),
+                new SwitchPort("port-10", null, null),
+                new SwitchPort("port-10"),
+                new SwitchPort(NodeConnector.NodeConnectorIDType.OPENFLOW, "13"),
+        };
+
+        for (SwitchPort port: ports) {
+            for (short vlan : vlans) {
+                PortMapConfig pmconf = new PortMapConfig(node, port, (short)vlan);
+                st = mgr.setPortMap(ifp, pmconf);
+                assertTrue(pmconf.toString(), st.isSuccess());
+
+                PortMap map = null;
+                try {
+                    map = mgr.getPortMap(ifp);
+                } catch (Exception e) {
+                    unexpected(e);
+                }
+                assertEquals(pmconf, map.getConfig());
+                assertNull(pmconf.toString(), map.getNodeConnector());
+
+                VInterface bif = null;
+                try {
+                    bif = mgr.getBridgeInterface(ifp);
+                } catch (VTNException e) {
+                    unexpected(e);
+                }
+                assertEquals(pmconf.toString(), VNodeState.DOWN, bif.getState());
+
+                VBridge brdg = null;
+                try {
+                    brdg = mgr.getBridge(bpath);
+                } catch (VTNException e) {
+                   unexpected(e);
+                }
+                assertEquals(pmconf.toString(), VNodeState.DOWN, brdg.getState());
+            }
+        }
+
+        st = mgr.setPortMap(ifp, null);
+        assertTrue(st.isSuccess());
+
+        PortMap map = null;
+        try {
+            map = mgr.getPortMap(ifp);
+        } catch (Exception e) {
+            unexpected(e);
+        }
+        assertNull(map);
+
+        st = mgr.removeTenant(tpath);
+        assertTrue(st.isSuccess());
+
+        // assign mutli portmaps to a vbridge
+        String bname1 = "vbridge1";
+        VBridgePath bpath1 = new VBridgePath(tname, bname1);
+        String bname2 = "vbridge2";
+        VBridgePath bpath2 = new VBridgePath(tname, bname2);
+        String ifname1 = "vinterface1";
+        VBridgeIfPath ifp1 = new VBridgeIfPath(tname, bname1, ifname1);
+        String ifname2 = "vinterface2";
+        VBridgeIfPath ifp2 = new VBridgeIfPath(tname, bname1, ifname2);
+        List<VBridgePath> mbpathlist = new ArrayList<VBridgePath>();
+        List<VBridgeIfPath> mifplist = new ArrayList<VBridgeIfPath>();
+        mbpathlist.add(bpath1);
+        mbpathlist.add(bpath2);
+        mifplist.add(ifp1);
+        mifplist.add(ifp2);
+
+        createTenantAndBridgeAndInterface(mgr, tpath, mbpathlist, mifplist);
+
+        Node node1 = NodeCreator.createOFNode(0L);
+        SwitchPort port1 = new SwitchPort(NodeConnector.NodeConnectorIDType.OPENFLOW, "10");
+        PortMapConfig pmconf1 = new PortMapConfig(node1, port1, (short) 0);
+        st = mgr.setPortMap(ifp1, pmconf1);
+        assertTrue(st.isSuccess());
+
+        SwitchPort port2 = new SwitchPort( NodeConnector.NodeConnectorIDType.OPENFLOW, "11");
+        PortMapConfig pmconf2 = new PortMapConfig(node1, port2, (short) 0);
+        st = mgr.setPortMap(ifp2, pmconf2);
+        assertTrue(st.isSuccess());
+
+        // if specified port is not exist, duplicate portmap success.
+        String ifname3 = "vinterface3";
+        VBridgeIfPath ifp3 = new VBridgeIfPath(tname, bname2, ifname3);
+        st = mgr.addBridgeInterface(ifp3, new VInterfaceConfig(null, true));
+        st = mgr.setPortMap(ifp3, pmconf1);
+        assertTrue(st.isSuccess());
+
+        st = mgr.removeTenant(tpath);
+        assertTrue(st.isSuccess());
+    }
+
+    /**
+     * Test method for invalid cases of
+     * {@link VTNManagerImpl#getPortMap(VBridgeIfPath)} and
+     * {@link VTNManagerImpl#setPortMap(VBridgeIfPath, PortMapConfig)}.
+     */
+    @Test
+    public void testPortMapInvalidCase() {
+        VTNManagerImpl mgr = vtnMgr;
+
+        String tname = "vtn";
+        VTenantPath tpath = new VTenantPath(tname);
+        String bname = "vbridge";
+        VBridgePath bpath = new VBridgePath(tname, bname);
+        String ifname = "vinterface";
+        VBridgeIfPath ifp = new VBridgeIfPath(tname, bname, ifname);
+        List<VBridgePath> bpathlist = new ArrayList<VBridgePath>();
+        List<VBridgeIfPath> ifplist = new ArrayList<VBridgeIfPath>();
+        bpathlist.add(bpath);
+        ifplist.add(ifp);
+
+        createTenantAndBridgeAndInterface(mgr, tpath, bpathlist, ifplist);
+
+
+        Node node = NodeCreator.createOFNode(0L);
+        SwitchPort port = new SwitchPort("port-1", NodeConnector.NodeConnectorIDType.OPENFLOW, "1");
+        PortMapConfig pmconf = new PortMapConfig(node, port, (short) 0);
+        Status st = mgr.setPortMap(ifp, pmconf);
+        assertTrue(st.isSuccess());
+
+        // bad request
+        VBridgeIfPath[] biflist = new VBridgeIfPath[] {
+                null, new VBridgeIfPath(tname, bname, null),
+                new VBridgeIfPath(tname, null, ifname),
+                new VBridgeIfPath(null, bname, ifname)};
+        SwitchPort[] badports = new SwitchPort[] {
+                new SwitchPort("port-2", NodeConnector.NodeConnectorIDType.OPENFLOW, null),
+                new SwitchPort(null, null, "16"),
+                new SwitchPort(NodeConnector.NodeConnectorIDType.ONEPK, "10"),
+        };
+        PortMapConfig[] bpmlist = new PortMapConfig[] {
+                new PortMapConfig(null, port, (short) 0),
+                new PortMapConfig(node, null, (short) 0),
+                new PortMapConfig(node, null, (short) 0),
+                new PortMapConfig(node, port, (short)-1)};
+
+        for (VBridgeIfPath path: biflist) {
+            st = mgr.setPortMap(path, pmconf);
+            assertEquals((path == null) ? "null" : path.toString(),
+                    StatusCode.BADREQUEST, st.getCode());
+
+            try {
+                mgr.getPortMap(path);
+                fail("throwing exception was expected.");
+            } catch (VTNException e) {
+                assertEquals((path == null) ? "null" : path.toString(),
+                        StatusCode.BADREQUEST, e.getStatus().getCode());
+            }
+        }
+
+        for (SwitchPort sw: badports) {
+            mgr.setPortMap(ifp, new PortMapConfig(node, sw, (short)0));
+            assertEquals(sw.toString(), StatusCode.BADREQUEST, st.getCode());
+        }
+
+        for (PortMapConfig map: bpmlist) {
+            st = mgr.setPortMap(ifp, map);
+            assertEquals(map.toString(), StatusCode.BADREQUEST, st.getCode());
+        }
+
+        Node pnode = null;
+        try {
+            pnode = new Node(Node.NodeIDType.PRODUCTION, "Node ID: 0");
+        } catch (ConstructionException e1) {
+            unexpected(e1);
+        }
+        st = mgr.setPortMap(ifp, new PortMapConfig(pnode, new SwitchPort("port-1"), (short) 0));
+        assertEquals(StatusCode.BADREQUEST, st.getCode());
+
+        // not found
+        VBridgeIfPath[] niflist = new VBridgeIfPath[] {
+                new VBridgeIfPath(tname, bname, "ii"),
+                new VBridgeIfPath(tname, "bbb", ifname),
+                new VBridgeIfPath("vv", bname, ifname)};
+
+        for (VBridgeIfPath path: niflist) {
+            st = mgr.setPortMap(path, pmconf);
+            assertEquals(StatusCode.NOTFOUND, st.getCode());
+            try {
+                mgr.getPortMap(path);
+                fail("throwing exception was expected.");
+            } catch (VTNException e) {
+                assertEquals(path.toString(), StatusCode.NOTFOUND, e.getStatus().getCode());
+            }
+        }
+
+        // TODO: NOTACCEPTABLE
+
+        st = mgr.removeTenant(tpath);
+        assertTrue(st.isSuccess());
+    }
+
+    /**
+     * Test method for
+     * {@link VTNManagerImpl#getMacEntries(VBridgePath)},
+     * {@link VTNManagerImpl#getMacEntries(VBridgePath)},
+     * {@link VTNManagerImpl#getMacEntry(VBridgePath, DataLinkAddress)},
+     * {@link VTNManagerImpl#removeMacEntry(VBridgePath, DataLinkAddress)},
+     * {@link VTNManagerImpl#flushMacEntries(VBridgePath)}
+     */
+    @Test
+    public void testMacEntry() {
+        VTNManagerImpl mgr = vtnMgr;
+        short[] vlans = new short[] { 0, 10, 4095 };
+        String tname = "vtn";
+        VTenantPath tpath = new VTenantPath(tname);
+        String bname = "vbridge";
+        VBridgePath bpath = new VBridgePath(tname, bname);
+        String bname2 = "vbridge2";
+        VBridgePath bpath2 = new VBridgePath(tname, bname2);
+        List<VBridgePath> bpathlist = new ArrayList<VBridgePath>();
+        bpathlist.add(bpath);
+        bpathlist.add(bpath2);
+
+        createTenantAndBridge(mgr, tpath, bpathlist);
+
+        MacAddressTable tbl = mgr.getMacAddressTable(bpath);
+        MacAddressTable tbl2 = mgr.getMacAddressTable(bpath2);
+
+        List<EthernetAddress> ethers = createEthernetAddresses(false);
+        List<NodeConnector> connectors = createNodeConnectors(3, false);
+        NodeConnector nc = connectors.get(0);
+        byte iphost = 1;
+        short vlan = -1;
+        short vlan2 = 4095;
+
+        for (EthernetAddress ea: ethers) {
+            byte[] bytes = ea.getValue();
+            byte[] src = new byte[] {bytes[0], bytes[1], bytes[2], bytes[3], bytes[4], bytes[5]};
+            byte[] dst = new byte[] {(byte)0xFF, (byte)0xFF, (byte)0xFF, (byte)0xFF, (byte)0xFF, (byte)0xFF};
+            byte[] sender = new byte[] {(byte)192, (byte)168, (byte)0, (byte)iphost};
+            byte[] target = new byte[] {(byte)192, (byte)168, (byte)0, (byte)250};
+            byte[] src2 = new byte[] {00, bytes[4], bytes[3], bytes[2], bytes[1], bytes[0]};
+            byte[] dst2 = new byte[] {(byte)0xFF, (byte)0xFF, (byte)0xFF, (byte)0xFF, (byte)0xFF, (byte)0xFF};
+            byte[] sender2 = new byte[] {(byte)192, (byte)1, (byte)0, (byte)iphost};
+            byte[] target2 = new byte[] {(byte)192, (byte)1, (byte)0, (byte)250};
+            EthernetAddress ea2 = null;
+            try {
+                 ea2 = new EthernetAddress(src2);
+            } catch (ConstructionException e1) {
+                unexpected(e1);
+            }
+
+            PacketContext pctx = createARPPacketContext(src, dst, sender, target, vlan, connectors.get(0), ARP.REQUEST);
+            PacketContext pctx2 = createARPPacketContext(src2, dst2, sender2, target2, vlan2, connectors.get(0), ARP.REQUEST);
+
+            tbl.add(mgr, pctx);
+            tbl2.add(mgr, pctx2);
+
+            MacAddressEntry entry = null;
+            try {
+                entry = mgr.getMacEntry(bpath, ea);
+            } catch (VTNException e) {
+                unexpected(e);
+            }
+            assertEquals(ea.toString(), ea, entry.getAddress());
+            assertEquals(ea.toString(), ((vlan < 0) ? (short)0 : vlan), entry.getVlan());
+            assertEquals(ea.toString(), nc, entry.getNodeConnector());
+
+            Set<InetAddress> ips = entry.getInetAddresses();
+            assertArrayEquals(ea.toString(), sender, ips.iterator().next().getAddress());
+
+            try {
+                entry = mgr.getMacEntry(bpath, ea2);
+            } catch (VTNException e) {
+                unexpected(e);
+            }
+            assertNull(ea.toString(), entry);
+
+            try {
+                entry = mgr.getMacEntry(bpath2, ea2);
+            } catch (VTNException e) {
+                unexpected(e);
+            }
+            assertEquals(ea.toString(), ea2, entry.getAddress());
+            assertEquals(ea.toString(), ((vlan2 < 0) ? (short)0 : vlan2), entry.getVlan());
+            assertEquals(ea.toString(), nc, entry.getNodeConnector());
+
+            ips = entry.getInetAddresses();
+            assertArrayEquals(ea.toString(), sender2, ips.iterator().next().getAddress());
+
+            try {
+                mgr.removeMacEntry(bpath, ea);
+            } catch (VTNException e) {
+                unexpected(e);
+            }
+
+            iphost++;
+        }
+
+        // test flush
+        for (EthernetAddress ea: ethers) {
+            byte[] bytes = ea.getValue();
+            byte[] src = new byte[] {bytes[0], bytes[1], bytes[2], bytes[3], bytes[4], bytes[5]};
+            byte[] dst = new byte[] {(byte)0xFF, (byte)0xFF, (byte)0xFF, (byte)0xFF, (byte)0xFF, (byte)0xFF};
+            byte[] sender = new byte[] {(byte)192, (byte)168, (byte)0, (byte)iphost};
+            byte[] target = new byte[] {(byte)192, (byte)168, (byte)0, (byte)250};
+
+            PacketContext pctx = createARPPacketContext(src, dst, sender, target, (short)-1, connectors.get(0), ARP.REQUEST);
+
+            tbl.add(mgr, pctx);
+        }
+
+        List<MacAddressEntry> list = null;
+        try {
+            list = mgr.getMacEntries(bpath);
+        } catch (VTNException e) {
+            unexpected(e);
+        }
+        assertNotNull(list);
+        assertTrue(list.size() == ethers.size());
+
+        Status st = mgr.flushMacEntries(bpath);
+        assertEquals(StatusCode.SUCCESS, st.getCode());
+
+        try {
+            list = mgr.getMacEntries(bpath);
+        } catch (VTNException e) {
+            unexpected(e);
+        }
+        assertNotNull(list);
+        assertTrue(list.size() == 0);
+
+        try {
+            list = mgr.getMacEntries(bpath2);
+        } catch (VTNException e) {
+            unexpected(e);
+        }
+        assertNotNull(list);
+        assertTrue(list.size() == ethers.size());
+
+        st = mgr.flushMacEntries(bpath2);
+        assertEquals(StatusCode.SUCCESS, st.getCode());
+
+        try {
+            list = mgr.getMacEntries(bpath2);
+        } catch (VTNException e) {
+            unexpected(e);
+        }
+        assertNotNull(list);
+        assertTrue(list.size() == 0);
+
+        st = mgr.removeTenant(tpath);
+        assertTrue(st.isSuccess());
+    }
+
+    /**
+     * Test method for invalid cases of
+     * {@link VTNManagerImpl#getMacEntries(VBridgePath)},
+     * {@link VTNManagerImpl#getMacEntries(VBridgePath)},
+     * {@link VTNManagerImpl#getMacEntry(VBridgePath, DataLinkAddress)},
+     * {@link VTNManagerImpl#removeMacEntry(VBridgePath, DataLinkAddress)},
+     * {@link VTNManagerImpl#flushMacEntries(VBridgePath)}
+     */
+    @Test
+    public void testMacEntryInvalidCase() {
+        VTNManagerImpl mgr = vtnMgr;
+        short[] vlans = new short[] { 0, 10, 4095 };
+        String tname = "vtn";
+        VTenantPath tpath = new VTenantPath(tname);
+        String bname = "vbridge";
+        VBridgePath bpath = new VBridgePath(tname, bname);
+        Status st = null;
+        List<VBridgePath> bpathlist = new ArrayList<VBridgePath>();
+        bpathlist.add(bpath);
+
+        createTenantAndBridge(mgr, tpath, bpathlist);
+
+        MacAddressTable tbl = mgr.getMacAddressTable(bpath);
+
+        List<NodeConnector> connectors = createNodeConnectors(1, false);
+        NodeConnector nc = connectors.get(0);
+        short vlan = -1;
+
+        byte[] src = new byte[] {(byte)0x00, (byte)0x00, (byte)0x00, (byte)0x00, (byte)0x00, (byte)0x01};
+        byte[] dst = new byte[] {(byte)0xFF, (byte)0xFF, (byte)0xFF, (byte)0xFF, (byte)0xFF, (byte)0xFF};
+        byte[] sender = new byte[] {(byte)192, (byte)168, (byte)0, (byte)1};
+        byte[] target = new byte[] {(byte)192, (byte)168, (byte)0, (byte)250};
+
+        PacketContext pctx = createARPPacketContext(src, dst, sender, target, vlan, nc, ARP.REQUEST);
+        EthernetAddress ea = null;
+        try {
+            ea = new EthernetAddress(src);
+        } catch (ConstructionException e) {
+            unexpected(e);
+        }
+
+        tbl.add(mgr, pctx);
+
+        VBridgePath[] badplist = new VBridgePath[] {null,
+                new VBridgePath(tname, null),
+                new VBridgePath((String)null, bname)};
+        EthernetAddress[] badelist = new EthernetAddress[] {null};
+
+        // bad request
+        for (VBridgePath path: badplist) {
+            try {
+                mgr.getMacEntry(path, ea);
+                fail("Throwing exception was expected.");
+            } catch (VTNException e) {
+                assertEquals((path == null) ? "null" : path.toString(),
+                        StatusCode.BADREQUEST, e.getStatus().getCode());
+            }
+
+            try {
+                mgr.getMacEntries(path);
+                fail("Throwing exception was expected.");
+            } catch (VTNException e) {
+                assertEquals((path == null) ? "null" : path.toString(),
+                        StatusCode.BADREQUEST, e.getStatus().getCode());
+            }
+
+            try {
+                mgr.removeMacEntry(path, ea);
+                fail("Throwing exception was expected.");
+            } catch (VTNException e) {
+                assertEquals((path == null) ? "null" : path.toString(),
+                        StatusCode.BADREQUEST, e.getStatus().getCode());
+            }
+
+            st = mgr.flushMacEntries(path);
+            assertEquals((path == null) ? "null" : path.toString(),
+                    StatusCode.BADREQUEST, st.getCode());
+        }
+
+        for (EthernetAddress eth: badelist) {
+            try {
+                mgr.getMacEntry(bpath, eth);
+                fail("Throwing exception was expected.");
+            } catch (VTNException e) {
+                assertEquals(StatusCode.BADREQUEST, e.getStatus().getCode());
+            }
+        }
+
+        // not found
+        VBridgePath[] nfplist = new VBridgePath[] {
+                new VBridgePath("vvvvvv", bname),
+                new VBridgePath(tname, "bbbbbb")};
+        EthernetAddress[] nfelist = new EthernetAddress[] {null};
+
+        // bad request
+        for (VBridgePath path: nfplist) {
+            try {
+                mgr.getMacEntry(path, ea);
+                fail("Throwing exception was expected.");
+            } catch (VTNException e) {
+                assertEquals((path == null) ? "null" : path.toString(),
+                        StatusCode.NOTFOUND, e.getStatus().getCode());
+            }
+
+            try {
+                mgr.getMacEntries(path);
+                fail("Throwing exception was expected.");
+            } catch (VTNException e) {
+                assertEquals((path == null) ? "null" : path.toString(),
+                        StatusCode.NOTFOUND, e.getStatus().getCode());
+            }
+
+            try {
+                mgr.removeMacEntry(path, ea);
+                fail("Throwing exception was expected.");
+            } catch (VTNException e) {
+                assertEquals((path == null) ? "null" : path.toString(),
+                        StatusCode.NOTFOUND, e.getStatus().getCode());
+            }
+
+            st = mgr.flushMacEntries(path);
+            assertEquals((path == null) ? "null" : path.toString(),
+                    StatusCode.NOTFOUND, st.getCode());
+        }
+
+        st = mgr.removeTenant(tpath);
+        assertTrue(st.isSuccess());
+    }
+
+    /**
+     * Test method for {@link VTNManagerImpl#readObject(ObjectInputStream))}
+     */
+    @Test
+    public void testReadObject() {
+        Object o = new VTenantPath("tenant");
+        byte[] bytes = null;
+        try {
+            ByteArrayOutputStream bout = new ByteArrayOutputStream();
+            ObjectOutputStream out = new ObjectOutputStream(bout);
+
+            out.writeObject(o);
+            out.close();
+            bytes = bout.toByteArray();
+        } catch (Exception e) {
+            unexpected(e);
+        }
+        assertTrue(bytes.length != 0);
+
+        // Deserialize the object.
+        Object newobj = null;
+        try {
+            ByteArrayInputStream bin = new ByteArrayInputStream(bytes);
+            ObjectInputStream in = new ObjectInputStream(bin);
+            newobj = vtnMgr.readObject(in);
+            in.close();
+        } catch (Exception e) {
+            unexpected(e);
+        }
+
+        assertNotSame(o, newobj);
+        assertEquals(o, newobj);
+    }
+
+    /**
+     * Test method for
+     * {@link VTNManagerImpl#entrCreated},
+     * {@link VTNManagerImpl#entryUpdated},
+     * {@link VTNManagerImpl#entryDeleted}
+     */
+    @Test
+    public void testCacheEntryChange() {
+        VTNManagerImpl mgr = vtnMgr;
+        String root = GlobalConstants.STARTUPHOME.toString();
+        String tenantListFileName = root + "vtn-names.conf";
+        String configFileName = root + "vtn-" + "default" + "-" + "tenant100" + ".conf";
+        String configFileNameUp = root + "vtn-" + "default" + "-" + "tenant" + ".conf";
+
+        // create
+        File tenantList = new File(tenantListFileName);
+        tenantList.delete();
+
+        mgr.entryCreated("tenant100", "vtn.tenant" , true);
+        tenantList = new File(tenantListFileName);
+        assertFalse(tenantList.exists());
+
+        mgr.entryCreated("tenant100", "vtn.tenant" , false);
+        tenantList = new File(tenantListFileName);
+        assertTrue(tenantList.exists());
+
+
+        // update
+        VTenantPath tpath = new VTenantPath("tenant");
+        mgr.addTenant(tpath, new VTenantConfig(null));
+        tenantList = new File(tenantListFileName);
+        tenantList.delete();
+        File configFile = new File(configFileNameUp);
+        configFile.delete();
+
+        mgr.entryUpdated("tenant", Long.valueOf(1L), "vtn.tenant", true);
+        checkFileExists(configFileNameUp, false, false);
+        checkFileExists(tenantListFileName, false, false);
+
+        mgr.entryUpdated("<all>", Long.valueOf(1L), "vtn.tenant", false);
+        checkFileExists(configFileNameUp, true, true);
+        checkFileExists(tenantListFileName, true, true);
+
+        mgr.entryUpdated("tenant", Long.valueOf(1L), "vtn.tenant", false);
+        checkFileExists(configFileNameUp, true, true);
+        checkFileExists(tenantListFileName, false, true);
+
+        mgr.removeTenant(tpath);
+
+        // delete
+        tenantList = new File(tenantListFileName);
+        tenantList.delete();
+        configFile = new File(configFileName);
+        try {
+            configFile.createNewFile();
+        } catch (IOException e) {
+            unexpected(e);
+        }
+
+        mgr.entryDeleted("tenant100", "vtn.tenant" , true);
+        checkFileExists(configFileName, true, false);
+        checkFileExists(tenantListFileName, false, true);
+
+        mgr.entryDeleted("<all>", "vtn.tenant" , false);
+        checkFileExists(configFileName, true, false);
+        checkFileExists(tenantListFileName, true, true);
+
+        mgr.entryDeleted("tenant100", "vtn.tenant" , false);
+        checkFileExists(configFileName, false, true);
+        checkFileExists(tenantListFileName, true, true);
+
+    }
+
+    private void checkFileExists(String fileName, boolean result, boolean remove) {
+        File file = new File(fileName);
+        assertEquals(result, file.exists());
+        if (remove && file.exists()) {
+            file.delete();
+        } else {
+            try {
+                file.createNewFile();
+            } catch (IOException e) {
+               unexpected(e);
+            }
+        }
+    };
+
+
+    /**
+     * Test method for
+     * {@link VTNManagerImpl#saveConfiguration()}
+     */
+    @Test
+    public void testSaveConfiguration() {
+        VTNManagerImpl mgr = vtnMgr;
+        String tname = "vtn";
+        VTenantPath tpath = new VTenantPath(tname);
+        Status st = mgr.addTenant(tpath, new VTenantConfig(null));
+        assertTrue(st.isSuccess());
+        assertTrue(mgr.isActive());
+
+        st = mgr.saveConfiguration();
+        assertTrue(st.isSuccess());
+
+        mgr.removeTenant(tpath);
+        assertTrue(st.isSuccess());
+
+        st = mgr.saveConfiguration();
+        assertTrue(st.isSuccess());
+    }
+
+    /**
+     * Test method for
+     * {@link VTNManagerImpl#receiveDataPacket(RawPacket)}
+     */
+    @Test
+    public void testReceiveDataPacket() {
+        VTNManagerImpl mgr = vtnMgr;
+        short[] vlans = new short[] { 0, 10, 4095 };
+        ISwitchManager swmgr = mgr.getSwitchManager();
+        byte[] cntMac = swmgr.getControllerMAC();
+
+        String tname = "vtn";
+        VTenantPath tpath = new VTenantPath(tname);
+        Status st = mgr.addTenant(tpath, new VTenantConfig(null));
+        assertTrue(st.isSuccess());
+        assertTrue(mgr.isActive());
+
+        PacketResult result = mgr.receiveDataPacket(null);
+        assertEquals(PacketResult.IGNORED, result);
+
+        List<NodeConnector> connectors = createNodeConnectors(4);
+        for (NodeConnector nc: connectors) {
+            byte iphost = 1;
+            for (EthernetAddress ea: createEthernetAddresses(false)) {
+                byte [] bytes = ea.getValue();
+                byte [] src = new byte[] {bytes[0], bytes[1], bytes[2],
+                                        bytes[3], bytes[4], bytes[5]};
+                byte [] dst = new byte[] {(byte)0xff, (byte)0xff, (byte)0xff,
+                                        (byte)0xff, (byte)0xff, (byte)0xff};
+                byte [] sender = new byte[] {(byte)192, (byte)168, (byte)0, (byte)iphost};
+                byte [] target = new byte[] {(byte)192, (byte)168, (byte)0, (byte)250};
+                short vlan = 0;
+                RawPacket inPkt = createARPRawPacket(src, dst, sender, target, vlan, nc, ARP.REQUEST);
+                result = mgr.receiveDataPacket(inPkt);
+
+                // because there are no topology, in this case always ignored.
+                assertEquals(PacketResult.IGNORED, result);
+            }
+
+            // packet from controller.
+            byte [] src = new byte[] {cntMac[0], cntMac[1], cntMac[2],
+                                    cntMac[3], cntMac[4], cntMac[5]};
+            byte [] dst = new byte[] {(byte)0xff, (byte)0xff, (byte)0xff,
+                                    (byte)0xff, (byte)0xff, (byte)0xff};
+            byte [] sender = new byte[] {(byte)192, (byte)168, (byte)0, (byte)1};
+            byte [] target = new byte[] {(byte)192, (byte)168, (byte)0, (byte)250};
+            short vlan = 0;
+
+            RawPacket inPkt = createARPRawPacket(src, dst, sender, target, vlan, nc, ARP.REQUEST);
+            result = mgr.receiveDataPacket(inPkt);
+
+            assertEquals(PacketResult.IGNORED, result);
+        }
+
+        st = mgr.removeTenant(tpath);
+        assertTrue(st.isSuccess());
+    }
+
+
+    // private method
+    protected void sleep(long millis) {
+        Thread.yield();
+        try {
+            Thread.sleep(millis);
+        } catch (InterruptedException e) {
+            unexpected(e);
+        }
+    }
+
+}
diff --git manager/implementation/src/test/java/org/opendaylight/vtn/manager/internal/VTNManagerImplTestCommon.java manager/implementation/src/test/java/org/opendaylight/vtn/manager/internal/VTNManagerImplTestCommon.java
new file mode 100644
index 0000000..d1d2ff1
--- /dev/null
+++ manager/implementation/src/test/java/org/opendaylight/vtn/manager/internal/VTNManagerImplTestCommon.java
@@ -0,0 +1,226 @@
+/*
+ * Copyright (c) 2013 NEC Corporation
+ * All rights reserved.
+ *
+ * This program and the accompanying materials are made available under the
+ * terms of the Eclipse Public License v1.0 which accompanies this
+ * distribution, and is available at http://www.eclipse.org/legal/epl-v10.html
+ */
+package org.opendaylight.vtn.manager.internal;
+
+import static org.junit.Assert.*;
+
+import java.io.File;
+import java.util.Hashtable;
+import java.util.List;
+
+
+import org.apache.felix.dm.impl.ComponentImpl;
+import org.junit.After;
+import org.junit.Before;
+
+
+import org.opendaylight.controller.sal.packet.ARP;
+import org.opendaylight.controller.sal.packet.Ethernet;
+import org.opendaylight.controller.sal.packet.IEEE8021Q;
+import org.opendaylight.controller.sal.utils.EtherTypes;
+import org.opendaylight.controller.sal.utils.GlobalConstants;
+import org.opendaylight.controller.sal.utils.Status;
+import org.opendaylight.vtn.manager.IVTNManager;
+import org.opendaylight.vtn.manager.VBridgeConfig;
+import org.opendaylight.vtn.manager.VBridgeIfPath;
+import org.opendaylight.vtn.manager.VBridgePath;
+import org.opendaylight.vtn.manager.VInterfaceConfig;
+import org.opendaylight.vtn.manager.VTenantConfig;
+import org.opendaylight.vtn.manager.VTenantPath;
+
+/**
+ * Common class for {@link VTNManagerImplTest} and {@link VTNManagerImplWithNodesTest}.
+ *
+ */
+public class VTNManagerImplTestCommon extends TestBase {
+    protected VTNManagerImpl vtnMgr = null;
+    protected TestStub stubObj = null;
+    protected static int stubMode = 0;
+
+    @Before
+    public void before() {
+        File confdir = new File(GlobalConstants.STARTUPHOME.toString());
+        boolean result = confdir.exists();
+        if (!result) {
+            result = confdir.mkdirs();
+        } else {
+            File[] list = confdir.listFiles();
+            for (File f : list) {
+                f.delete();
+            }
+        }
+
+        vtnMgr = new VTNManagerImpl();
+        ComponentImpl c = new ComponentImpl(null, null, null);
+        GlobalResourceManager grsc = new GlobalResourceManager();
+        stubObj = new TestStub(stubMode);
+
+        Hashtable<String, String> properties = new Hashtable<String, String>();
+        properties.put("containerName", "default");
+        c.setServiceProperties(properties);
+
+        grsc.setClusterGlobalService(stubObj);
+        grsc.init(c);
+        vtnMgr.setResourceManager(grsc);
+        vtnMgr.setClusterContainerService(stubObj);
+        vtnMgr.setSwitchManager(stubObj);
+        vtnMgr.setTopologyManager(stubObj);
+        vtnMgr.setDataPacketService(stubObj);
+        vtnMgr.setRouting(stubObj);
+        vtnMgr.setHostTracker(stubObj);
+        vtnMgr.init(c);
+    }
+
+    @After
+    public void after() {
+
+        vtnMgr.destroy();
+
+        String currdir = new File(".").getAbsoluteFile().getParent();
+        File confdir = new File(GlobalConstants.STARTUPHOME.toString());
+
+        if (confdir.exists()) {
+            File[] list = confdir.listFiles();
+            for (File f : list) {
+                f.delete();
+            }
+
+            while (confdir != null && confdir.getAbsolutePath() != currdir) {
+                confdir.delete();
+                String pname = confdir.getParent();
+                if (pname == null) {
+                    break;
+                }
+                confdir = new File(pname);
+            }
+        }
+    }
+
+
+    /**
+     * method for setup enviroment.
+     * create 1 Tenant and bridges
+     */
+    protected void createTenantAndBridge(IVTNManager mgr, VTenantPath tpath,
+            List<VBridgePath> bpaths) {
+
+        Status st = mgr.addTenant(tpath, new VTenantConfig(null));
+        assertTrue(st.isSuccess());
+        assertTrue(mgr.isActive());
+
+        for (VBridgePath bpath : bpaths) {
+            st = mgr.addBridge(bpath, new VBridgeConfig(null));
+            assertTrue(st.isSuccess());
+        }
+    }
+
+    /**
+     * method for setup enviroment.
+     * create 1 Tenant and bridges and vinterfaces
+     */
+    protected void createTenantAndBridgeAndInterface(IVTNManager mgr, VTenantPath tpath,
+            List<VBridgePath> bpaths, List<VBridgeIfPath> ifpaths) {
+
+        Status st = mgr.addTenant(tpath, new VTenantConfig(null));
+        assertTrue(st.isSuccess());
+        assertTrue(mgr.isActive());
+
+        for (VBridgePath bpath : bpaths) {
+            st = mgr.addBridge(bpath, new VBridgeConfig(null));
+            assertTrue(st.isSuccess());
+        }
+
+        for (VBridgeIfPath ifpath : ifpaths) {
+            VInterfaceConfig ifconf = new VInterfaceConfig(null, null);
+            st = mgr.addBridgeInterface(ifpath, ifconf);
+            assertTrue(st.isSuccess());
+        }
+    }
+
+    /**
+     * check a Ethernet packet whether setted expected parametor in the packet.
+     * (for IPv4 packet)
+     *
+     * @param msg   if check is failed, report error with a message specified this.
+     * @param eth   input ethernet frame data.
+     * @param ethType   expected ethernet type.
+     * @param destMac   expected destination mac address.
+     * @param srcMac    expected source mac address.
+     * @param vlan  expected vlan id. (if expected untagged, specify 0 or less than 0)
+     */
+    protected void checkOutEthernetPacketIPv4 (String msg, Ethernet eth, EtherTypes ethType,
+            byte[] srcMac, byte[] destMac,  short vlan) {
+
+        checkOutEthernetPacket(msg, eth, ethType, srcMac, destMac, vlan, null, (short)-1,
+                null, null, null, null);
+    }
+
+    /**
+     * check a Ethernet packet whether setted expected parametor in the packet.
+     *
+     * @param msg   if check is failed, report error with a message specified this.
+     * @param eth   input ethernet frame data.
+     * @param ethType   expected ethernet type.
+     * @param destMac   expected destination mac address.
+     * @param srcMac    expected source mac address.
+     * @param vlan  expected vlan id. (if expected untagged, specify 0 or less than 0)
+     * @param protoType expected protocol type.
+     * @param opCode    expected opCode. if thish is not ARP, opCode is not checked.
+     * @param senderMac expected sender HW address.
+     * @param targetMac expected target HW address.
+     * @param senderAddr    expected sender protocol address.
+     * @param targetAddr    expected target protocol address.
+     *
+     */
+    protected void checkOutEthernetPacket (String msg, Ethernet eth, EtherTypes ethType,
+            byte[] srcMac, byte[] destMac,  short vlan, EtherTypes protoType, short opCode,
+            byte[] senderMac, byte[] targetMac, byte[] senderAddr, byte [] targetAddr) {
+
+        ARP arp = null;
+        if (vlan > 0) {
+            assertEquals(msg, EtherTypes.VLANTAGGED.shortValue(), eth.getEtherType());
+            IEEE8021Q vlantag = (IEEE8021Q)eth.getPayload();
+            assertEquals(msg, vlan, vlantag.getVid());
+            assertEquals(msg, ethType.shortValue(), vlantag.getEtherType());
+            if (ethType.shortValue() == EtherTypes.ARP.shortValue()) {
+                arp = (ARP)vlantag.getPayload();
+            }
+        } else {
+            assertEquals(msg, ethType.shortValue(), eth.getEtherType());
+            if (ethType.shortValue() == EtherTypes.ARP.shortValue()) {
+                arp = (ARP)eth.getPayload();
+            }
+        }
+
+        if (srcMac != null) {
+            assertArrayEquals(msg, srcMac, eth.getSourceMACAddress());
+        }
+        if (destMac != null) {
+            assertArrayEquals(msg, destMac, eth.getDestinationMACAddress());
+        }
+
+        if (ethType.shortValue() == EtherTypes.ARP.shortValue()) {
+            assertEquals(msg, protoType.shortValue(), arp.getProtocolType());
+            assertEquals(msg, opCode, arp.getOpCode());
+            if (senderMac != null) {
+                assertArrayEquals(msg, senderMac, arp.getSenderHardwareAddress());
+            }
+            if (targetMac != null) {
+                assertArrayEquals(msg, targetMac, arp.getTargetHardwareAddress());
+            }
+            if (senderAddr != null) {
+                assertArrayEquals(msg, senderAddr, arp.getSenderProtocolAddress());
+            }
+            if (targetAddr != null) {
+                assertArrayEquals(msg, targetAddr, arp.getTargetProtocolAddress());
+            }
+        }
+    }
+
+}
diff --git manager/implementation/src/test/java/org/opendaylight/vtn/manager/internal/VTNManagerImplWithNodesTest.java manager/implementation/src/test/java/org/opendaylight/vtn/manager/internal/VTNManagerImplWithNodesTest.java
new file mode 100644
index 0000000..bcf9814
--- /dev/null
+++ manager/implementation/src/test/java/org/opendaylight/vtn/manager/internal/VTNManagerImplWithNodesTest.java
@@ -0,0 +1,1464 @@
+/*
+ * Copyright (c) 2013 NEC Corporation
+ * All rights reserved.
+ *
+ * This program and the accompanying materials are made available under the
+ * terms of the Eclipse Public License v1.0 which accompanies this
+ * distribution, and is available at http://www.eclipse.org/legal/epl-v10.html
+ */
+package org.opendaylight.vtn.manager.internal;
+
+
+import java.net.InetAddress;
+import java.net.UnknownHostException;
+import java.util.ArrayList;
+import java.util.HashSet;
+import java.util.List;
+import java.util.Map;
+import java.util.Set;
+import java.util.concurrent.ConcurrentHashMap;
+import java.util.concurrent.ConcurrentMap;
+
+import org.junit.BeforeClass;
+import org.junit.Test;
+
+import org.opendaylight.controller.hosttracker.hostAware.HostNodeConnector;
+import org.opendaylight.controller.sal.core.ConstructionException;
+import org.opendaylight.controller.sal.core.Node;
+import org.opendaylight.controller.sal.core.NodeConnector;
+import org.opendaylight.controller.sal.core.Property;
+import org.opendaylight.controller.sal.core.UpdateType;
+import org.opendaylight.controller.sal.packet.ARP;
+import org.opendaylight.controller.sal.packet.Ethernet;
+import org.opendaylight.controller.sal.packet.IEEE8021Q;
+import org.opendaylight.controller.sal.packet.Packet;
+import org.opendaylight.controller.sal.packet.PacketResult;
+import org.opendaylight.controller.sal.packet.RawPacket;
+import org.opendaylight.controller.sal.packet.address.EthernetAddress;
+import org.opendaylight.controller.sal.utils.EtherTypes;
+import org.opendaylight.controller.sal.utils.NodeConnectorCreator;
+import org.opendaylight.controller.sal.utils.NodeCreator;
+import org.opendaylight.controller.sal.utils.Status;
+import org.opendaylight.controller.sal.utils.StatusCode;
+import org.opendaylight.controller.switchmanager.ISwitchManager;
+import org.opendaylight.vtn.manager.MacAddressEntry;
+import org.opendaylight.vtn.manager.PortMap;
+import org.opendaylight.vtn.manager.PortMapConfig;
+import org.opendaylight.vtn.manager.SwitchPort;
+import org.opendaylight.vtn.manager.VBridge;
+import org.opendaylight.vtn.manager.VBridgeIfPath;
+import org.opendaylight.vtn.manager.VBridgePath;
+import org.opendaylight.vtn.manager.VInterface;
+import org.opendaylight.vtn.manager.VInterfaceConfig;
+import org.opendaylight.vtn.manager.VNodeState;
+import org.opendaylight.vtn.manager.VTNException;
+import org.opendaylight.vtn.manager.VTenantPath;
+import org.opendaylight.vtn.manager.VlanMap;
+import org.opendaylight.vtn.manager.VlanMapConfig;
+
+/**
+ * JUnit test for {@link VTNManagerImplTest}.
+ * This test class test at using stub environment.
+ */
+public class VTNManagerImplWithNodesTest extends VTNManagerImplTestCommon {
+
+    @BeforeClass
+    public static void beforeClass() {
+        stubMode = 1;
+    }
+
+    /**
+     * Test method for
+     * {@link VTNManagerImpl#addVlanMap(VBridgePath, VlanMapConfig)},
+     * {@link VTNManagerImpl#removeVlanMap(VBridgePath, java.lang.String)},
+     * {@link VTNManagerImpl#getVlanMap(VBridgePath, java.lang.String)},
+     * {@link VTNManagerImpl#getVlanMaps(VBridgePath)}.
+     */
+    @Test
+    public void testVlanMap() {
+        VTNManagerImpl mgr = vtnMgr;
+        short[] vlans = new short[] { 0, 10, 4095 };
+        String tname = "vtn";
+        VTenantPath tpath = new VTenantPath(tname);
+        String bname = "vbridge";
+        VBridgePath bpath = new VBridgePath(tname, bname);
+        String ifname = "vinterface";
+        VBridgeIfPath ifp = new VBridgeIfPath(tname, bname, ifname);
+        Status st = null;
+        List<VBridgePath> bpathlist = new ArrayList<VBridgePath>();
+        List<VBridgeIfPath> ifplist = new ArrayList<VBridgeIfPath>();
+        bpathlist.add(bpath);
+        ifplist.add(ifp);
+
+        createTenantAndBridgeAndInterface(mgr, tpath, bpathlist, ifplist);
+
+        // add a vlanmap to a vbridge
+        testVlanMapSingle(mgr, bpath);
+
+        // add multi vlanmap to a vbridge
+        for (Node node : createNodes(3)) {
+            for (short vlan : vlans) {
+                VlanMapConfig vlconf = new VlanMapConfig(node, vlan);
+                VlanMap map = null;
+                try {
+                    map = mgr.addVlanMap(bpath, vlconf);
+                    if (node != null && node.getType() != NodeConnector.NodeConnectorIDType.OPENFLOW) {
+                        fail("throwing Exception was expected.");
+                    }
+                } catch (VTNException e) {
+                    if (node != null && node.getType() == NodeConnector.NodeConnectorIDType.OPENFLOW) {
+                        unexpected(e);
+                    } else {
+                        // if node type is not OF, throwing a VTNException is expected.
+                        continue;
+                    }
+                }
+            }
+
+            List<VlanMap> list = null;
+            try {
+                list = mgr.getVlanMaps(bpath);
+            } catch (Exception e) {
+                unexpected(e);
+            }
+            if (node == null || node.getType() == NodeConnector.NodeConnectorIDType.OPENFLOW) {
+                assertTrue((node == null) ? "" : node.toString(), list.size() == vlans.length);
+                VBridge brdg = null;
+                try {
+                    brdg = mgr.getBridge(bpath);
+                } catch (VTNException e) {
+                   unexpected(e);
+                }
+                assertEquals((node == null) ? "" : node.toString(), VNodeState.UP, brdg.getState());
+            } else {
+                assertTrue(list.size() == 0);
+                VBridge brdg = null;
+                try {
+                    brdg = mgr.getBridge(bpath);
+                } catch (VTNException e) {
+                   unexpected(e);
+                }
+                assertEquals(node.toString(), VNodeState.UNKNOWN, brdg.getState());
+            }
+
+            for (VlanMap map : list) {
+                st = mgr.removeVlanMap(bpath, map.getId());
+                assertTrue((node == null) ? "" : node.toString(), st.isSuccess());
+            }
+        }
+
+        st = mgr.removeTenant(tpath);
+        assertTrue(st.isSuccess());
+    }
+
+    /**
+     * Test method for
+     * {@link VTNManagerImpl#getPortMap(VBridgeIfPath)} and
+     * {@link VTNManagerImpl#setPortMap(VBridgeIfPath, PortMapConfig)}.
+     */
+    @Test
+    public void testPortMap() {
+        VTNManagerImpl mgr = vtnMgr;
+        short[] vlans = new short[] { 0, 10, 4095 };
+        String tname = "vtn";
+        VTenantPath tpath = new VTenantPath(tname);
+        String bname = "vbridge";
+        VBridgePath bpath = new VBridgePath(tname, bname);
+        String ifname = "vinterface";
+        VBridgeIfPath ifp = new VBridgeIfPath(tname, bname, ifname);
+        Status st = null;
+        List<VBridgePath> bpathlist = new ArrayList<VBridgePath>();
+        List<VBridgeIfPath> ifplist = new ArrayList<VBridgeIfPath>();
+        bpathlist.add(bpath);
+        ifplist.add(ifp);
+
+        createTenantAndBridgeAndInterface(mgr, tpath, bpathlist, ifplist);
+
+
+        PortMap pmap = null;
+        try {
+            pmap = mgr.getPortMap(ifp);
+        } catch (Exception e) {
+            unexpected(e);
+        }
+        assertNull(pmap);
+
+        Node node = NodeCreator.createOFNode(0L);
+        SwitchPort[] ports = new SwitchPort[] {
+                new SwitchPort("port-10", NodeConnector.NodeConnectorIDType.OPENFLOW, "10"),
+                new SwitchPort(null, NodeConnector.NodeConnectorIDType.OPENFLOW, "11"),
+                new SwitchPort("port-10", null, null),
+                new SwitchPort("port-10"),
+                new SwitchPort(NodeConnector.NodeConnectorIDType.OPENFLOW, "13"),
+        };
+
+        for (SwitchPort port: ports) {
+            for (short vlan : vlans) {
+                PortMapConfig pmconf = new PortMapConfig(node, port, (short)vlan);
+                st = mgr.setPortMap(ifp, pmconf);
+                assertTrue(pmconf.toString(), st.isSuccess());
+
+                PortMap map = null;
+                try {
+                    map = mgr.getPortMap(ifp);
+                } catch (Exception e) {
+                    unexpected(e);
+                }
+                assertEquals(pmconf.toString(), pmconf, map.getConfig());
+                assertNotNull(pmconf.toString(), map.getNodeConnector());
+                if(port.getId() != null) {
+                    assertEquals(pmconf.toString(),
+                            Short.parseShort(port.getId()), map.getNodeConnector().getID());
+                }
+                if (port.getType() != null) {
+                    assertEquals(pmconf.toString(),
+                            port.getType(), map.getNodeConnector().getType());
+                }
+
+                checkNodeStatus(mgr, bpath, ifp, VNodeState.UP, VNodeState.UP, pmconf.toString());
+            }
+        }
+
+        st = mgr.setPortMap(ifp, null);
+        assertTrue(st.isSuccess());
+
+        PortMap map = null;
+        try {
+            map = mgr.getPortMap(ifp);
+        } catch (Exception e) {
+            unexpected(e);
+        }
+        assertNull(map);
+
+        st = mgr.removeTenant(tpath);
+        assertTrue(st.isSuccess());
+
+        // set mutli portmaps to a vbridge
+        String bname1 = "vbridge1";
+        VBridgePath bpath1 = new VBridgePath(tname, bname1);
+        String bname2 = "vbridge2";
+        VBridgePath bpath2 = new VBridgePath(tname, bname2);
+        String ifname1 = "vinterface1";
+        VBridgeIfPath ifp1 = new VBridgeIfPath(tname, bname1, ifname1);
+        String ifname2 = "vinterface2";
+        VBridgeIfPath ifp2 = new VBridgeIfPath(tname, bname1, ifname2);
+
+        List<VBridgePath> mbpathlist = new ArrayList<VBridgePath>();
+        List<VBridgeIfPath> mifplist = new ArrayList<VBridgeIfPath>();
+        mbpathlist.add(bpath1);
+        mbpathlist.add(bpath2);
+        mifplist.add(ifp1);
+        mifplist.add(ifp2);
+        createTenantAndBridgeAndInterface(mgr, tpath, mbpathlist, mifplist);
+
+        Node node1 = NodeCreator.createOFNode(0L);
+        SwitchPort port1 = new SwitchPort(NodeConnector.NodeConnectorIDType.OPENFLOW, "10");
+        PortMapConfig pmconf1 = new PortMapConfig(node1, port1, (short) 0);
+        st = mgr.setPortMap(ifp1, pmconf1);
+        assertTrue(st.isSuccess());
+
+        SwitchPort port2 = new SwitchPort(NodeConnector.NodeConnectorIDType.OPENFLOW, "11");
+        PortMapConfig pmconf2 = new PortMapConfig(node1, port2, (short) 0);
+        st = mgr.setPortMap(ifp2, pmconf2);
+        assertTrue(st.isSuccess());
+
+        // set duplicate portmap.
+        String ifname3 = "vinterface3";
+        VBridgeIfPath ifp3 = new VBridgeIfPath(tname, bname2, ifname3);
+        st = mgr.addBridgeInterface(ifp3, new VInterfaceConfig(null, true));
+        st = mgr.setPortMap(ifp3, pmconf1);
+        assertEquals(StatusCode.CONFLICT, st.getCode());
+
+        // add a vlan map to this VTN.
+        testVlanMapSingle(mgr, bpath1);
+
+        // remove test settings.
+        st = mgr.removeTenant(tpath);
+        assertTrue(st.isSuccess());
+    }
+
+    /**
+     * Common routine for {@code testVlanMap} and {@code testPortMap}
+     *
+     * @param mgr   a VTNManagerImpl.
+     * @param bpath a VBridgePath.
+     */
+    private void testVlanMapSingle (VTNManagerImpl mgr, VBridgePath bpath) {
+        short[] vlans = new short[] { 0, 10, 4095 };
+
+        for (Node vnode : createNodes(3)) {
+            for (short vlan : vlans) {
+                VlanMapConfig vlconf = new VlanMapConfig(vnode, vlan);
+                VlanMap vmap = null;
+                try {
+                    vmap = mgr.addVlanMap(bpath, vlconf);
+                    if (vnode != null && vnode.getType() != NodeConnector.NodeConnectorIDType.OPENFLOW) {
+                        fail("throwing Exception was expected.");
+                    }
+                } catch (VTNException e) {
+                    if (vnode != null && vnode.getType() == NodeConnector.NodeConnectorIDType.OPENFLOW) {
+                        unexpected(e);
+                    } else {
+                     // if node type is not OF, throwing a VTNException is expected.
+                        continue;
+                    }
+                }
+
+                VlanMap getmap = null;
+                try {
+                    getmap = mgr.getVlanMap(bpath, vmap.getId());
+                } catch (VTNException e) {
+                    unexpected(e);
+                }
+                assertEquals(vlconf.toString(), getmap.getId(), vmap.getId());
+                assertEquals(vlconf.toString(), getmap.getNode(), vnode);
+                assertEquals(vlconf.toString(), getmap.getVlan(), vlan);
+
+                VBridge brdg = null;
+                try {
+                    brdg = mgr.getBridge(bpath);
+                } catch (VTNException e) {
+                   unexpected(e);
+                }
+                assertEquals(vlconf.toString(), VNodeState.UP, brdg.getState());
+
+                Status st = mgr.removeVlanMap(bpath, vmap.getId());
+                assertTrue(vlconf.toString(), st.isSuccess());
+            }
+        }
+    }
+
+
+    /**
+     * Test method for invalid cases of
+     * {@link VTNManagerImpl#getPortMap(VBridgeIfPath)} and
+     * {@link VTNManagerImpl#setPortMap(VBridgeIfPath, PortMapConfig)}.
+     */
+    @Test
+    public void testPortMapInvalidCase() {
+        VTNManagerImpl mgr = vtnMgr;
+        String tname = "vtn";
+        VTenantPath tpath = new VTenantPath(tname);
+        String bname = "vbridge";
+        VBridgePath bpath = new VBridgePath(tname, bname);
+        String ifname = "vinterface";
+        VBridgeIfPath ifp = new VBridgeIfPath(tname, bname, ifname);
+
+        List<VBridgePath> bpathlist = new ArrayList<VBridgePath>();
+        List<VBridgeIfPath> ifplist = new ArrayList<VBridgeIfPath>();
+        bpathlist.add(bpath);
+        ifplist.add(ifp);
+        createTenantAndBridgeAndInterface(mgr, tpath, bpathlist, ifplist);
+
+        Node node = NodeCreator.createOFNode(0L);
+        SwitchPort port = new SwitchPort("port-1", NodeConnector.NodeConnectorIDType.OPENFLOW, "1");
+        PortMapConfig pmconf = new PortMapConfig(node, port, (short) 0);
+        Status st = mgr.setPortMap(ifp, pmconf);
+        assertTrue(st.isSuccess());
+
+        // bad request
+        VBridgeIfPath[] biflist = new VBridgeIfPath[] {
+                null, new VBridgeIfPath(tname, bname, null),
+                new VBridgeIfPath(tname, null, ifname),
+                new VBridgeIfPath(null, bname, ifname)};
+        SwitchPort[] badports = new SwitchPort[] {
+                new SwitchPort("port-10", NodeConnector.NodeConnectorIDType.OPENFLOW, null),
+                new SwitchPort("port-11", NodeConnector.NodeConnectorIDType.OPENFLOW, "10"),
+                new SwitchPort(null, null, "16"),
+                new SwitchPort(NodeConnector.NodeConnectorIDType.ONEPK, "10"),
+        };
+        PortMapConfig[] bpmlist = new PortMapConfig[] {
+                new PortMapConfig(null, port, (short) 0),
+                new PortMapConfig(node, null, (short) 0),
+                new PortMapConfig(node, null, (short) 0),
+                new PortMapConfig(node, port, (short)-1),
+                new PortMapConfig(node, port, (short)4096)};
+
+        for (VBridgeIfPath path: biflist) {
+            st = mgr.setPortMap(path, pmconf);
+            assertEquals((path == null) ? "null" : path.toString(),
+                    StatusCode.BADREQUEST, st.getCode());
+
+            try {
+                mgr.getPortMap(path);
+                fail("throwing exception was expected.");
+            } catch (VTNException e) {
+                assertEquals((path == null) ? "null" : path.toString(),
+                        StatusCode.BADREQUEST, e.getStatus().getCode());
+            }
+        }
+
+        for (SwitchPort sw: badports) {
+            mgr.setPortMap(ifp, new PortMapConfig(node, sw, (short)0));
+            assertEquals(sw.toString(), StatusCode.BADREQUEST, st.getCode());
+        }
+
+        for (PortMapConfig map: bpmlist) {
+            st = mgr.setPortMap(ifp, map);
+            assertEquals(map.toString(), StatusCode.BADREQUEST, st.getCode());
+        }
+
+        Node pnode = null;
+        try {
+            pnode = new Node(Node.NodeIDType.PRODUCTION, "Node ID: 0");
+        } catch (ConstructionException e1) {
+            unexpected(e1);
+        }
+        st = mgr.setPortMap(ifp, new PortMapConfig(pnode, new SwitchPort("port-1"), (short)10));
+        assertEquals(StatusCode.BADREQUEST, st.getCode());
+
+        // not found
+        VBridgeIfPath[] niflist = new VBridgeIfPath[] {
+                new VBridgeIfPath(tname, bname, "ii"),
+                new VBridgeIfPath(tname, "bbb", ifname),
+                new VBridgeIfPath("vv", bname, ifname)};
+
+        for (VBridgeIfPath path: niflist) {
+            st = mgr.setPortMap(path, pmconf);
+            assertEquals(path.toString(), StatusCode.NOTFOUND, st.getCode());
+
+            try {
+                mgr.getPortMap(path);
+                fail("throwing exception was expected.");
+            } catch (VTNException e) {
+                assertEquals(path.toString(), StatusCode.NOTFOUND, e.getStatus().getCode());
+            }
+        }
+
+        // TODO: NOTACCEPTABLE
+
+        st = mgr.removeTenant(tpath);
+        assertTrue(st.isSuccess());
+    }
+
+    /**
+     * Test method for
+     * {@link VTNManagerImpl#notifyNode(Node, UpdateType, Map)},
+     * {@link VTNManagerImpl#notifyNodeConnector(NodeConnector, UpdateType, Map)},
+     * {@link VTNManagerImpl#edgeUpdate(java.util.List)}
+     */
+    @Test
+    public void testNotifyNodeAndNodeConnectorWithPortMap() {
+        VTNManagerImpl mgr = vtnMgr;
+        short[] vlans = new short[] { 0, 10, 4095 };
+        Status st = null;
+        String tname = "vtn";
+        VTenantPath tpath = new VTenantPath(tname);
+        String bname = "vbridge";
+        VBridgePath bpath = new VBridgePath(tname, bname);
+        String ifname = "vinterface";
+        VBridgeIfPath ifp = new VBridgeIfPath(tname, bname, ifname);
+
+        List<VBridgePath> bpathlist = new ArrayList<VBridgePath>();
+        List<VBridgeIfPath> ifplist = new ArrayList<VBridgeIfPath>();
+        bpathlist.add(bpath);
+        ifplist.add(ifp);
+        createTenantAndBridgeAndInterface(mgr, tpath, bpathlist, ifplist);
+
+        PortMap pmap = null;
+        try {
+            pmap = mgr.getPortMap(ifp);
+        } catch (Exception e) {
+            unexpected(e);
+        }
+        assertNull(pmap);
+
+        Node node = NodeCreator.createOFNode(0L);
+        Node onode = NodeCreator.createOFNode(1L);
+        SwitchPort[] ports = new SwitchPort[] {
+                new SwitchPort("port-10", NodeConnector.NodeConnectorIDType.OPENFLOW, "10"),
+                new SwitchPort(null, NodeConnector.NodeConnectorIDType.OPENFLOW, "11"),
+                new SwitchPort("port-10", null, null),
+                new SwitchPort("port-10"),
+                new SwitchPort(NodeConnector.NodeConnectorIDType.OPENFLOW, "13"),
+        };
+
+        NodeConnector otherNc
+            = NodeConnectorCreator.createOFNodeConnector(Short.valueOf((short)10), onode);
+
+        for (SwitchPort port: ports) {
+            for (short vlan : vlans) {
+                PortMapConfig pmconf = new PortMapConfig(node, port, (short)vlan);
+                st = mgr.setPortMap(ifp, pmconf);
+                assertTrue(pmconf.toString(), st.isSuccess());
+
+                PortMap map = null;
+                try {
+                    map = mgr.getPortMap(ifp);
+                } catch (Exception e) {
+                    unexpected(e);
+                }
+                assertEquals(pmconf, map.getConfig());
+                assertNotNull(map.getNodeConnector());
+                if(port.getId() != null) {
+                    assertEquals(pmconf.toString(),
+                            Short.parseShort(port.getId()), map.getNodeConnector().getID());
+                }
+                if (port.getType() != null) {
+                    assertEquals(pmconf.toString(),
+                            port.getType(), map.getNodeConnector().getType());
+                }
+                checkNodeStatus(mgr, bpath, ifp, VNodeState.UP, VNodeState.UP, pmconf.toString());
+
+                // test for nodeconnector change notify.
+                Map<String, Property> propMap = null; // not used now.
+
+                putMacTableEntry(mgr, bpath, map.getNodeConnector());
+
+                mgr.notifyNodeConnector(map.getNodeConnector(), UpdateType.REMOVED, propMap);
+                checkNodeStatus(mgr, bpath, ifp, VNodeState.DOWN, VNodeState.DOWN, pmconf.toString());
+
+                checkMacTableEntry(mgr, bpath, true, pmconf.toString());
+
+                mgr.notifyNodeConnector(map.getNodeConnector(), UpdateType.ADDED, propMap);
+                checkNodeStatus(mgr, bpath, ifp, VNodeState.UP, VNodeState.UP, pmconf.toString());
+
+                mgr.notifyNodeConnector(map.getNodeConnector(), UpdateType.CHANGED, propMap);
+                checkNodeStatus(mgr, bpath, ifp, VNodeState.UP, VNodeState.UP, pmconf.toString());
+
+                mgr.notifyNodeConnector(otherNc, UpdateType.REMOVED, propMap);
+                checkNodeStatus(mgr, bpath, ifp, VNodeState.UP, VNodeState.UP, pmconf.toString());
+
+                mgr.notifyNodeConnector(otherNc, UpdateType.ADDED, propMap);
+                checkNodeStatus(mgr, bpath, ifp, VNodeState.UP, VNodeState.UP, pmconf.toString());
+
+                // test for node change notify.
+                putMacTableEntry(mgr, bpath, map.getNodeConnector());
+
+                mgr.notifyNode(node, UpdateType.REMOVED, propMap);
+                checkNodeStatus(mgr, bpath, ifp, VNodeState.DOWN, VNodeState.DOWN, pmconf.toString());
+
+                checkMacTableEntry(mgr, bpath, true, pmconf.toString());
+
+                mgr.notifyNode(node, UpdateType.ADDED, propMap);
+                checkNodeStatus(mgr, bpath, ifp, VNodeState.DOWN, VNodeState.DOWN, pmconf.toString());
+
+                mgr.notifyNodeConnector(map.getNodeConnector(), UpdateType.ADDED, propMap);
+                checkNodeStatus(mgr, bpath, ifp, VNodeState.UP, VNodeState.UP, pmconf.toString());
+
+                mgr.notifyNode(node, UpdateType.CHANGED, propMap);
+                checkNodeStatus(mgr, bpath, ifp, VNodeState.UP, VNodeState.UP, pmconf.toString());
+
+                mgr.notifyNode(onode, UpdateType.REMOVED, propMap);
+                checkNodeStatus(mgr, bpath, ifp, VNodeState.UP, VNodeState.UP, pmconf.toString());
+
+                mgr.notifyNode(onode, UpdateType.ADDED, propMap);
+                checkNodeStatus(mgr, bpath, ifp, VNodeState.UP, VNodeState.UP, pmconf.toString());
+
+                // TODO: test for edge change notify
+            }
+        }
+
+        st = mgr.removeTenant(tpath);
+        assertTrue(st.isSuccess());
+    }
+
+    /**
+     * same test with {@code testNotifyNodeAndNodeConnectorWithPortMap}.
+     * this test case do with vlan map setting.
+     */
+    @Test
+    public void testNotifyNodeAndNodeConnectorWithVlanMap() {
+        VTNManagerImpl mgr = vtnMgr;
+        short[] vlans = new short[] { 0, 10, 4095 };
+
+        String tname = "vtn";
+        VTenantPath tpath = new VTenantPath(tname);
+        String bname = "vbridge";
+        VBridgePath bpath = new VBridgePath(tname, bname);
+        String ifname = "vinterface";
+        VBridgeIfPath ifp = new VBridgeIfPath(tname, bname, ifname);
+        Status st = null;
+
+        List<VBridgePath> bpathlist = new ArrayList<VBridgePath>();
+        List<VBridgeIfPath> ifplist = new ArrayList<VBridgeIfPath>();
+        bpathlist.add(bpath);
+        ifplist.add(ifp);
+        createTenantAndBridgeAndInterface(mgr, tpath, bpathlist, ifplist);
+
+        Node cnode = NodeCreator.createOFNode(0L);
+        Node onode = NodeCreator.createOFNode(1L);
+        NodeConnector nc
+            = NodeConnectorCreator.createOFNodeConnector(Short.valueOf((short)10), cnode);
+        NodeConnector otherNc
+            = NodeConnectorCreator.createOFNodeConnector(Short.valueOf((short)10), onode);
+
+        // add a vlanmap to a vbridge
+        for (Node node : createNodes(2)) {
+            for (short vlan : vlans) {
+                VlanMapConfig vlconf = new VlanMapConfig(node, vlan);
+                VlanMap map = null;
+                try {
+                    map = mgr.addVlanMap(bpath, vlconf);
+                    if (node != null && node.getType() != NodeConnector.NodeConnectorIDType.OPENFLOW) {
+                        fail("throwing Exception was expected.");
+                    }
+                } catch (VTNException e) {
+                    if (node != null && node.getType() == NodeConnector.NodeConnectorIDType.OPENFLOW) {
+                        unexpected(e);
+                    } else {
+                        continue;
+                    }
+                }
+
+                VlanMap getmap = null;
+                try {
+                    getmap = mgr.getVlanMap(bpath, map.getId());
+                } catch (VTNException e) {
+                    unexpected(e);
+                }
+                assertEquals(getmap.getId(), map.getId());
+                assertEquals(getmap.getNode(), node);
+                assertEquals(getmap.getVlan(), vlan);
+                checkNodeStatus(mgr, bpath, ifp, VNodeState.UP, VNodeState.UNKNOWN, vlconf.toString());
+
+                // test for node connector change notify.
+                Map<String, Property> propMap = null; // not used now.
+
+                putMacTableEntry(mgr, bpath, nc);
+
+                mgr.notifyNodeConnector(nc, UpdateType.REMOVED, propMap);
+                checkNodeStatus(mgr, bpath, ifp, VNodeState.UP, VNodeState.UNKNOWN, vlconf.toString());
+
+                checkMacTableEntry(mgr, bpath, true, vlconf.toString());
+
+                mgr.notifyNodeConnector(nc, UpdateType.ADDED, propMap);
+                checkNodeStatus(mgr, bpath, ifp, VNodeState.UP, VNodeState.UNKNOWN, vlconf.toString());
+
+                mgr.notifyNodeConnector(nc, UpdateType.CHANGED, propMap);
+                checkNodeStatus(mgr, bpath, ifp, VNodeState.UP, VNodeState.UNKNOWN, vlconf.toString());
+
+                mgr.notifyNodeConnector(otherNc, UpdateType.REMOVED, propMap);
+                checkNodeStatus(mgr, bpath, ifp, VNodeState.UP, VNodeState.UNKNOWN, vlconf.toString());
+
+                mgr.notifyNodeConnector(otherNc, UpdateType.ADDED, propMap);
+                checkNodeStatus(mgr, bpath, ifp, VNodeState.UP, VNodeState.UNKNOWN, vlconf.toString());
+
+                // test for node change notify.
+                putMacTableEntry(mgr, bpath, nc);
+                mgr.notifyNode(cnode, UpdateType.REMOVED, propMap);
+                checkNodeStatus(mgr, bpath, ifp, (node == null) ? VNodeState.UP : VNodeState.DOWN,
+                        VNodeState.UNKNOWN, vlconf.toString());
+
+               checkMacTableEntry(mgr, bpath, true, vlconf.toString());
+
+                mgr.notifyNode(cnode, UpdateType.ADDED, propMap);
+                checkNodeStatus(mgr, bpath, ifp, VNodeState.UP, VNodeState.UNKNOWN, vlconf.toString());
+
+//                mgr.notifyNodeConnector(nc, UpdateType.ADDED, propMap);
+//                checkNodeStatus(mgr, bpath, ifp, VNodeState.UP, VNodeState.UP, vlconf.toString());
+
+                mgr.notifyNode(cnode, UpdateType.CHANGED, propMap);
+                checkNodeStatus(mgr, bpath, ifp, VNodeState.UP, VNodeState.UNKNOWN, vlconf.toString());
+
+                mgr.notifyNode(onode, UpdateType.REMOVED, propMap);
+                checkNodeStatus(mgr, bpath, ifp, VNodeState.UP, VNodeState.UNKNOWN, vlconf.toString());
+
+                mgr.notifyNode(onode, UpdateType.ADDED, propMap);
+                checkNodeStatus(mgr, bpath, ifp, VNodeState.UP, VNodeState.UNKNOWN, vlconf.toString());
+
+                // TODO: test for edge change notify
+
+                st = mgr.removeVlanMap(bpath, map.getId());
+                assertTrue(st.isSuccess());
+            }
+        }
+
+        st = mgr.removeTenant(tpath);
+        assertTrue(st.isSuccess());
+    }
+
+    /**
+     * check node and interface status specified vbridge and vinterface.
+     * @param mgr   VTNManagerImpl
+     * @param bpath checked VBridgePath
+     * @param ifp   checked VBridgeIfPath
+     * @param bstate expected vbridge state
+     * @param ifstate expected vinterface state
+     * @param msg message strings print when assertion failed.
+     */
+    private void checkNodeStatus(VTNManagerImpl mgr, VBridgePath bpath, VBridgeIfPath ifp,
+            VNodeState bstate, VNodeState ifstate, String msg) {
+
+        VBridge brdg = null;
+        VInterface bif = null;
+        try {
+            bif = mgr.getBridgeInterface(ifp);
+            brdg = mgr.getBridge(bpath);
+        } catch (VTNException e) {
+            unexpected(e);
+        }
+
+        assertEquals(msg, bstate, brdg.getState());
+        assertEquals(msg, ifstate, bif.getState());
+    }
+
+    /**
+     * put a Mac Address Table Entry to Mac Address Table of specified bridge.
+     *
+     * @param mgr   VTNManagerImpl
+     * @param bpath VBridgePath
+     * @param nc    NodeConnector
+     */
+    private void putMacTableEntry(VTNManagerImpl mgr, VBridgePath bpath, NodeConnector nc) {
+        byte[] src = new byte[] {(byte)0x00, (byte)0x01, (byte)0x01, (byte)0x01, (byte)0x01, (byte)0x01,};
+        byte[] dst = new byte[] {(byte)0xFF, (byte)0xFF, (byte)0xFF, (byte)0xFF, (byte)0xFF, (byte)0xFF};
+        byte[] sender = new byte[] {(byte)192, (byte)168, (byte)0, (byte)1};
+        byte[] target = new byte[] {(byte)192, (byte)168, (byte)0, (byte)250};
+
+        PacketContext pctx = createARPPacketContext(src, dst, sender ,target, (short)0, nc, ARP.REQUEST);
+        MacAddressTable tbl = mgr.getMacAddressTable(bpath);
+        tbl.add(mgr, pctx);
+    }
+
+    /**
+     * check a Mac Address Table Entry.
+     *
+     * @param mgr   VTNManagerImpl
+     * @param bpath VBridgePath
+     * @param isFlushed if true, expected result is 0. if not 0, execpted result is more than 0.
+     * @param msg
+     */
+    private void checkMacTableEntry(VTNManagerImpl mgr, VBridgePath bpath, boolean isFlushed, String msg) {
+        MacAddressTable tbl = mgr.getMacAddressTable(bpath);
+
+        List<MacAddressEntry> list = null;
+        try {
+            list = tbl.getEntries();
+        } catch (VTNException e) {
+           unexpected(e);
+        }
+
+        if (isFlushed) {
+            assertEquals(msg, 0, list.size());
+        } else {
+            assertTrue(msg, list.size() > 0);
+        }
+    }
+
+    /**
+     * Test method for {@link VTNManagerImpl#receiveDataPacket(RawPacket)}.
+     * The case PortMap applied to vBridge.
+     */
+    @Test
+    public void testReceiveDataPacketPortMapped() {
+        VTNManagerImpl mgr = vtnMgr;
+        TestStub stub = stubObj;
+        ISwitchManager swmgr = mgr.getSwitchManager();
+        short[] vlans = new short[] { 0, 10, 4095 };
+        byte[] cntMac = swmgr.getControllerMAC();
+        ConcurrentMap<VBridgePath, Set<NodeConnector>> mappedConnectors
+            = new ConcurrentHashMap<VBridgePath, Set<NodeConnector>>();
+        Status st = null;
+
+        String tname = "vtn";
+        VTenantPath tpath = new VTenantPath(tname);
+        String bname1 = "vbridge1";
+        VBridgePath bpath1 = new VBridgePath(tname, bname1);
+        String bname2 = "vbridge2";
+        VBridgePath bpath2 = new VBridgePath(tname, bname2);
+        List<VBridgePath> bpathlist = new ArrayList<VBridgePath>();
+        bpathlist.add(bpath1);
+        bpathlist.add(bpath2);
+        createTenantAndBridge(mgr, tpath, bpathlist);
+
+
+        mappedConnectors.put(bpath1, new HashSet<NodeConnector>());
+        mappedConnectors.put(bpath2, new HashSet<NodeConnector>());
+
+        Set<Node> existNodes = swmgr.getNodes();
+        Set<NodeConnector> existConnectors = new HashSet<NodeConnector>();
+        for (Node node: existNodes) {
+            existConnectors.addAll(swmgr.getNodeConnectors(node));
+        }
+
+        // add interface
+        for (short i = 0; i < 4; i++) {
+            int inode = 0;
+            for (Node node : existNodes) {
+                String ifname = "vinterface" + inode + (i + 10);
+                VBridgeIfPath ifp = new VBridgeIfPath(tname, (i < 2) ? bname1 : bname2,
+                                                    ifname);
+                st = mgr.addBridgeInterface(ifp, new VInterfaceConfig(null, true));
+                assertTrue(ifp.toString(), st.isSuccess());
+                inode++;
+            }
+        }
+
+        // null case
+        PacketResult result = mgr.receiveDataPacket(null);
+        assertEquals(PacketResult.IGNORED, result);
+
+        for (short vlan: vlans) {
+            // add port mapping
+            for (short i = 0; i < 4; i++) {
+                int inode = 0;
+                for (Node node : existNodes) {
+                    String ifname = "vinterface" + inode + (i + 10);
+                    VBridgeIfPath ifp = new VBridgeIfPath(tname, (i < 2) ? bname1 : bname2,
+                                                            ifname);
+
+                    SwitchPort port = new SwitchPort(NodeConnector.NodeConnectorIDType.OPENFLOW,
+                                                    String.valueOf(i + 10));
+                    PortMapConfig pmconf = new PortMapConfig(node, port, vlan);
+                    st = mgr.setPortMap(ifp, pmconf);
+                    assertTrue(ifp.toString() + "," + pmconf.toString(), st.isSuccess());
+
+                    NodeConnector mapnc = NodeConnectorCreator.createOFNodeConnector(
+                                                        Short.valueOf((short)(i + 10)), node);
+                    Set<NodeConnector> set  = mappedConnectors.get((i < 2)? bpath1 : bpath2);
+                    set.add(mapnc);
+                    mappedConnectors.put((i < 2)? bpath1 : bpath2, set);
+                    inode++;
+                }
+            }
+
+            Set<NodeConnector> mappedThis = new HashSet<NodeConnector>(mappedConnectors.get(bpath1));
+            Set<NodeConnector> noMappedThis = new HashSet<NodeConnector>(existConnectors);
+            noMappedThis.removeAll(mappedConnectors.get(bpath1));
+
+            testReceiveDataPacketBCLoop(mgr, bpath1, MapType.PORT, vlan,
+                                        mappedThis, noMappedThis, stub);
+
+            st = mgr.flushMacEntries(bpath1);
+            assertTrue("vlan=" + vlan, st.isSuccess());
+
+            testReceiveDataPacketUCLoopLearned(mgr, bpath1, MapType.PORT, vlan,
+                    mappedThis, noMappedThis, stub);
+
+            st = mgr.flushMacEntries(bpath1);
+            assertTrue("vlan=" + vlan, st.isSuccess());
+
+            testReceiveDataPacketUCLoop(mgr, bpath1, MapType.PORT, vlan,
+                    mappedThis, noMappedThis, stub);
+
+            st = mgr.flushMacEntries(bpath1);
+            assertTrue("vlan=" + vlan, st.isSuccess());
+
+            testReceiveDataPacketUCLoopLearned(mgr, bpath1, MapType.PORT, vlan,
+                    mappedThis, noMappedThis, stub);
+
+
+            // in case recieved a packet from controller.
+            for (NodeConnector nc: mappedThis) {
+                byte [] src = new byte[] {cntMac[0], cntMac[1], cntMac[2],
+                                        cntMac[3], cntMac[4], cntMac[5]};
+                byte [] dst = new byte[] {(byte)0xff, (byte)0xff, (byte)0xff,
+                                        (byte)0xff, (byte)0xff, (byte)0xff};
+                byte [] sender = new byte[] {(byte)192, (byte)168, (byte)0, (byte)1};
+                byte [] target = new byte[] {(byte)192, (byte)168, (byte)0, (byte)250};
+
+                RawPacket inPkt = createARPRawPacket(src, dst, sender, target, vlan, nc, ARP.REQUEST);
+                result = mgr.receiveDataPacket(inPkt);
+                assertEquals(nc.toString(), PacketResult.IGNORED, result);
+
+                st = mgr.flushMacEntries(bpath1);
+                assertTrue(nc.toString(), st.isSuccess());
+            }
+        }
+
+        st = mgr.removeBridge(bpath2);
+        assertTrue(st.isSuccess());
+
+        // in case received pacekt from no mapped port.
+        for (NodeConnector nc: mappedConnectors.get(bpath2)) {
+            byte iphost = 1;
+            for (EthernetAddress ea: createEthernetAddresses(false)) {
+                byte [] bytes = ea.getValue();
+                byte [] src = new byte[] {bytes[0], bytes[1], bytes[2],
+                                        bytes[3], bytes[4], bytes[5]};
+                byte [] dst = new byte[] {(byte)0xff, (byte)0xff, (byte)0xff,
+                                        (byte)0xff, (byte)0xff, (byte)0xff};
+                byte [] sender = new byte[] {(byte)192, (byte)168, (byte)0, (byte)iphost};
+                byte [] target = new byte[] {(byte)192, (byte)168, (byte)0, (byte)250};
+                short vlan = -1;
+                RawPacket inPkt = createARPRawPacket(src, dst, sender, target, vlan, nc, ARP.REQUEST);
+                Ethernet inPktDecoded = (Ethernet)stub.decodeDataPacket(inPkt);
+
+                result = mgr.receiveDataPacket(inPkt);
+                if (nc != null) {
+                    assertEquals(nc.toString() + "," + ea.toString(), PacketResult.IGNORED, result);
+                } else {
+                    assertEquals(ea.toString(), PacketResult.IGNORED, result);
+                }
+
+                List<RawPacket> transDatas = stub.getTransmittedDataPacket();
+                assertEquals(nc.toString() + "," + ea.toString(), 0, transDatas.size());
+                iphost++;
+            }
+        }
+
+        st = mgr.removeTenant(tpath);
+        assertTrue(st.isSuccess());
+    }
+
+    /**
+     * Test method for {@link VTNManagerImpl#receiveDataPacket(RawPacket)}.
+     * The case VlanMap applied to vBridge.
+     */
+    @Test
+    public void testReceiveDataPacketVlanMapped() {
+        VTNManagerImpl mgr = vtnMgr;
+        TestStub stub = stubObj;
+        ISwitchManager swmgr = mgr.getSwitchManager();
+        short[] vlans = new short[] { 0, 10, 4095 };
+        byte[] cntMac = swmgr.getControllerMAC();
+        ConcurrentMap<VBridgePath, Set<NodeConnector>> mappedConnectors
+            = new ConcurrentHashMap<VBridgePath, Set<NodeConnector>>();
+        Status st = null;
+
+        String tname = "vtn";
+        VTenantPath tpath = new VTenantPath(tname);
+        String bname1 = "vbridge1";
+        VBridgePath bpath1 = new VBridgePath(tname, bname1);
+        String bname2 = "vbridge2";
+        VBridgePath bpath2 = new VBridgePath(tname, bname2);
+        List<VBridgePath> bpathlist = new ArrayList<VBridgePath>();
+        bpathlist.add(bpath1);
+        bpathlist.add(bpath2);
+        createTenantAndBridge(mgr, tpath, bpathlist);
+
+        mappedConnectors.put(bpath1, new HashSet<NodeConnector>());
+        mappedConnectors.put(bpath2, new HashSet<NodeConnector>());
+
+        Set<Node> existNodes = swmgr.getNodes();
+        Set<NodeConnector> existConnectors = new HashSet<NodeConnector>();
+        for (Node node: existNodes) {
+            existConnectors.addAll(swmgr.getNodeConnectors(node));
+        }
+
+        for (short vlan : vlans) {
+            VlanMapConfig vlconf = new VlanMapConfig(null, vlan);
+            VlanMap map = null;
+            try {
+                map = mgr.addVlanMap(bpath1, vlconf);
+            } catch (VTNException e) {
+                unexpected(e);
+            }
+
+            Set<NodeConnector> set = new HashSet<NodeConnector>(existConnectors);
+            mappedConnectors.put(bpath1, set);
+
+            Set<NodeConnector> mappedThis = new HashSet<NodeConnector>(mappedConnectors.get(bpath1));
+            Set<NodeConnector> noMappedThis = new HashSet<NodeConnector>(existConnectors);
+            noMappedThis.removeAll(mappedConnectors.get(bpath1));
+
+            testReceiveDataPacketBCLoop(mgr, bpath1, MapType.PORT, vlan,
+                    mappedThis, noMappedThis, stub);
+
+            st = mgr.flushMacEntries(bpath1);
+            assertTrue(vlconf.toString(), st.isSuccess());
+
+            testReceiveDataPacketUCLoopLearned(mgr, bpath1, MapType.PORT, vlan,
+                    mappedThis, noMappedThis, stub);
+
+            st = mgr.flushMacEntries(bpath1);
+            assertTrue(vlconf.toString(), st.isSuccess());
+
+            testReceiveDataPacketUCLoop(mgr, bpath1, MapType.PORT, vlan,
+                    mappedThis, noMappedThis, stub);
+
+            st = mgr.flushMacEntries(bpath1);
+            assertTrue(vlconf.toString(), st.isSuccess());
+
+            testReceiveDataPacketUCLoopLearned(mgr, bpath1, MapType.VLAN, vlan,
+                    mappedThis, noMappedThis, stub);
+
+            mappedConnectors.replace(bpath1, new HashSet<NodeConnector>());
+            mappedConnectors.replace(bpath2, new HashSet<NodeConnector>());
+
+            st = mgr.removeVlanMap(bpath1, map.getId());
+            assertTrue(vlconf.toString(), st.isSuccess());
+
+            st = mgr.flushMacEntries(bpath1);
+            assertTrue(vlconf.toString(), st.isSuccess());
+        }
+
+        st = mgr.removeTenant(tpath);
+        assertTrue(st.isSuccess());
+    }
+
+    /**
+     * Test method for {@link VTNManagerImpl#receiveDataPacket(RawPacket)}.
+     * The case both VlanMap and PortMap applied to vBridge.
+     */
+    @Test
+    public void testReceiveDataPacketBothMapped() {
+        // TODO:
+    }
+
+    /**
+     * Test method for
+     * {@link VTNManagerImpl#find(InetAddress)},
+     * {@link internal.VTNManagerImpl#findHost(InetAddress, Set)},
+     * {@link VTNManagerImpl#probe(HostNodeConnector)},
+     * {@link VTNManagerImpl#probeHost(HostNodeConnector)}
+     */
+    @Test
+    public void testFindProbe() {
+        VTNManagerImpl mgr = vtnMgr;
+        TestStub stub = stubObj;
+        ISwitchManager swmgr = mgr.getSwitchManager();
+        short[] vlans = new short[] { 0, 10, 4095 };
+        byte[] cntMac = swmgr.getControllerMAC();
+        ConcurrentMap<VBridgePath, Set<NodeConnector>> mappedConnectors
+            = new ConcurrentHashMap<VBridgePath, Set<NodeConnector>>();
+        Status st = null;
+
+        String tname = "vtn";
+        VTenantPath tpath = new VTenantPath(tname);
+        String bname1 = "vbridge1";
+        VBridgePath bpath1 = new VBridgePath(tname, bname1);
+        String bname2 = "vbridge2";
+        VBridgePath bpath2 = new VBridgePath(tname, bname2);
+        List<VBridgePath> bpathlist = new ArrayList<VBridgePath>();
+        bpathlist.add(bpath1);
+        bpathlist.add(bpath2);
+        createTenantAndBridge(mgr, tpath, bpathlist);
+
+        mappedConnectors.put(bpath1, new HashSet<NodeConnector>());
+        mappedConnectors.put(bpath2, new HashSet<NodeConnector>());
+
+        Set<Node> existNodes = swmgr.getNodes();
+        Set<NodeConnector> existConnectors = new HashSet<NodeConnector>();
+        for (Node node: existNodes) {
+            existConnectors.addAll(swmgr.getNodeConnectors(node));
+        }
+
+        // add interface
+        for (short i = 0; i < 4; i++) {
+            int inode = 0;
+            for (Node node : existNodes) {
+                String ifname = "vinterface" + inode + (i + 10);
+                VBridgeIfPath ifp = new VBridgeIfPath(tname, (i < 2) ? bname1 : bname2,
+                                                    ifname);
+                st = mgr.addBridgeInterface(ifp, new VInterfaceConfig(null, true));
+                assertTrue(ifp.toString(), st.isSuccess());
+                inode++;
+            }
+        }
+
+        InetAddress ia6 = null;
+        try {
+            ia6 = InetAddress.getByAddress(new byte[]{
+                    (byte)0x20, (byte)0x01, (byte)0x04, (byte)0x20,
+                    (byte)0x02, (byte)0x81, (byte)0x10, (byte)0x04,
+                    (byte)0x0e1, (byte)0x23, (byte)0xe6, (byte)0x88,
+                    (byte)0xd6, (byte)0x55, (byte)0xa1, (byte)0xb0});
+        } catch (UnknownHostException e) {
+            unexpected(e);
+        }
+
+        for (short vlan: vlans) {
+            // add port mapping
+            for (short i = 0; i < 4; i++) {
+                int inode = 0;
+                for (Node node : existNodes) {
+                    String ifname = "vinterface" + inode + (i + 10);
+                    VBridgeIfPath ifp = new VBridgeIfPath(tname, (i < 2) ? bname1 : bname2,
+                                                            ifname);
+                    SwitchPort port = new SwitchPort(NodeConnector.NodeConnectorIDType.OPENFLOW,
+                                                    String.valueOf(i + 10));
+                    PortMapConfig pmconf = new PortMapConfig(node, port, vlan);
+                    st = mgr.setPortMap(ifp, pmconf);
+                    assertTrue(ifp.toString() + "," + pmconf.getVlan(), st.isSuccess());
+
+                    NodeConnector mapnc = NodeConnectorCreator.createOFNodeConnector(
+                                                        Short.valueOf((short)(i + 10)), node);
+                    Set<NodeConnector> set  = mappedConnectors.get((i < 2)? bpath1 : bpath2);
+                    set.add(mapnc);
+                    mappedConnectors.put((i < 2)? bpath1 : bpath2, set);
+                    inode++;
+                }
+            }
+
+            Set<Set<VBridgePath>> bpathset = new HashSet<Set<VBridgePath>>();
+            bpathset.add(null);
+            Set<VBridgePath> bpaths1 = new HashSet<VBridgePath>();
+            bpaths1.add(bpath1);
+            bpathset.add(bpaths1);
+            Set<VBridgePath> bpaths2 = new HashSet<VBridgePath>(bpaths1);
+            bpaths2.add(bpath2);
+            bpathset.add(bpaths2);
+
+            InetAddress ia = null;
+            try {
+                ia = InetAddress.getByAddress(new byte[] {
+                                     (byte)10, (byte)0, (byte)0, (byte)1});
+            } catch (UnknownHostException e) {
+                unexpected(e);
+            }
+
+            mgr.findHost(null, bpaths1);
+            mgr.findHost(ia6, bpaths1);
+
+            for (Set<VBridgePath> bpaths : bpathset) {
+                int numMapped = 0;
+                Set<NodeConnector> mappedThis = new HashSet<NodeConnector>();
+                if (bpaths == null || bpaths.contains(bpath1)) {
+                    mappedThis.addAll(mappedConnectors.get(bpath1));
+                    numMapped += mappedConnectors.get(bpath1).size();
+                }
+                if (bpaths == null || bpaths.contains(bpath2)) {
+                    mappedThis.addAll(mappedConnectors.get(bpath2));
+                    numMapped += mappedConnectors.get(bpath2).size();
+                }
+                Set<NodeConnector> noMappedThis = new HashSet<NodeConnector>(existConnectors);
+                noMappedThis.removeAll(mappedThis);
+
+                // test find()
+                if (bpaths == null) {
+                    mgr.find(ia);
+                } else {
+                    mgr.findHost(ia, bpaths);
+                }
+
+                List<RawPacket> transDatas = stub.getTransmittedDataPacket();
+                assertEquals(numMapped, transDatas.size());
+
+                for (RawPacket raw : transDatas) {
+                    Packet pkt = stub.decodeDataPacket(raw);
+                    assertTrue(raw.getOutgoingNodeConnector().toString(),
+                        mappedThis.contains(raw.getOutgoingNodeConnector()));
+                    assertFalse(raw.getOutgoingNodeConnector().toString(),
+                        noMappedThis.contains(raw.getOutgoingNodeConnector()));
+
+                    Ethernet eth = (Ethernet)pkt;
+
+                    checkOutEthernetPacket("vlan=" + vlan, eth, EtherTypes.ARP,
+                            swmgr.getControllerMAC(), new byte[] {-1, -1, -1, -1, -1, -1},
+                            vlan, EtherTypes.IPv4, ARP.REQUEST,
+                            swmgr.getControllerMAC(), new byte[] {0, 0, 0, 0, 0, 0},
+                            new byte[] {0, 0, 0, 0}, ia.getAddress());
+                }
+            }
+
+            // probe()
+            for (Node node: existNodes) {
+                byte [] mac = new byte [] { 0x00, 0x00, 0x00, 0x11, 0x22, 0x33};
+                NodeConnector nc = NodeConnectorCreator.createOFNodeConnector(Short.valueOf("10"), node);
+                HostNodeConnector hnode = null;
+                try {
+                    hnode = new HostNodeConnector(mac, ia, nc, vlan);
+                } catch (ConstructionException e) {
+                    unexpected(e);
+                }
+
+                mgr.probe(hnode);
+
+                List<RawPacket> transDatas = stub.getTransmittedDataPacket();
+                assertEquals(node.toString(), 1, transDatas.size());
+
+                RawPacket raw = transDatas.get(0);
+                assertEquals(node.toString(), nc, raw.getOutgoingNodeConnector());
+
+                Ethernet eth = (Ethernet)stub.decodeDataPacket(raw);
+                checkOutEthernetPacket("vlan=" + vlan, eth, EtherTypes.ARP,
+                        swmgr.getControllerMAC(), mac,
+                        vlan, EtherTypes.IPv4, ARP.REQUEST,
+                        swmgr.getControllerMAC(), mac,
+                        new byte[] {0, 0, 0, 0}, ia.getAddress());
+            }
+
+            // if null case
+            mgr.probe(null);
+        }
+
+        st = mgr.removeTenant(tpath);
+        assertTrue(st.isSuccess());
+    }
+
+
+    // private methods.
+
+    /**
+     * common method for test which use BroadCast Packet (ARP Request packet).
+     * this method expected that action for received packet is flooding to mapped port.
+     */
+    private void testReceiveDataPacketBCLoop(VTNManagerImpl mgr, VBridgePath bpath,
+           MapType type, short vlan, Set<NodeConnector> mappedThis, Set<NodeConnector> noMappedThis,
+           TestStub stub) {
+        testReceiveDataPacketCommonLoop(mgr, bpath, MapType.PORT, vlan,
+                mappedThis, noMappedThis, stub, (short)1, EtherTypes.ARP, null);
+    }
+
+    /**
+     * common method for test which use UniCast Packet (IPv4 packet).
+     * this method expected that action for received packet is flooding to mapped port.
+     */
+    private void testReceiveDataPacketUCLoop(VTNManagerImpl mgr, VBridgePath bpath,
+            MapType type, short vlan, Set<NodeConnector> mappedThis, Set<NodeConnector> noMappedThis,
+            TestStub stub) {
+        testReceiveDataPacketCommonLoop(mgr, bpath, MapType.PORT, vlan,
+                                mappedThis, noMappedThis, stub, (short)0, EtherTypes.IPv4, null);
+    }
+
+    /**
+     * common method for
+     * {@link testReceiveDataPacketBCLoop} and {@link testReceiveDataPacketUCLoop}.
+     * this method expected that action for received packet is flooding to mapped port.
+     */
+    private void testReceiveDataPacketCommonLoop(VTNManagerImpl mgr, VBridgePath bpath,
+            MapType type, short vlan, Set<NodeConnector> mappedThis, Set<NodeConnector> noMappedThis,
+            TestStub stub, short bc, EtherTypes ethtype, NodeConnector targetnc) {
+        ISwitchManager swmgr = mgr.getSwitchManager();
+        byte[] cntMac = swmgr.getControllerMAC();
+
+        for (NodeConnector nc: mappedThis) {
+            if (targetnc != null && !targetnc.equals(nc)) {
+                continue;
+            }
+            byte iphost = 1;
+            for (EthernetAddress ea: createEthernetAddresses(false)) {
+                byte [] bytes = ea.getValue();
+                byte [] src = new byte[] {bytes[0], bytes[1], bytes[2],
+                                       bytes[3], bytes[4], bytes[5]};
+                byte [] dst;
+                if (bc > 0) {
+                    dst = new byte[] {(byte)0xff, (byte)0xff, (byte)0xff,
+                                        (byte)0xff, (byte)0xff, (byte)0xff};
+                } else {
+                    dst = new byte[] {(byte)0x00, (byte)0x00, (byte)0x00,
+                                        (byte)0xff, (byte)0xff, (byte)0x11};
+                }
+                byte [] sender = new byte[] {(byte)192, (byte)168, (byte)0, (byte)iphost};
+                byte [] target = new byte[] {(byte)192, (byte)168, (byte)0, (byte)250};
+
+                RawPacket inPkt = null;
+                if (ethtype.shortValue() == EtherTypes.IPv4.shortValue()) {
+                    inPkt = createIPv4RawPacket(src, dst, sender, target,
+                                                    (vlan > 0) ? vlan : -1, nc);
+                } else if (ethtype.shortValue() == EtherTypes.ARP.shortValue()){
+                    inPkt = createARPRawPacket(src, dst, sender, target,
+                            (vlan > 0) ? vlan : -1, nc, ARP.REQUEST);
+                }
+                Ethernet inPktDecoded = (Ethernet)stub.decodeDataPacket(inPkt);
+                PacketResult result = mgr.receiveDataPacket(inPkt);
+
+                if (nc != null &&
+                    nc.getType() == NodeConnector.NodeConnectorIDType.OPENFLOW) {
+
+                    assertEquals(nc.toString() + ea.toString(), PacketResult.KEEP_PROCESSING, result);
+
+                    MacAddressEntry entry = null;
+                    try {
+                        entry = mgr.getMacEntry(bpath, new EthernetAddress(src));
+                    } catch (Exception e) {
+                        unexpected(e);
+                    }
+
+                    Packet payload = inPktDecoded.getPayload();
+                    if (inPktDecoded.getEtherType() == EtherTypes.VLANTAGGED.shortValue()) {
+                        payload = payload.getPayload();
+                    }
+                    if (payload instanceof ARP) {
+                        assertTrue(nc.toString() + ea.toString(),
+                                entry.getInetAddresses().size() == 1);
+                        assertArrayEquals(nc.toString() + "," + ea.toString(),
+                                sender, entry.getInetAddresses().iterator().next().getAddress() );
+                    } else {
+                        assertTrue(nc.toString() + ea.toString(), entry.getInetAddresses().size() == 0);
+                    }
+
+                    List<RawPacket> transDatas = stub.getTransmittedDataPacket();
+
+                    if (ethtype.shortValue() == EtherTypes.IPv4.shortValue()) {
+                        // TODO: code is not implemented yet.
+//                        assertEquals(nc.toString() + "," + ea.toString(),
+//                                mappedThis.size(), transDatas.size());
+                    } else {
+                        assertEquals(nc.toString() + "," + ea.toString(),
+                                mappedThis.size() - 1, transDatas.size());
+                    }
+
+
+                    for (RawPacket raw: transDatas) {
+                        Packet pkt = stub.decodeDataPacket(raw);
+                        assertTrue(nc.toString() + ea.toString() + raw.getOutgoingNodeConnector(),
+                                mappedThis.contains(raw.getOutgoingNodeConnector()));
+                        assertFalse(nc.toString() + ea.toString() + raw.getOutgoingNodeConnector(),
+                                noMappedThis.contains(raw.getOutgoingNodeConnector()));
+                        if (ethtype.shortValue() == EtherTypes.ARP.shortValue() ||
+                            (ethtype.shortValue() == EtherTypes.IPv4.shortValue() &&
+                             !raw.getOutgoingNodeConnector().equals(nc))) {
+                            assertFalse(raw.getOutgoingNodeConnector().equals(nc));
+                            assertEquals(nc.toString() + "," +  ea.toString(), inPktDecoded, pkt);
+
+                            if (ethtype.shortValue() == EtherTypes.IPv4.shortValue()) {
+                                checkOutEthernetPacketIPv4(nc.toString() + "," + ea.toString(),
+                                        (Ethernet)pkt, EtherTypes.IPv4, src, dst, vlan);
+                            } else if (ethtype.shortValue() == EtherTypes.ARP.shortValue()){
+                                checkOutEthernetPacket(nc.toString() + "," + ea.toString(),
+                                        (Ethernet)pkt, EtherTypes.ARP, src, dst, vlan,
+                                        EtherTypes.IPv4, ARP.REQUEST, src, dst, sender, target);
+                            } else {
+                                fail("unexpected packet received.");
+                            }
+                        } else {
+                            checkOutEthernetPacket(nc.toString() + "," + ea.toString(),
+                                    (Ethernet)pkt, EtherTypes.ARP, cntMac, src, vlan,
+                                    EtherTypes.IPv4, ARP.REQUEST, cntMac, src,
+                                    new byte[] {0, 0, 0, 0}, sender);
+                        }
+                    }
+                } else {
+                    if (nc != null) {
+                        assertEquals(nc.toString() + "," + ea.toString(), PacketResult.IGNORED, result);
+                    } else {
+                        assertEquals(ea.toString(), PacketResult.IGNORED, result);
+                    }
+                }
+                iphost++;
+            }
+        }
+    }
+
+    /**
+     * common method for test which use BroadCast Packet (ARP Request packet).
+     * this method expected that action for received packet is flooding to mapped port.
+     */
+    private void testReceiveDataPacketBCLoopLearned(VTNManagerImpl mgr, VBridgePath bpath,
+           MapType type, short vlan, Set<NodeConnector> mappedThis, Set<NodeConnector> noMappedThis,
+           TestStub stub) {
+        testReceiveDataPacketCommonLoopLearned(mgr, bpath, MapType.PORT, vlan,
+                mappedThis, noMappedThis, stub, (short)1, EtherTypes.ARP);
+    }
+
+    /**
+     * common method for test which use UniCast Packet (IPv4 packet).
+     * this method expected that action for received packet is output to learned port.
+     */
+    private void testReceiveDataPacketUCLoopLearned(VTNManagerImpl mgr, VBridgePath bpath,
+            MapType type, short vlan, Set<NodeConnector> mappedThis, Set<NodeConnector> noMappedThis,
+            TestStub stub) {
+        testReceiveDataPacketCommonLoopLearned(mgr, bpath, MapType.PORT, vlan,
+                                mappedThis, noMappedThis, stub, (short)0, EtherTypes.IPv4);
+    }
+
+    /**
+     * common method for
+     * {@link testReceiveDataPacketBCLoop} and {@link testReceiveDataPacketUCLoop}.
+     * this method expected that action for received packet is a port host is connected to.
+     *
+     */
+    private void testReceiveDataPacketCommonLoopLearned(VTNManagerImpl mgr, VBridgePath bpath,
+            MapType type, short vlan, Set<NodeConnector> mappedThis, Set<NodeConnector> noMappedThis,
+            TestStub stub, short bc, EtherTypes ethtype) {
+        ISwitchManager swmgr = mgr.getSwitchManager();
+        byte[] cntMac = swmgr.getControllerMAC();
+
+        for (NodeConnector nc: mappedThis) {
+
+            // first learned hosts to vbridge.
+            testReceiveDataPacketCommonLoop(mgr, bpath, MapType.PORT, vlan,
+                    mappedThis, noMappedThis, stub, (short)0, EtherTypes.IPv4, nc);
+
+            // mac addresses have been learned at this point.
+            for (NodeConnector innc: mappedThis) {
+                byte tip = 1;
+                boolean first = false;
+                for (EthernetAddress ea: createEthernetAddresses(false)) {
+                    byte [] bytes = ea.getValue();
+                    byte [] src;
+                    if (bc > 0) {
+                        src = new byte[] {(byte)0xff, (byte)0xff, (byte)0xff,
+                                            (byte)0xff, (byte)0xff, (byte)0xff};
+                    } else {
+                        src = new byte[] {(byte)0x00, (byte)0x00, (byte)0x00,
+                                            (byte)0xff, (byte)0xff, (byte)0x11};
+                    }
+                    byte [] dst = new byte[] {bytes[0], bytes[1], bytes[2],
+                                            bytes[3], bytes[4], bytes[5]};
+                    byte [] sender = new byte[] {(byte)192, (byte)168, (byte)0, (byte)250};
+                    byte [] target = new byte[] {(byte)192, (byte)168, (byte)0, (byte)tip};
+
+                    RawPacket inPkt = null;
+                    if (ethtype.shortValue() == EtherTypes.IPv4.shortValue()) {
+                        inPkt = createIPv4RawPacket(src, dst, sender, target,
+                                                        (vlan > 0) ? vlan : -1, innc);
+                    } else if (ethtype.shortValue() == EtherTypes.ARP.shortValue()){
+                        // not used case.
+                    }
+
+                    Ethernet inPktDecoded = (Ethernet)stub.decodeDataPacket(inPkt);
+                    PacketResult result = mgr.receiveDataPacket(inPkt);
+
+                    if (innc != null &&
+                        innc.getType() == NodeConnector.NodeConnectorIDType.OPENFLOW) {
+                        assertEquals(nc.toString() + ea.toString(), PacketResult.KEEP_PROCESSING, result);
+
+                        MacAddressEntry entry = null;
+                        try {
+                            entry = mgr.getMacEntry(bpath, new EthernetAddress(src));
+                        } catch (Exception e) {
+                            unexpected(e);
+                        }
+
+                        Packet payload = inPktDecoded.getPayload();
+                        if (inPktDecoded.getEtherType() == EtherTypes.VLANTAGGED.shortValue()) {
+                            payload = payload.getPayload();
+                        }
+                        if (payload instanceof ARP) {
+                            assertTrue(nc.toString() + ea.toString(),
+                                        entry.getInetAddresses().size() == 1);
+                            assertArrayEquals(nc.toString() + "," + ea.toString(),
+                                        sender, entry.getInetAddresses().iterator().next().getAddress() );
+                        } else {
+                            assertTrue(nc.toString() + ea.toString(), entry.getInetAddresses().size() == 0);
+                        }
+
+                        List<RawPacket> transDatas = stub.getTransmittedDataPacket();
+                        if (!first) {
+                            // TODO: code is not implemented yet.
+//                            assertEquals(nc.toString() + "," + ea.toString(),
+//                                    2, transDatas.size());
+                            first = true;
+                        } else {
+                            assertEquals(nc.toString() + "," + ea.toString(),
+                                    1, transDatas.size());
+                        }
+
+                        for (RawPacket raw : transDatas) {
+                            raw = transDatas.get(0);
+                            Packet pkt = stub.decodeDataPacket(raw);
+
+                            Ethernet eth = (Ethernet)pkt;
+                            short outEthType;
+                            if (vlan > 0) {
+                                IEEE8021Q vlantag = (IEEE8021Q)eth.getPayload();
+                                outEthType = vlantag.getEtherType();
+                            } else {
+                                outEthType = eth.getEtherType();
+                            }
+
+                            if (outEthType == EtherTypes.ARP.shortValue() &&
+                                    raw.getOutgoingNodeConnector().equals(innc)) {
+                                // this is a packet to detect IP address of host
+                                // which has no IP address.
+                                checkOutEthernetPacket(nc.toString() + "," + ea.toString(),
+                                    (Ethernet)pkt, EtherTypes.ARP, cntMac, src, vlan,
+                                    EtherTypes.IPv4, ARP.REQUEST, cntMac, src,
+                                    new byte[] {0, 0, 0, 0}, sender);
+                            } else {
+                                assertEquals(nc.toString() + "," +  ea.toString(),
+                                        inPktDecoded, pkt);
+                                checkOutEthernetPacketIPv4(nc.toString() + "," + ea.toString(),
+                                    (Ethernet)pkt, EtherTypes.IPv4, src, dst, vlan);
+                            }
+                        }
+                    } else {
+                        if (innc != null) {
+                            assertEquals(innc.toString() + "," + ea.toString(), PacketResult.IGNORED, result);
+                        } else {
+                            assertEquals(ea.toString(), PacketResult.IGNORED, result);
+                        }
+                    }
+                    tip++;
+                }
+            }
+
+            Status st = mgr.flushMacEntries(bpath);
+            assertTrue(st.isSuccess());
+        }
+    }
+}
diff --git manager/implementation/src/test/java/org/opendaylight/vtn/manager/internal/cluster/VBridgeStateTest.java manager/implementation/src/test/java/org/opendaylight/vtn/manager/internal/cluster/VBridgeStateTest.java
new file mode 100644
index 0000000..87f4507
--- /dev/null
+++ manager/implementation/src/test/java/org/opendaylight/vtn/manager/internal/cluster/VBridgeStateTest.java
@@ -0,0 +1,89 @@
+/*
+ * Copyright (c) 2013 NEC Corporation
+ * All rights reserved.
+ *
+ * This program and the accompanying materials are made available under the
+ * terms of the Eclipse Public License v1.0 which accompanies this
+ * distribution, and is available at http://www.eclipse.org/legal/epl-v10.html
+ */
+
+package org.opendaylight.vtn.manager.internal.cluster;
+
+import java.util.HashSet;
+import java.util.Set;
+
+import org.junit.Test;
+import org.opendaylight.controller.sal.core.Node;
+import org.opendaylight.vtn.manager.VNodeState;
+import org.opendaylight.vtn.manager.internal.TestBase;
+
+/**
+ * Junit test for {@link VBridgeState}.
+ */
+public class VBridgeStateTest extends TestBase {
+    private Set<ObjectPair<Node, Node>> fp = new HashSet<ObjectPair<Node, Node>>();
+    /**
+     * Test case for getter methods.
+     */
+    @Test
+    public void testGetter() {
+        VNodeState[] states = VNodeState.values();
+
+        for (VNodeState state: states) {
+            VBridgeState bst = new VBridgeState(state);
+            assertSame(state, bst.getState());
+            assertEquals(fp, bst.getFaultedPaths());
+        }
+    }
+
+    /**
+     * Test case for {@link VBridgeState#equals(object)} and {@link VBridgeState#hashCode()}.
+     */
+    @Test
+    public void testEquals() {
+        HashSet<Object> set = new HashSet<Object>();
+        VNodeState[] states = VNodeState.values();
+
+        for (VNodeState state: states) {
+            VBridgeState bst1 = new VBridgeState(state);
+            VBridgeState bst2 = new VBridgeState(state);
+
+            testEquals(set, bst1, bst2);
+        }
+
+        int required = states.length;
+        assertEquals(required, set.size());
+
+    }
+
+    /**
+     * Test case for {@link VBridgeState#toString()}.
+     */
+    @Test
+    public void testToString() {
+        String prefix = "VBridgeState[";
+        String suffix = "]";
+
+        VNodeState[] states = VNodeState.values();
+        for (VNodeState state: states) {
+            VBridgeState bst = new VBridgeState(state);
+            String s = "state=" + state.toString();
+            String f = "faulted=" + fp.toString();
+            String required = joinStrings(prefix, suffix, ",", s, f);
+
+            assertEquals(required, bst.toString());
+        }
+    }
+
+    /**
+     * Ensure that {@link VBridgeState} is serializable.
+     */
+    @Test
+    public void testSerialize() {
+        VNodeState[] states = VNodeState.values();
+        for (VNodeState state: states) {
+            VBridgeState bst = new VBridgeState(state);
+            serializeTest(bst);
+        }
+    }
+}
diff --git manager/implementation/src/test/resources/logback.xml manager/implementation/src/test/resources/logback.xml
new file mode 100644
index 0000000..55e82e6
--- /dev/null
+++ manager/implementation/src/test/resources/logback.xml
@@ -0,0 +1,28 @@
+<?xml version="1.0" encoding="UTF-8"?>
+
+<!--
+#
+# Copyright (c) 2013 NEC Corporation
+# All rights reserved.
+#
+# This program and the accompanying materials are made available under the
+# terms of the Eclipse Public License v1.0 which accompanies this
+# distribution, and is available at http://www.eclipse.org/legal/epl-v10.html
+#
+-->
+
+<configuration scan="true">
+  <appender name="STDOUT" class="ch.qos.logback.core.ConsoleAppender">
+    <encoder>
+      <pattern>%date{"yyyy-MM-dd HH:mm:ss.SSS z"} [%thread] %-5level %logger{36} - %msg%n</pattern>
+    </encoder>
+  </appender>
+
+  <root level="error">
+    <appender-ref ref="STDOUT" />
+  </root>
+
+  <!-- Suppress informational logs on tests. -->
+  <logger name="org.opendaylight.vtn" level="WARN"/>
+
+</configuration>
diff --git manager/northbound/src/test/java/org/opendaylight/vtn/manager/northbound/IpAddressSetTest.java manager/northbound/src/test/java/org/opendaylight/vtn/manager/northbound/IpAddressSetTest.java
new file mode 100644
index 0000000..264c9f2
--- /dev/null
+++ manager/northbound/src/test/java/org/opendaylight/vtn/manager/northbound/IpAddressSetTest.java
@@ -0,0 +1,85 @@
+/*
+ * Copyright (c) 2013 NEC Corporation
+ * All rights reserved.
+ *
+ * This program and the accompanying materials are made available under the
+ * terms of the Eclipse Public License v1.0 which accompanies this
+ * distribution, and is available at http://www.eclipse.org/legal/epl-v10.html
+ */
+
+package org.opendaylight.vtn.manager.northbound;
+
+import java.net.InetAddress;
+import java.util.HashSet;
+import java.util.List;
+import java.util.Set;
+
+import org.junit.Test;
+
+/**
+ * Junit test for {@link IpAddressSet}.
+ */
+public class IpAddressSetTest extends TestBase {
+    /**
+     * Test case for getter methods.
+     */
+    @Test
+    public void testGetter() {
+        List<Set<InetAddress>> ips = createInetAddresses();
+        Set<IpAddress> addrSet;
+
+        for (Set<InetAddress> ipset: ips) {
+            addrSet = new HashSet<IpAddress>();
+            if (ipset != null && ipset.size() != 0) {
+                for (InetAddress ip: ipset) {
+                   addrSet.add(new IpAddress(ip));
+                }
+                IpAddressSet iaddrs = new IpAddressSet(ipset);
+                assertEquals(addrSet, iaddrs.getAddresses());
+                assertSame(ipset.size(), iaddrs.getLength());
+            } else {
+                if (ipset == null) {
+                    assertNull(ipset);
+                } else {
+                    assertEquals(0, ipset.size());
+                }
+            }
+        }
+    }
+
+    /**
+     * Test case for {@link IpAddressSet#equals(Object)} and {@link IpAddressSet#hashCode()}.
+     */
+    @Test
+    public void testEquals() {
+        List<Set<InetAddress>> ips = createInetAddresses();
+        HashSet<Object> set = new HashSet<Object>();
+        int required = 0;
+
+        for (Set<InetAddress> ipset: ips) {
+            if (ipset != null && ipset.size() != 0) {
+                IpAddressSet iaddrs1 = new IpAddressSet(ipset);
+                IpAddressSet iaddrs2 = new IpAddressSet(ipset);
+
+                testEquals(set, iaddrs1, iaddrs2);
+                required++;
+            }
+        }
+
+        assertEquals(required, set.size());
+    }
+
+    /*
+     * Ensure that {@link IpAddressSet} is mapped to XML root element.
+     */
+    @Test
+    public void testJAXB() {
+        List<Set<InetAddress>> ips = createInetAddresses();
+        for (Set<InetAddress> ipset: ips) {
+            if (ipset != null && ipset.size() != 0) {
+                IpAddressSet iaddrs = new IpAddressSet(ipset);
+                jaxbTest(iaddrs, "inetAddresses");
+            }
+        }
+    }
+}
diff --git manager/northbound/src/test/java/org/opendaylight/vtn/manager/northbound/IpAddressTest.java manager/northbound/src/test/java/org/opendaylight/vtn/manager/northbound/IpAddressTest.java
new file mode 100644
index 0000000..368fdf5
--- /dev/null
+++ manager/northbound/src/test/java/org/opendaylight/vtn/manager/northbound/IpAddressTest.java
@@ -0,0 +1,89 @@
+/*
+ * Copyright (c) 2013 NEC Corporation
+ * All rights reserved.
+ *
+ * This program and the accompanying materials are made available under the
+ * terms of the Eclipse Public License v1.0 which accompanies this
+ * distribution, and is available at http://www.eclipse.org/legal/epl-v10.html
+ */
+
+package org.opendaylight.vtn.manager.northbound;
+
+
+import java.net.InetAddress;
+import java.util.HashSet;
+import java.util.List;
+import java.util.Set;
+
+import org.junit.Test;
+/**
+ * Junit test for {@link IpAddress}.
+ */
+public class IpAddressTest extends TestBase {
+    /**
+     * Test case for getter methods.
+     */
+    @Test
+    public void testGetter() {
+        List<Set<InetAddress>> ips = createInetAddresses();
+        for (Set<InetAddress> ipset: ips) {
+            if (ipset != null && ipset.size() != 0) {
+                for (InetAddress iaddr: ipset) {
+                    IpAddress ia = new IpAddress(iaddr);
+                    assertEquals(iaddr.getHostAddress(), ia.getAddress());
+                }
+            } else {
+                if (ipset == null) {
+                    assertNull(ipset);
+                } else {
+                    assertEquals(0, ipset.size());
+                }
+            }
+        }
+    }
+
+    /**
+     * Test case for {@link IpAddress#equals(Object)} and {@link IpAddress#hashCode()}.
+     */
+    @Test
+    public void testEquals() {
+        List<Set<InetAddress>> ips = createInetAddresses();
+        HashSet<Object> set = new HashSet<Object>();
+
+        for (Set<InetAddress> ipset: ips) {
+            set = new HashSet<Object>();
+            if (ipset != null && ipset.size() != 0) {
+                for (InetAddress iaddr: ipset) {
+                    IpAddress ia1 = new IpAddress(iaddr);
+                    IpAddress ia2 = new IpAddress(iaddr);
+
+                    testEquals(set, ia1, ia2);
+                }
+            int required = ipset.size();
+            assertEquals(required, set.size());
+            } else {
+                if (ipset == null) {
+                    assertNull(ipset);
+                } else {
+                    assertEquals(0, ipset.size());
+                }
+            }
+        }
+    }
+
+    /*
+     * Ensure that {@link IpAddress} is mapped to XML root element.
+     */
+    @Test
+    public void testJAXB() {
+        List<Set<InetAddress>> ips = createInetAddresses();
+        for (Set<InetAddress> ipset: ips) {
+            if (ipset != null && ipset.size() != 0) {
+                for (InetAddress iaddr: ipset) {
+                    IpAddress ia = new IpAddress(iaddr);
+                    jaxbTest(ia, "inetAddress");
+                }
+            }
+        }
+    }
+}
