/*
 * Copyright (c) 2012-2014 NEC Corporation
 * All rights reserved.
 *
 * This program and the accompanying materials are made available under the
 * terms of the Eclipse Public License v1.0 which accompanies this
 * distribution, and is available at http://www.eclipse.org/legal/epl-v10.html
 */

/**
 * @brief   ODBC Manager
 * @file    odbcm_query_processor.cc
 *
 */

#include "odbcm_query_processor.hh"
#include "odbcm_utils.hh"

using unc::uppl::QueryProcessor;

/**
 * @Description : Constructor for QueryProcessor
 * @param[in]   : None
 * @return      : None
 **/
QueryProcessor::QueryProcessor() {
}

/**
 * @Description : Destructor for QueryProcessor
 * @param[in]   : None
 * @return      : None
 **/
QueryProcessor::~QueryProcessor() {
}

/**
 * @Description : This invokes SQLPrepare method, the query generated by
 *                QueryFactory will be given to SQLPrepare ODBC API to 
 *                prepare the statement
 * @param[in]   : sql_edit_query - specifies the framed query
 *                hstmt - statement handler which carries the SQL Query
 * @return      : ODBCM_RC_SUCCESS is returned when SQLPrepare is success
 *                otherwise DB related error code will be returned
 **/
ODBCM_RC_STATUS QueryProcessor::PrepareQueryStatement(
    std::string sql_edit_query, HSTMT &hstmt) {
  /** ODBC APIs return code with initialize 0 */
  RETCODE odbc_rc = SQL_SUCCESS;
  /** ODBC API call to prepare the statement for SQL query */
  SQLINTEGER  query_length;
  query_length = (SQLINTEGER)sql_edit_query.length();
  odbc_rc = SQLPrepare(
      hstmt, /** statement handler */
      (unsigned char*)sql_edit_query.c_str(), /** query string */
      query_length/*SQL_NTS*/);
  ODBCM_PROCESS_HANDLE_CHECK(hstmt, odbc_rc);
  if (odbc_rc != ODBCM_RC_SUCCESS &&
      odbc_rc != ODBCM_RC_SUCCESS_WITH_INFO) {
    pfc_log_error("ODBCM::QueryProcessor::PrepareQueryStatement: Error %s",
        ODBCMUtils::ODBCMUtils::get_RC_Details(odbc_rc).c_str());
    return (ODBCM_RC_STATUS) odbc_rc;
  }
  return ODBCM_RC_SUCCESS;
}

/**
 * @Description : This method invokes SQLExecute for write operation	 
 * @param[in]   : operation_type - specifies the db related operation
 *                i.e CREATE/DELETE/UPDATE/GETONEROW/GETBULK*
 *                hstmt - statement handler which carries the SQL Query
 * @return      : ODBCM_RC_SUCCESS is returned when SQLExecute is success
 *                otherwise DB related error code will be returned
 **/
ODBCM_RC_STATUS QueryProcessor::ExecuteEditDBQuery(
    UpplDbOperationType operation_type, const HSTMT &hstmt) {
  /** Initialize the local variables */
  SQLLEN    row_count = 0;                 // No of rows
  RETCODE   odbc_rc   = ODBCM_RC_SUCCESS;  // return val from SQL api
  /** SQL API to execute the query */
  odbc_rc = SQLExecute(hstmt);
  ODBCM_PROCESS_HANDLE_CHECK(hstmt, odbc_rc);
  if (odbc_rc != ODBCM_RC_SUCCESS &&
      odbc_rc != ODBCM_RC_SUCCESS_WITH_INFO) {
    pfc_log_error("ODBCM::QueryProcessor::ExecuteEditDBQuery: "
        "Error in SQLExecute: %s",
        ODBCMUtils::ODBCMUtils::get_RC_Details(odbc_rc).c_str());
    /** Get the diagnostics information */
    ODBCMUtils::OdbcmHandleDiagnosticsPrint(SQL_HANDLE_STMT, hstmt);
    return (ODBCM_RC_STATUS)odbc_rc;
  }
  /** Get the row count from SQL */
  odbc_rc = SQLRowCount(hstmt, &row_count);
  ODBCM_PROCESS_HANDLE_CHECK(hstmt, odbc_rc);
  if (odbc_rc != ODBCM_RC_SUCCESS &&
      odbc_rc != ODBCM_RC_SUCCESS_WITH_INFO) {
    pfc_log_error("ODBCM::QueryProcessor::ExecuteEditDBQuery: "
        "Error in SQLRowCount: %s",
        ODBCMUtils::ODBCMUtils::get_RC_Details(odbc_rc).c_str());
    return (ODBCM_RC_STATUS)odbc_rc;
  }
  pfc_log_trace("ODBCM::QueryProcessor::ExecuteEditDBQuery: "
      "No. of rows inserted/affected: %d", (uint32_t)row_count);
  return ODBCM_RC_SUCCESS;
}

/**
 * @Description : This method invokes SQLExecute for read operation
 * @param[in]   : operation_type - specifies the db related operation
 *                i.e CREATE/DELETE/UPDATE/GETONEROW/GETBULK*
 *                hstmt - statement handler which carries the SQL Query
 * @return      : ODBCM_RC_SUCCESS is returned when SQLExecute is success
 *                otherwise DB related error code will be returned
 **/
ODBCM_RC_STATUS QueryProcessor::ExecuteReadDBQuery(
    UpplDbOperationType operation_type, HSTMT &hstmt) {
  /** Initialize the local variables */
  SQLLEN      row_count = 0;
  RETCODE     odbc_rc = ODBCM_RC_SUCCESS;
  /** Execute the query */
  odbc_rc = SQLExecute(hstmt);
  ODBCM_PROCESS_HANDLE_CHECK(hstmt, odbc_rc);
  if (odbc_rc != ODBCM_RC_SUCCESS &&
      odbc_rc != ODBCM_RC_SUCCESS_WITH_INFO) {
    pfc_log_error("ODBCM::QueryProcessor::ExecuteReadDBQuery: "
      "Error in SQLExecute: %d, %s", odbc_rc,
      ODBCMUtils::get_RC_Details(odbc_rc).c_str());
    return (ODBCM_RC_STATUS)odbc_rc;
  }
  /** Fetch the no. of row return in last executed query */
  odbc_rc = SQLRowCount(hstmt, &row_count);
  ODBCM_PROCESS_HANDLE_CHECK(hstmt, odbc_rc);
  if (odbc_rc != ODBCM_RC_SUCCESS &&
      odbc_rc != ODBCM_RC_SUCCESS_WITH_INFO) {
    pfc_log_error("ODBCM::QueryProcessor::ExecuteReadDBQuery: "
      "Error in SQLRowCount: %s",
      ODBCMUtils::get_RC_Details(odbc_rc).c_str());
    return (ODBCM_RC_STATUS)odbc_rc;
  }
  /** If no record found for the read query */
  pfc_log_trace("ODBCM::QueryProcessor::ExecuteReadDBQuery: "
    "Row count = %" UNC_PFMT_SQLLEN, row_count);
  if (row_count <= 0) {
    return ODBCM_RC_RECORD_NOT_FOUND;
  } else {
    ODBCM_PROCESS_HANDLE_CHECK(hstmt, odbc_rc);
    if (odbc_rc != ODBCM_RC_SUCCESS &&
        odbc_rc != ODBCM_RC_SUCCESS_WITH_INFO) {
      pfc_log_error("ODBCM::QueryProcessor::ExecuteReadDBQuery: "
        "Error in SQLFetch: %s",
        ODBCMUtils::get_RC_Details(odbc_rc).c_str());
      return (ODBCM_RC_STATUS)odbc_rc;
    }
  }
  return ODBCM_RC_SUCCESS;
}

/**
 * @Description : This method is invoked for db group operations
 * @param[in]   : operation_type - specifies the db related operation
 *                i.e CREATE/DELETE/UPDATE/GETONEROW/GETBULK*
 *                hstmt - statement handler which carries the SQL Query
 * @return      : ODBCM_RC_SUCCESS is returned when SQLExecute is success
 *                otherwise DB related error code will be returned
 **/
ODBCM_RC_STATUS QueryProcessor::ExecuteGroupOperationQuery(
    UpplDbOperationType operation_type, const HSTMT &hstmt) {
  /** Initialize the local variables */
  RETCODE   odbc_rc    = ODBCM_RC_SUCCESS;
  SQLLEN    row_count = 0;
  /** Execute the query */
  odbc_rc = SQLExecute(hstmt);
  ODBCM_PROCESS_HANDLE_CHECK(hstmt, odbc_rc);
  if (odbc_rc != ODBCM_RC_SUCCESS &&
      odbc_rc != ODBCM_RC_SUCCESS_WITH_INFO) {
    pfc_log_error("ODBCM::QueryProcessor::ExecuteGroupOperationQuery: "
      "Error in SQLExecute :%s",
      ODBCMUtils::get_RC_Details(odbc_rc).c_str());
    return (ODBCM_RC_STATUS)odbc_rc;
  }
  /** Fetch the no. of row return in last executed query */
  odbc_rc = SQLRowCount(hstmt, &row_count);
  ODBCM_PROCESS_HANDLE_CHECK(hstmt, odbc_rc);
  if (odbc_rc != ODBCM_RC_SUCCESS &&
      odbc_rc != ODBCM_RC_SUCCESS_WITH_INFO) {
    pfc_log_error("ODBCM::QueryProcessor::ExecuteGroupOperationQuery: "
      "Error in SQLRowCount: %s",
      ODBCMUtils::get_RC_Details(odbc_rc).c_str());
    return (ODBCM_RC_STATUS)odbc_rc;
  }
  /** If no record found for the query */
  pfc_log_trace("ODBCM::QueryProcessor::ExecuteGroupOperationQuery: "
      "No of rows in last executed query: %" UNC_PFMT_SQLLEN, row_count);
  if (row_count <= 0) {
    pfc_log_debug("ODBCM::QueryProcessor::ExecuteGroupOperationQuery: "
      "No record exists !!!");
    return ODBCM_RC_ROW_NOT_EXISTS;
  } else {
    pfc_log_debug("ODBCM::QueryProcessor::ExecuteGroupOperationQuery: "
                 "ODBCM_RC_ROW_EXISTS");
    /** If row exists, fetch data from database */
    odbc_rc = SQLFetch(hstmt);
    ODBCM_PROCESS_HANDLE_CHECK(hstmt, odbc_rc);
    if (odbc_rc != ODBCM_RC_SUCCESS &&
        odbc_rc != ODBCM_RC_SUCCESS_WITH_INFO) {
      pfc_log_error("ODBCM::QueryProcessor::ExecuteGroupOperationQuery: "
        "Error in SQLFetch :%s",
      ODBCMUtils::get_RC_Details(odbc_rc).c_str());
      return (ODBCM_RC_STATUS)odbc_rc;
    }
    return ODBCM_RC_ROW_EXISTS;
  }
  return ODBCM_RC_SUCCESS;
}

/**
 * @Description : To invoke SQLExecDirect
 * @param[in]   : operation_type - specifies the db related operation
 *                i.e CREATE/DELETE/UPDATE/GETONEROW/GETBULK*
 *                query - specifies the framed query
 *                hstmt - statement handler which carries the SQL Query
 * @return      : ODBCM_RC_SUCCESS is returned when SQLExecDirect is success
 *                otherwise DB related error code will be returned
 **/
ODBCM_RC_STATUS QueryProcessor::ExecuteQueryDirect(
    UpplDbOperationType operation_type,
    std::string query,
    const HSTMT &qp_hstmt) {
  /** Initialise the lcoal variables */
  RETCODE odbc_rc = ODBCM_RC_SUCCESS;
  SQLINTEGER  query_length;
  /** Execute the query using SQLExecDirect api */
  query_length = (SQLINTEGER)query.length();
  odbc_rc = SQLExecDirect(qp_hstmt,
              (unsigned char*)query.c_str(), query_length /*SQL_NTS*/);
  /** Validate the return value */
  if (odbc_rc != ODBCM_RC_SUCCESS &&
      odbc_rc != ODBCM_RC_SUCCESS_WITH_INFO) {
    pfc_log_error("ODBCM::QueryProcessor::ExecuteQueryDirect: "
      "Error in SQLExecDirect: %s",
      ODBCMUtils::get_RC_Details(odbc_rc).c_str());
    return (ODBCM_RC_STATUS)odbc_rc;
  }
  return ODBCM_RC_SUCCESS;
}

/**
 * @Description : This method will be invoked for executing a transaction
 * @param[in]   : operation_type - specifies the db related operation
 *                i.e CREATE/DELETE/UPDATE/GETONEROW/GETBULK*
 *                query - specifies the framed query
 *                hstmt - statement handler which carries the SQL Query
 * @return      : ODBCM_RC_SUCCESS is returned when ExecuteTransaction is
 *                success otherwise DB related error code will be returned
 **/
ODBCM_RC_STATUS QueryProcessor::ExecuteTransaction(
    UpplDbOperationType operation_type,
    std::string *query,
    const HSTMT &hstmt) {
  /** Initialise the local variables */
  uint8_t           loop            = 0;
  uint8_t           is_exists_false = 0;
  SQLLEN            row_count       = 0;
  SQLRETURN         odbc_rc         = ODBCM_RC_SUCCESS;
  ODBCM_RC_STATUS   status          = ODBCM_RC_SUCCESS;
  SQLINTEGER  query_length = 0;
  /** If the requested operation is to check
    * candidate db is dirty or not */
  switch (operation_type) {
    case ISCANDIDATEDIRTY:
      for (loop = 0; loop < ODBCM_MAX_CANDIDATE_TABLES; loop++) {
        /** If the query is NULL */
        if (NULL == query[loop].c_str()) {
          pfc_log_error("ODBCM::QueryProcessor::ExecuteTransaction: "
                       "IsCandidateDiry Query:%d string is empty", loop);
          return ODBCM_RC_ERROR_IN_FRAMEQUERY;
        }
        odbcm_debug_info("ODBCM::QueryProcessor::ExecuteTransaction: "
            "Execute query:%d \"%s\"", loop, query[loop].c_str());
        /** Execute the query */
        query_length = (SQLINTEGER)query[loop].length();
        odbc_rc = SQLExecDirect(hstmt,
                                (unsigned char*)query[loop].c_str(),
                                query_length /*SQL_NTS*/);
        //  ODBCM_PROCESS_HANDLE_CHECK(hstmt, odbc_rc);
        if ((odbc_rc != SQL_SUCCESS) &&
            (odbc_rc != SQL_SUCCESS_WITH_INFO)) {
          pfc_log_error("ODBCM::QueryProcessor::ExecuteTransaction :"
                        "Error in SQLExecDirect for operation_type:%d: %s",
                        operation_type,
                        ODBCMUtils::get_RC_Details(odbc_rc).c_str());
          return (ODBCM_RC_STATUS)odbc_rc;
        }
        /** Fetch the no. of row return in last executed query */
        odbc_rc = SQLRowCount(hstmt, &row_count);
        //  ODBCM_PROCESS_HANDLE_CHECK(hstmt, odbc_rc);
        if (odbc_rc != ODBCM_RC_SUCCESS &&
            odbc_rc != ODBCM_RC_SUCCESS_WITH_INFO) {
          pfc_log_error("ODBCM::QueryProcessor::ExecuteTransaction: "
                        "Error in SQLRowCount for operation_type:%d: %s",
                        operation_type,
                        ODBCMUtils::get_RC_Details(odbc_rc).c_str());
          return (ODBCM_RC_STATUS)odbc_rc;
        }
        pfc_log_debug("ODBCM::QueryProcessor::ExecuteTransaction: %"
            UNC_PFMT_SQLLEN " rows with cs_row_status not as APPLIED",
            row_count);
        /* Close the cursor */
        odbc_rc = SQLCloseCursor(hstmt);
        //  ODBCM_PROCESS_HANDLE_CHECK(hstmt, odbc_rc);
        if ((odbc_rc != SQL_SUCCESS) &&
            (odbc_rc != SQL_SUCCESS_WITH_INFO)) {
          pfc_log_error("ODBCM::QueryProcessor::ExecuteTransaction: "
                        "Error in SQLCloseCursor for operation_type:%d: %s",
                        operation_type,
                        ODBCMUtils::get_RC_Details(odbc_rc).c_str());
          return (ODBCM_RC_STATUS)odbc_rc;
        }

        if (row_count >= 1) {
          /** If any table in candidate db is dirty, break and return */
          status = ODBCM_RC_CANDIDATE_DIRTY;
          pfc_log_info("ODBCM::QueryProcessor::ExecuteTransaction:"
              " ODBCM_RC_CANDIDATE_DIRTY");
          break;
        }
        if (row_count == 0) is_exists_false++;
      }  // for loop

      /** Confirm there is no cs_row_status(!APPLIED) in candidate db */
      if (is_exists_false == ODBCM_MAX_UPPL_TABLES) {
        status = ODBCM_RC_SUCCESS;  // ODBCM_RC_CANDIDATE_NO_DIRTY
        pfc_log_debug("ODBCM::QueryProcessor::ExecuteTransaction:"
            " ODBCM_RC_SUCCESS (ODBCM_RC_CANDIDATE_NO_DIRTY)");
      }
      break;
    case COPYDATABASE:
    case COMMITALLCONFIG:
    case CLEARDATABASE:
    case CLEARONEINSTANCE:
      loop = 0;
      /** Execute the query until end_of_query */
      while (strcmp(query[loop].c_str(), "end_of_query") != 0) {
        if (NULL == query[loop].c_str()) {
          pfc_log_debug("ODBCM::QueryProcessor::ExecuteTransaction: "
                       "operation_type:%d, Query:%d string is empty",
                       operation_type, loop);
          return ODBCM_RC_ERROR_IN_FRAMEQUERY;
        }
        odbcm_debug_info("ODBCM::QueryProcessor::ExecuteTransaction: "
            "operation_type:%d, Execute query:%d: \"%s\"",
            operation_type, loop, query[loop].c_str());
        /** Execute the query */
        query_length = (SQLINTEGER)query[loop].length();
        odbc_rc = SQLExecDirect(hstmt,
                                (unsigned char*)query[loop].c_str(),
                                query_length/*SQL_NTS*/);
        //  ODBCM_PROCESS_HANDLE_CHECK(hstmt, odbc_rc);
        if (odbc_rc != SQL_SUCCESS &&
            odbc_rc != SQL_NO_DATA &&
            odbc_rc != SQL_NO_DATA_FOUND &&
            odbc_rc != SQL_SUCCESS_WITH_INFO) {
          pfc_log_error("ODBCM::QueryProcessor::ExecuteTransaction: "
                        "Error in SQLExecDirect for operation_type:%d "
                        "in query:%d: %s",
                        operation_type, loop,
                        ODBCMUtils::get_RC_Details(odbc_rc).c_str());
          break;
        }
        SQLCloseCursor(hstmt);
        loop++;
      }
      break;
    default:
      pfc_log_error("ODBCM::QueryProcessor::ExecuteTransaction:"
                    " ODBCM_RC_SUCCESS");
  }
  if (odbc_rc != SQL_SUCCESS && odbc_rc != SQL_SUCCESS_WITH_INFO
    && odbc_rc != SQL_NO_DATA_FOUND && odbc_rc != SQL_NO_DATA) {
    return (ODBCM_RC_STATUS)odbc_rc;
  }
  return status;
}
/**EOF*/
