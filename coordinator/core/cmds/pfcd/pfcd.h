/*
 * Copyright (c) 2010-2013 NEC Corporation
 * All rights reserved.
 * 
 * This program and the accompanying materials are made available under the
 * terms of the Eclipse Public License v1.0 which accompanies this
 * distribution, and is available at http://www.eclipse.org/legal/epl-v10.html
 */

#ifndef	_PFCD_PFCD_H
#define	_PFCD_PFCD_H

/*
 * Common definitions for PFC daemon.
 */

#include <errno.h>
#include <stdarg.h>
#include <pthread.h>
#include <sys/stat.h>
#include <pfc/base.h>
#include <pfc/config.h>
#include <pfc/conf.h>
#include <pfc/log.h>
#include <pfc/util.h>
#include <pfc/event.h>
#include <pfc/path.h>
#include <pfc/hash.h>
#include <pfc/listmodel.h>
#include <pfc/iostream.h>
#include <ctrl_proto.h>
#include <cmdutil.h>
#include <libpfc_impl.h>

/*
 * Permission bits for system directory.
 */
#define	PFCD_DIR_PERM							\
	(S_IRWXU | S_IRGRP | S_IXGRP | S_IROTH | S_IXOTH)	/* 0755 */

/*
 *  Daemon running mode.
 */
typedef enum {
	PFCD_MODE_DAEMON,		/* Daemon mode (default) */
	PFCD_MODE_FGDAEMON,		/* Foreground daemon mode */
	PFCD_MODE_DEBUG,		/* Debug mode */
} pfcd_mode_t;

extern pfcd_mode_t	pfcd_mode;

/*
 * Daemon state.
 */
typedef enum {
	PFCD_STATE_BOOTING,		/* We're in early bootstrap code */
	PFCD_STATE_INIT,		/* We're initializing PFC service */
	PFCD_STATE_MODLOAD,		/* We're loading modules */
	PFCD_STATE_RUNNING,		/* PFC service is running */
	PFCD_STATE_SHUTDOWN,		/* We're in normal shutdown sequence */
	PFCD_STATE_FATAL,		/* Fatal error has been detected */
	PFCD_STATE_DEAD,		/* We must die as soon as possible. */
} pfcd_state_t;

/* Symbols generated by gencopy. */
extern const char	copyright[];
extern const char	build_stamp[];

/*
 * Program name.
 */
extern const char	*pfcd_progname;

/*
 * True if pfcd is running as debug mode.
 */
extern uint32_t		pfcd_debug;

/*
 * Process ID of PFC daemon.
 */
extern pid_t		pfcd_pid;

/*
 * Export system file paths.
 */
extern const char	*pfcd_module_dir;
extern const char	*pfcd_modcache_dir;
extern const char	*pfcd_work_dir;
extern const char	*pfcd_stderr_logdir;
extern const char	*pfcd_pid_file_path;

extern size_t		pfcd_work_dir_len;

/*
 * Global option block handle.
 */
extern pfc_cfblk_t	pfcd_options;

/*
 * Internal thread IDs.
 */
extern pthread_t	pfcd_main_thread;

/*
 * Shutdown flag.
 */
extern volatile uint32_t	pfcd_shutdown_received;

/*
 * Prototypes.
 */
extern void	fatal(const char *fmt, ...)
	PFC_FATTR_PRINTFLIKE(1, 2) PFC_FATTR_NORETURN;
extern void	fatal_status(int status, const char *fmt, ...)
	PFC_FATTR_PRINTFLIKE(2, 3) PFC_FATTR_NORETURN;
extern void	warning(const char *fmt, ...) PFC_FATTR_PRINTFLIKE(1, 2);
extern void	die(const char *fmt, ...)
	PFC_FATTR_PRINTFLIKE(1, 2) PFC_FATTR_NORETURN;

#ifdef	__GNUC__

#ifdef	PFC_VERBOSE_DEBUG
extern void	verbose(const char *fmt, ...) PFC_FATTR_PRINTFLIKE(1, 2);
#else	/* !PFC_VERBOSE_DEBUG */
#define	verbose(fmt, ...)	((void)0)
#endif	/* PFC_VERBOSE_DEBUG */

#else	/* !__GNUC__ */

#ifdef	PFC_VERBOSE_DEBUG
extern void	verbose_v(const char *fmt, va_list ap)
	PFC_FATTR_PRINTFLIKE(1, 0);
#endif	/* PFC_VERBOSE_DEBUG */

static inline void PFC_FATTR_PRINTFLIKE(1, 2)
verbose(const char *fmt, ...)
{
#ifdef	PFC_VERBOSE_DEBUG
	va_list	ap;

	va_start(ap, fmt);
	verbose_v(fmt, ap);
	va_end(ap);
#endif	/* PFC_VERBOSE_DEBUG */
}

#endif	/* __GNUC__ */

extern pfcd_state_t	pfcd_getstate(void);
extern void		pfcd_setstate(pfcd_state_t state);
extern int		pfcd_getexstatus(void);

extern void	path_init(void);
extern void	path_verify(const char *path);
extern char	*path_create(const char *name, size_t namelen);

extern void	ctrl_init(void);
extern void	ctrl_main(void);
extern void	ctrl_cleanup(void);

extern void	stderr_init(int nullfd);

extern void	resource_init(void);

extern void		signal_bootstrap(void);
extern void		signal_init(void);
extern pfc_bool_t	signal_dispatch(void);
extern void		signal_delete_shutdown(sigset_t *mask);
extern void		signal_child_init(void);
#ifdef	PFC_VERBOSE_DEBUG
extern void		signal_mask_assert(void);
#else	/* !PFC_VERBOSE_DEBUG */
#define	signal_mask_assert()		((void)0)
#endif	/* PFC_VERBOSE_DEBUG */

extern void		event_init(void);
extern void		event_post_global(pfc_evtype_t type);
extern pfc_bool_t	event_post_signal(int sig);

extern void	module_init(int argc, char **argv, uint32_t flags);
extern int	module_boot(void);
extern void	module_shutdown(void);
extern void	module_check_conf(void);

extern void	logging_init(pfc_log_fatal_t handler);

extern void	child_init(void);
extern void	child_fini(void);
extern void	child_killall(void);

/*
 * Flags for module_init().
 */
#define	PFCD_MODF_ALL		PFC_CONST_U(0x1)	/* load all modules */
#define	PFCD_MODF_CHECKONLY	PFC_CONST_U(0x2)	/* conf check only */

/*
 * static inline void *
 * pfcd_malloc(size_t size)
 *	Allocate a buffer of at least the specified size.
 *	A program exits abnormally on failure.
 */
static inline void *
pfcd_malloc(size_t size)
{
	void	*buf = malloc(size);

	if (PFC_EXPECT_FALSE(buf == NULL)) {
		fatal("Failed to allocate memory: %" PFC_PFMT_SIZE_T, size);
		/* NOTREACHED */
	}

	return buf;
}

/*
 * static inline void
 * pfcd_free(void *buf)
 *	Free a buffer allocated by pfcd_malloc().
 */
static inline void
pfcd_free(void *buf)
{
	free(buf);
}

#endif	/* !_PFCD_PFCD_H */
