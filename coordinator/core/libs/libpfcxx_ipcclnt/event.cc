/*
 * Copyright (c) 2012-2013 NEC Corporation
 * All rights reserved.
 * 
 * This program and the accompanying materials are made available under the
 * terms of the Eclipse Public License v1.0 which accompanies this
 * distribution, and is available at http://www.eclipse.org/legal/epl-v10.html
 */

/*
 * event.cc - IPC event APIs for IPC client written in C++ language.
 */

#include <cstring>
#include <pfcxx/ipc_client.hh>
#include <pfc/atomic.h>
#include <pfc/debug.h>
#include "ipcclnt_event.hh"

namespace pfc {
namespace core {
namespace ipc {

#define EVENT_HANDLER_PTR(ptr)  (reinterpret_cast<IpcEventHandler *>(ptr))

/*
 * Class which implements internal work for IPC event subsystem.
 */
class IpcEventSystem
{
public:
    static void    handler(pfc_ipcevent_t *event, pfc_ptr_t arg);
    static void    dtor(pfc_ptr_t arg);

    /*
     * static inline pfc_ipcevhdlr_t *
     * getIdPointer(IpcEventHandler *handler)
     *      Return a pointer to IPC event handler ID in the specified handler
     *      instance.
     */
    static inline pfc_ipcevhdlr_t *
    getIdPointer(IpcEventHandler *handler)
    {
        return &handler->_id;
    }

    /*
     * static inline void
     * initAttributes(ipc_evattr_t &newattr, IpcEventHandler *handler,
     *                const IpcEventAttr *attr)
     *      Initialize the IPC event attributes object for C++ API.
     *
     * Remarks:
     *      This method copies ipc_evattr_t in `attr' to `newattr'.
     *      Never pass `newattr' to pfc_ipcevent_attr_destroy().
     */
    static inline void
    initAttributes(ipc_evattr_t &newattr, IpcEventHandler *handler,
                   const IpcEventAttr *attr)
    {
        // Copy event attributes in order to update handler's argument.
        if (attr == NULL) {
            pfc_ipcevattr_t  *a(PFC_IPCEVATTR_PTR(&newattr));
            PFC_ASSERT_INT(pfc_ipcevent_attr_init(a), 0);
        }
        else {
            memcpy(&newattr, &attr->_attr, sizeof(newattr));
        }

        PFC_ASSERT(newattr.eva_arg == NULL);
        PFC_ASSERT(newattr.eva_argdtor == NULL);
        newattr.eva_arg = handler;
        newattr.eva_argdtor = &IpcEventSystem::dtor;

        // Set IPC_EVATTRF_CXX flag to attribute flag bits.
        // This makes pfc_ipcevent_add_handler() fail if `idp' does not point
        // PFC_IPCEVHDLR_INVALID.
        newattr.eva_flags |= IPC_EVATTRF_CXX;
    }
};

/*
 * void PFC_ATTR_HIDDEN
 * IpcEventSystem::handler(pfc_ipcevent_t *event, pfc_ptr_t arg)
 *      Common entry function of C++ IPC event handler.
 */
void PFC_ATTR_HIDDEN
IpcEventSystem::handler(pfc_ipcevent_t *event, pfc_ptr_t arg)
{
    IpcEventHandler  *handler(EVENT_HANDLER_PTR(arg));
    IpcEvent         ev(event);

    // Call actual event handler.
    PFC_ASSERT(handler != NULL);
    handler->eventHandler(ev);
}

/*
 * void PFC_ATTR_HIDDEN
 * IpcEventSystem::dtor(pfc_ptr_t arg)
 *      Destructor of IPC event handler instance.
 */
void PFC_ATTR_HIDDEN
IpcEventSystem::dtor(pfc_ptr_t arg)
{
    IpcEventHandler  *handler(EVENT_HANDLER_PTR(arg));

#ifdef	PFC_VERBOSE_DEBUG
    (void)pfc_atomic_swap_uint32(&handler->_id, PFC_IPCEVHDLR_INVALID);
#endif	/* PFC_VERBOSE_DEBUG */

    delete handler;
}

/*
 * int
 * add_event_handler(const char *channel, IpcEventHandler *handler,
 *                   const IpcEventAttr *attr)
 *      Add an IPC event handler which receives events generated by the IPC
 *      channel specified by `channel'.
 *
 *      `channel' is a pointer to IPC channel name, not IPC channel address.
 *      The IPC server's address part in `channel' is simply ignored.
 *      If NULL is specified, the channel name of the current default
 *      connection is used.
 *
 *      `attr' is a pointer to event attributes object which determines
 *      behavior of event handler. If NULL is specified to `attr', an event
 *      handler is added with default attributes.
 *
 * Calling/Exit State:
 *      Upon successful completion, zero is returned.
 *      Otherwise error number which indicates the cause of error is returned.
 *
 * Remarks:
 *      `handler' is deleted on error except for EEXIST error.
 */
int
add_event_handler(const char *channel, IpcEventHandler *handler,
                  const IpcEventAttr *attr)
{
    if (PFC_EXPECT_FALSE(handler == NULL)) {
        return EINVAL;
    }

    ipc_evattr_t  newattr;
    IpcEventSystem::initAttributes(newattr, handler, attr);

    const char       *name(handler->getName());
    pfc_ipcevhdlr_t  *idp(IpcEventSystem::getIdPointer(handler));

    return pfc_ipcevent_add_handler(idp, channel, &IpcEventSystem::handler,
                                    PFC_IPCEVATTR_PTR(&newattr), name);
}

/*
 * int
 * remove_event_handler(pfc_ipcevhdlr_t id)
 *      Remove the event handler associated with the specified ID.
 *
 * Calling/Exit State:
 *      Upon successful completion, zero is returned.
 *      Otherwise error number which indicates the cause of error is returned.
 */
int
remove_event_handler(pfc_ipcevhdlr_t id)
{
    return pfc_ipcevent_remove_handler(id);
}

/*
 * void
 * setup_wrapper(pfc_ipcevfunc_t &wrapper, ipc_evattr_t &newattr,
 *               IpcEventHandler *handler, const IpcEventAttr *attr)
 *      Set up C++ IPC event wrapper function.
 *      This function is used by PFC C++ module system.
 */
void
setup_wrapper(pfc_ipcevfunc_t &wrapper, ipc_evattr_t &newattr,
              IpcEventHandler *handler, const IpcEventAttr *attr)
{
    IpcEventSystem::initAttributes(newattr, handler, attr);
    wrapper = &IpcEventSystem::handler;
}

/*
 * pfc_ipcevhdlr_t *
 * get_id_pointer(IpcEventHandler *handler)
 * setup_id(IpcEventHandler *handler, pfc_ipcevhdlr_t newid)
 *      Return a pointer to IPC event handler ID in the specified handler
 *      instance.
 *      This function is used by PFC C++ module system.
 */
pfc_ipcevhdlr_t *
get_id_pointer(IpcEventHandler *handler)
{
    return IpcEventSystem::getIdPointer(handler);
}

/*
 * IpcEventHandler::~IpcEventHandler()
 *      Destructor of IpcEventHandler.
 */
IpcEventHandler::~IpcEventHandler()
{
#ifdef  PFC_VERBOSE_DEBUG
    // Ensure that this handler is not registered to the IPC event subsystem.
    pfc_ipcevhdlr_t  id(pfc_atomic_swap_uint32(&_id, (uint32_t)-1));
    PFC_ASSERT(id == PFC_IPCEVHDLR_INVALID);
#endif  /* PFC_VERBOSE_DEBUG */
}

/*
 * const char *
 * IpcEventHandler::getName(void)
 *      Return the name of this handler.
 */
const char *
IpcEventHandler::getName(void)
{
    return NULL;
}

} // ipc
} // core
} // pfc
