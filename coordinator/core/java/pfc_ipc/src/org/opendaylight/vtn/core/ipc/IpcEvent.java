/*
 * Copyright (c) 2012-2013 NEC Corporation
 * All rights reserved.
 * 
 * This program and the accompanying materials are made available under the
 * terms of the Eclipse Public License v1.0 which accompanies this
 * distribution, and is available at http://www.eclipse.org/legal/epl-v10.html
 */

package org.opendaylight.vtn.core.ipc;

import org.opendaylight.vtn.core.util.TimeSpec;
import org.opendaylight.vtn.core.util.HostAddress;

/**
 * <p>
 *   An immutable object which represents an event on the IPC server.
 * </p>
 * <p>
 *   An instance of IPC event contains the following information.
 * </p>
 * <dl>
 *   <dt id="ipc-event-channel">IPC channel name</dt>
 *   <dd>
 *     IPC channel name of the IPC server which generated the IPC event.
 *   </dd>
 *
 *   <dt id="ipc-event-host">Host address</dt>
 *   <dd>
 *     The host address which specifies the host on which the IPC server is
 *     running.
 *   </dd>
 *
 *   <dt id="ipc-event-service">IPC service name</dt>
 *   <dd>
 *     The name of IPC service in the IPC server which generated the IPC event.
 *     The IPC service name specifies the sub-component in the IPC server.
 *   </dd>
 *
 *   <dt id="ipc-event-type">IPC event type</dt>
 *   <dd>
 *     An integer which represents type of the IPC event.
 *     The meaning of IPC event types are defined by the component in the
 *     IPC server which generates the IPC event.
 *     The minimum and maximum value of the IPC event type are zero and 63
 *     respectively.
 *   </dd>
 *
 *   <dt id="ipc-event-time">Creation time</dt>
 *   <dd>
 *     A realtime clock which represents the creation time of the IPC event.
 *   </dd>
 *
 *   <dt id="ipc-event-serial">Serial number</dt>
 *   <dd>
 *     An unique integer assigned to each IPC event.
 *     Note that the serial number of IPC event is unsigned 32-bit integer.
 *   </dd>
 *
 *   <dt id="ipc-event-data">Additional data</dt>
 *   <dd>
 *     The IPC server can set more than zero additional data represented by
 *     {@link IpcDataUnit} instance.
 *   </dd>
 * </dl>
 * <p>
 *   When the IPC client library receives an IPC event, it delivers an IPC
 *   event to all {@link IpcEventHandler} instances which watch the event.
 *   Each {@link IpcEventHandler} can determine the actual meaning of a
 *   received IPC event by IPC channel name, IPC service name, and IPC event
 *   type in the IPC event.
 * </p>
 * <p>
 *   Note that an {@code IpcEvent} instance will be invalidated when it
 *   completes to be delivered to all IPC event handlers. So any access to
 *   an {@code IpcEvent} instance must complete in the call of
 *   {@link IpcEventHandler#eventReceived(IpcEvent)}.
 *   Any access to an invalidated {@link IpcEvent} instance will throw an
 *   {@code IllegalStateException}.
 * </p>
 * <h4 id="chstate-event">Channel State Change Event</h4>
 * <p>
 *   A channel state change event is a pseudo IPC event generated by the
 *   IPC client library, which is used to notify change of IPC event listener
 *   session's state.
 *   A channel state change event is generated when an IPC event listener
 *   session has been established or discarded.
 *   The IPC client can monitor IPC server by adding IPC event handler which
 *   listens channel state change event.
 * </p>
 * <p>
 *   An IPC event type of a channel state change event is one of the
 *   followings.
 * </p>
 * <dl>
 *   <dt>{@link ChannelUpEvent#TYPE}</dt>
 *   <dd>
 *     A channel state change event has been generated because an IPC event
 *     listener session has been successfully established.
 *     In this case, a {@link ChannelUpEvent} is passed to
 *     {@link IpcEventHandler#eventReceived(IpcEvent)}.
 *   </dd>
 *
 *   <dt>{@link ChannelDownEvent#TYPE}</dt>
 *   <dd>
 *     A channel state change event has been generated because an IPC event
 *     listener session has been disconnected.
 *     In this case, a {@link ChannelDownEvent} is passed to
 *     {@link IpcEventHandler#eventReceived(IpcEvent)}.
 *     The cause of disconnection, which is represented by
 *     {@link ChannelDownCause}, can be obtained by
 *     {@link ChannelDownEvent#getCause()}.
 *   </dd>
 *
 *   <dt>{@link ChannelStateEvent#TYPE}</dt>
 *   <dd>
 *     A channel state notification event has been requested explicitly by
 *     {@link IpcEventSystem#notifyState(int)}.
 *     The state of the IPC event listener session, which is represented
 *     by {@link ChannelState}, can be obtained by
 *     {@link ChannelStateEvent#getState()}.
 *   </dd>
 * </dl>
 * <p>
 *   The IPC client library establishes only one IPC event listener session
 *   to an IPC server. If more than one IPC event handlers which listen events
 *   on the same IPC server, they share one IPC event listener session.
 *   So a newly added channel state change event handler may not receive a
 *   channel state change event which reports an initial state if another
 *   IPC event handler which listens events on the same IPC server is already
 *   registered. If each handler needs to recognize initial state of the
 *   event listener session, it needs to implement one of the following
 *   workarounds.
 * </p>
 * <ul>
 *   <li>
 *     Register all IPC event handlers with specifying an empty IPC host set,
 *     and then adds host addresses to the IPC host set using
 *     {@link IpcHostSet#add(HostAddress)}.
 *     This will raise a channel state change event which reports initial
 *     state of the event listener session because it is established when
 *     {@link IpcHostSet#add(HostAddress)} is invoked.
 *   </li>
 *   <li>
 *     After all IPC event handlers are registered,
 *     retrieve the state of the IPC event listener session by calling
 *     {@link IpcEventSystem#getChannelState(String)} or
 *     {@link IpcEventSystem#getChannelState(String, HostAddress)}.
 *   </li>
 *   <li>
 *     After an IPC event handler which listens channel notification events
 *     is registered, raise a channel state notification event by calling
 *     {@link IpcEventSystem#notifyState(int)}.
 *   </li>
 * </ul>
 *
 * @since	C10
 * @see		IpcEventSystem#initialize(IpcEventConfiguration)
 */
public class IpcEvent
{
	/**
	 * <p>
	 *   The minimum value of IPC event type.
	 * </p>
	 */
	public final static int  MIN_TYPE = 0;

	/**
	 * <p>
	 *   The maximum value of IPC event type.
	 * </p>
	 */
	public final static int  MAX_TYPE = 63;

	/**
	 * <p>
	 *   A handle for this IPC event.
	 * </p>
	 */
	private final long  _event;

	/**
	 * <p>
	 *   Serial number of this event.
	 * </p>
	 */
	private final int  _serial;

	/**
	 * <p>
	 *   IPC event type of this event.
	 * </p>
	 */
	private final int  _type;

	/**
	 * <p>
	 *   Creation time of this event.
	 * </p>
	 */
	private TimeSpec  _time;

	/**
	 * <p>
	 *   IPC channel name.
	 * </p>
	 */
	private String  _channel;

	/**
	 * <p>
	 *   Host address of the IPC server corresponding to this event.
	 * </p>
	 */
	private HostAddress  _host;

	/**
	 * <p>
	 *   IPC service name.
	 * </p>
	 */
	private String  _service;

	/**
	 * <p>
	 *   IPC client session used to derive additional data in this event.
	 * </p>
	 */
	private EventClientSession  _session;

	/**
	 * <p>
	 *   Busy counter which protects IPC event handle.
	 * </p>
	 */
	private long  _busy = 1;

	/**
	 * <p>
	 *   Determine whether this event is valid or not.
	 * </p>
	 */
	private boolean  _valid = true;

	/**
	 * <p>
	 *   Construct a new IPC event.
	 * </p>
	 *
	 * @param event		An IPC event handle.
	 * @param serial	Serial number of this event.
	 * @param type		An IPC event type.
	 * @param session	Client session handle in this event.
	 */
	IpcEvent(long event, int serial, int type, long session)
	{
		_event = event;
		_serial = serial;
		_type = type;
		_session = new EventClientSession(session);
	}

	/**
	 * <p>
	 *   Return the <a href="#ipc-event-type">IPC event type</a> of
	 *   this event.
	 * </p>
	 *
	 * @return	An integer which represents type of this event.
	 * @throws IllegalStateException
	 *	This event is already invalidated.
	 */
	public final int getType()
	{
		check();

		return _type;
	}

	/**
	 * <p>
	 *   Return the <a href="#ipc-event-serial">serial number</a> of
	 *   this event.
	 * </p>
	 *
	 * @return	The serial number of this event.
	 * @throws IllegalStateException
	 *	This event is already invalidated.
	 */
	public final int getSerialNumber()
	{
		check();

		return _serial;
	}

	/**
	 * <p>
	 *   Return a {@link TimeSpec} instance which contains the
	 *   <a href="#ipc-event-time">creation time</a> of this IPC event.
	 * </p>
	 *
	 * @return	A {@link TimeSpec} instance.
	 * @throws IllegalStateException
	 *	This event is already invalidated.
	 */
	public final synchronized TimeSpec getTime()
	{
		long event = getEvent();

		try {
			TimeSpec ts = _time;

			if (ts == null) {
				ts = getTime(event);
				_time = ts;
			}

			return ts;
		}
		finally {
			release();
		}
	}

	/**
	 * <p>
	 *   Return an <a href="#ipc-event-channel">IPC channel name</a>
	 *   in this IPC event.
	 * </p>
	 *
	 * @return	An IPC channel name in this event.
	 * @throws IllegalStateException
	 *	This event is already invalidated.
	 */
	public final synchronized String getChannelName()
	{
		long event = getEvent();

		try {
			String channel = _channel;

			if (channel == null) {
				channel = getChannelName(event);
				_channel = channel;
			}

			return channel;
		}
		finally {
			release();
		}
	}

	/**
	 * <p>
	 *   Return the <a href="#ipc-event-host">host address</a>
	 *   in this IPC event.
	 * </p>
	 * <ul>
	 *   <li>
	 *     If this event was generated by the IPC server, the host
	 *     address returned by this method specifies the host on which
	 *     the IPC server is running.
	 *   </li>
	 *   <li>
	 *     If this event is a <a href="#chstate-event">channel state
	 *     change event</a> generated by the IPC client, the host address
	 *     returned by this method specifies the address of the peer
	 *     connected to the IPC event listener session.
	 *   </li>
	 * </ul>
	 *
	 * @return	A {@link HostAddress} instance which represents the
	 *		host address.
	 * @throws IllegalStateException
	 *	This event is already invalidated.
	 */
	public final synchronized HostAddress getHostAddress()
	{
		long event = getEvent();

		try {
			HostAddress host = _host;

			if (host == null) {
				host = getHostAddress(event);
				if (host == null) {
					// This must be a local address.
					host = HostAddress.getLocalAddress();
				}
				_host = host;
			}

			return host;
		}
		finally {
			release();
		}
	}

	/**
	 * <p>
	 *   Return the <a href="#ipc-event-service">IPC service name</a>
	 *   in this IPC event.
	 * </p>
	 * <p>
	 *   If this event is a <a href="#chstate-event">channel state
	 *   change event</a> generated by the IPC client, a unique,
	 *   printable, but unspecified string is returned.
	 *   {@link #isStateChange()} must be used to determine whether
	 *   this event is a channel state change event or not.
	 * </p>
	 *
	 * @return	An IPC service name in this event.
	 * @throws IllegalStateException
	 *	This event is already invalidated.
	 */
	public final synchronized String getServiceName()
	{
		long event = getEvent();

		try {
			String service = _service;

			if (service == null) {
				service = getServiceName(event);
				_service = service;
			}

			return service;
		}
		finally {
			release();
		}
	}

	/**
	 * <p>
	 *   Return a {@link ClientSession} instance used to derive
	 *   <a href="#ipc-event-data">additional data</a> from this event.
	 * </p>
	 * <p>
	 *   The following methods can be used to derive additional data
	 *   from this IPC event.
	 * </p>
	 * <ul>
	 *   <li>
	 *     {@link ClientSession#getResponseCount()} returns the number of
	 *     additional data in this event.
	 *   </li>
	 *   <li>
	 *     {@link ClientSession#getResponse(int)} returns an
	 *     {@link IpcDataUnit} instance at the specified additional array
	 *     index in this event.
	 *   </li>
	 * </ul>
	 * <p>
	 *   A {@link ClientSession} returned by this method is fixed to
	 *   <strong>RESULT</strong> state, and it overrides the following
	 *   methods.
	 * </p>
	 * <ul>
	 *   <li>
	 *     {@link ClientSession#invoke()} always returns
	 *     {@link ClientSession#RESP_FATAL}.
	 *   </li>
	 *   <li>
	 *     The following methods do nothing.
	 *     <ul>
	 *       <li>{@link ClientSession#reset(String, int)}</li>
	 *       <li>{@link ClientSession#addOutput(IpcDataUnit)}</li>
	 *       <li>{@link ClientSession#setTimeout(TimeSpec)}</li>
	 *       <li>{@link ClientSession#forward(ClientSession)}</li>
	 *       <li>{@link ClientSession#forward(ClientSession, int)}</li>
	 *       <li>{@link ClientSession#forward(ClientSession, int, int)}</li>
	 *       <li>{@link ClientSession#cancel()}</li>
	 *       <li>{@link ClientSession#discard()}</li>
	 *       <li>{@link ClientSession#destroy()}</li>
	 *     </ul>
	 *   </li>
	 * </ul>
	 * <p>
	 *   Note that a {@link ClientSession} instance is invalidated
	 *   when this event is invalidated.
	 *   Any access to an invalidated {@link ClientSession} instance
	 *   will throw an {@link IpcBadClientSessionException}.
	 * </p>
	 *
	 * @return	a {@link ClientSession} instance.
	 * @throws IllegalStateException
	 *	This event is already invalidated.
	 */
	public final ClientSession getSession()
	{
		check();

		return _session;
	}

	/**
	 * <p>
	 *   Determine whether this event is a
	 *   <a href="#chstate-event">channel state change event</a> or not.
	 * </p>
	 * <p>
	 *   If this method returns {@code true}, this event must be one of
	 *   the followings.
	 * </p>
	 * <ul>
	 *   <li>
	 *     {@link ChannelUpEvent}
	 *   </li>
	 *   <li>
	 *     {@link ChannelDownEvent}
	 *   </li>
	 *   <li>
	 *     {@link ChannelStateEvent}
	 *   </li>
	 * </ul>
	 *
	 * @return	{@code true} if this event is a channel state change
	 *		event. Otherwise {@code false}.
	 * @throws IllegalStateException
	 *	This event is already invalidated.
	 */
	public boolean isStateChange()
	{
		check();

		return false;
	}

	/**
	 * <p>
	 *   Return a string representation of this event.
	 * </p>
	 *
	 * @return	A string representation of this event.
	 */
	@Override
	public final synchronized String toString()
	{
		String className = getClass().getName();
		int idx = className.lastIndexOf('.');

		if (idx >= 0) {
			className = className.substring(idx + 1);
		}

		StringBuilder buf = new StringBuilder(className);
		if (_valid) {
			buf.append(" date=[");
			buf.append(getTime().toDate());
			buf.append("] serial=");
			buf.append(getSerialNumber());
			buf.append(" channel=");
			buf.append(getChannelName());
			buf.append('@');
			buf.append(getHostAddress());

			String opt = toStringImpl();
			if (opt != null) {
				buf.append(opt);
			}
		}
		else {
			buf.append(" (invalid)");
		}

		return buf.toString();
	}

	/**
	 * <p>
	 *   Return an additional string to be added to the result of
	 *   {@link #toString()}.
	 * </p>
	 *
	 * @return	A string to be added to the result of
	 *		{@link #toString()}.
	 * @throws IllegalStateException
	 *	This event is already invalidated.
	 */
	synchronized String toStringImpl()
	{
		return " type=" + getServiceName() + "/" + getType();
	}

	/**
	 * <p>
	 *   Ensure that this event is still available.
	 * </p>
	 *
	 * @throws IllegalStateException
	 *	This event is already invalidated.
	 */
	synchronized void check()
	{
		if (_valid) {
			assert _busy > 0;

			return;
		}

		throw new IllegalStateException
			("IPC event is already invalidated.");
	}

	/**
	 * <p>
	 *   Return the IPC event handle of this event.
	 *   This method increments the busy counter {@link #_busy} on
	 *   successful return.
	 * </p>
	 *
	 * @return	An IPC event handle.
	 * @throws IllegalStateException
	 *	This event is already invalidated.
	 */
	private synchronized long getEvent()
	{
		check();
		_busy++;

		return _event;
	}

	/**
	 * <p>
	 *   Release the event handle held by {@link #getEvent()}.
	 * </p>
	 */
	private synchronized void release()
	{
		assert _busy > 0 : "Invalid busy counter: " + _busy;

		_busy--;
		if (_busy > 0) {
			// This event must be still retained.
			return;
		}

		assert !_valid;
		destroy(_event);
	}

	/**
	 * <p>
	 *   Invalidate this IPC event.
	 * </p>
	 *
	 * @return	{@code true} if the IPC event handle should be
	 *		destroyed. {@code false} if the IPC event handle
	 *		should be retained.
	 */
	private synchronized boolean invalidate()
	{
		// Invalidate this IPC event.
		_valid = false;

		// Invalidate client session in this event.
		_session.invalidate();
		_session = null;

		assert _busy > 0 : "Invalid busy counter: " + _busy;
		_busy--;

		return (_busy == 0);
	}

	/**
	 * <p>
	 *   Return a {@link TimeSpec} instance which contains the creation
	 *   time of this event.
	 * </p>
	 *
	 * @param event		An IPC event handle.
	 * @return		A {@link TimeSpec} instance.
	 */
	private native TimeSpec getTime(long event);

	/**
	 * <p>
	 *   Return a string which keeps the name of IPC channel name.
	 * </p>
	 *
	 * @param event		An IPC event handle.
	 * @return		An IPC channel name in this event.
	 */
	private native String getChannelName(long event);

	/**
	 * <p>
	 *   Return a host address in this IPC event.
	 * </p>
	 *
	 * @param event		An IPC event handle.
	 * @return		A {@link HostAddress} instance in this event.
	 *			{@code null} is returned if a local address
	 *			is set in this event.
	 */
	private native HostAddress getHostAddress(long event);

	/**
	 * <p>
	 *   Return an IPC service name in this event.
	 * </p>
	 *
	 * @param event		An IPC event handle.
	 * @return		An IPC service name in this event.
	 */
	private native String getServiceName(long event);

	/**
	 * <p>
	 *   Destroy the IPC event handle.
	 * </p>
	 *
	 * @param event		An IPC event handle to be destroyed.
	 */
	private synchronized native void destroy(long event);

	/**
	 * <p>
	 *   Pseudo IPC client session only used to derive additional data
	 *   in an IPC event.
	 * </p>
	 */
	private final class EventClientSession extends ClientSession
	{
		/**
		 * <p>
		 *   Construct a new IPC client session for an IPC event.
		 * </p>
		 *
		 * @param session	An IPC client session handle.
		 */
		EventClientSession(long session)
		{
			super(session);
		}

		/**
		 * <p>
		 *   Do nothing because this session is immutable.
		 * </p>
		 *
		 * @param session	Always ignored.
		 * @param name		Always ignored.
		 * @param service	Always ignored.
		 */
		@Override
		void reset(long session, String name, int service)
			throws IpcException
		{
		}

		/**
		 * <p>
		 *   Do nothing because this session is immutable.
		 * </p>
		 *
		 * @param unit		Always ignored.
		 * @throws IpcBadClientSessionException
		 *	This session is already destroyed.
		 */
		@Override
		public void addOutput(IpcDataUnit unit) throws IpcException
		{
			release(this.getSession());
		}

		/**
		 * <p>
		 *   Do nothing because this session is immutable.
		 * </p>
		 *
		 * @param session	Always ignored.
		 * @param sec		Always ignored.
		 * @param nsec		Always ignored.
		 */
		@Override
		void setTimeout(long session, long sec, long nsec)
			throws IpcException
		{
		}

		/**
		 * <p>
		 *   Do nothing because this session is immutable.
		 * </p>
		 *
		 * @param dst		Always ignored.
		 * @param src		Always ignored.
		 */
		@Override
		void forward(long dst, long src, int beginIndex, int endIndex)
			throws IpcException
		{
		}

		/**
		 * <p>
		 *   Do nothing because this session is immutable.
		 * </p>
		 *
		 * @param session	Always ignored.
		 * @param discard	Always ignored.
		 */
		@Override
		void cancel(long session, boolean discard)
			throws IpcException
		{
		}

		/**
		 * <p>
		 *   Do nothing because this session is immutable.
		 * </p>
		 *
		 * @param session	Always ignored.
		 * @return		{@link #RESP_FATAL} is always returned.
		 */
		@Override
		int invoke(long session) throws IpcException
		{
			return RESP_FATAL;
		}

		/**
		 * <p>
		 *   Do nothing because this session is destroyed when the
		 *   IPC event is destroyed.
		 * </p>
		 */
		@Override
		public void destroy()
		{
		}

		/**
		 * <p>
		 *   There is nothing to do on finalization.
		 * </p>
		 */
		@Override
		protected void finalize() throws Throwable
		{
		}

		/**
		 * <p>
		 *   Return the session handle of this instance.
		 *   This method uses {@link IpcEvent#_busy} as busy counter
		 *   instead of {@link ClientSession#_busy}.
		 * </p>
		 *
		 * @return	An IPC client session handle.
		 * @throws IpcBadClientSessionException
		 *	This session is already destroyed.
		 */
		@Override
		long getSession() throws IpcException
		{
			IpcEvent ev = IpcEvent.this;

			synchronized (ev) {
				if (ev._valid) {
					assert ev._busy > 0;
					assert this._session != SESS_INVALID;
					ev._busy++;

					return this._session;
				}

				throw new IpcBadClientSessionException
					("Client session is already " +
					 "destroyed.");
			}
		}

		/**
		 * <p>
		 *   Release this session held by {@link #getSession()}.
		 * </p>
		 *
		 * @param session	An IPC client session handle.
		 */
		@Override
		void release(long session)
		{
			IpcEvent.this.release();
		}

		/**
		 * <p>
		 *   Invalidate this session.
		 *   This method must be called from
		 *   {@link IpcEvent#invalidate()}.
		 * </p>
		 */
		private void invalidate()
		{
			_session = SESS_INVALID;
		}
	}
}
